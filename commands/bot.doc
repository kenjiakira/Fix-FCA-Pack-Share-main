Tạo văn bản từ dữ liệu đầu vào chỉ văn bản
Cách đơn giản nhất để tạo văn bản bằng API Gemini là cung cấp cho mô hình một đầu vào chỉ văn bản, như trong ví dụ sau:


import { GoogleGenerativeAI } from "@google/generative-ai";
const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");

const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const prompt = "Explain how AI works";

const result = await model.generateContent(prompt);
console.log(result.response.text());
Trong trường hợp này, câu lệnh ("Giải thích cách hoạt động của AI") không bao gồm bất kỳ ví dụ đầu ra, hướng dẫn hệ thống hoặc thông tin định dạng nào. Đây là phương pháp không cần chụp ảnh. Đối với một số trường hợp sử dụng, lời nhắc một lần hoặc vài lần có thể tạo ra kết quả phù hợp hơn với kỳ vọng của người dùng. Trong một số trường hợp, bạn cũng nên cung cấp hướng dẫn hệ thống để giúp mô hình hiểu được nhiệm vụ hoặc tuân theo các nguyên tắc cụ thể.

Tạo văn bản từ dữ liệu đầu vào là văn bản và hình ảnh
API Gemini hỗ trợ phương thức nhập đa phương thức kết hợp văn bản với tệp phương tiện. Ví dụ sau đây cho thấy cách tạo văn bản từ dữ liệu đầu vào văn bản và hình ảnh:


import { GoogleGenerativeAI } from "@google/generative-ai";
import * as fs from 'node:fs';

const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

function fileToGenerativePart(path, mimeType) {
  return {
    inlineData: {
      data: Buffer.from(fs.readFileSync(path)).toString("base64"),
      mimeType,
    },
  };
}

const prompt = "Describe how this product might be manufactured.";
const imagePart = fileToGenerativePart("/path/to/image.png", "image/png");

const result = await model.generateContent([prompt, imagePart]);
console.log(result.response.text());
Tạo luồng văn bản
Theo mặc định, mô hình sẽ trả về một phản hồi sau khi hoàn tất toàn bộ quá trình tạo văn bản. Bạn có thể đạt được các lượt tương tác nhanh hơn bằng cách không chờ toàn bộ kết quả mà thay vào đó, hãy sử dụng tính năng truyền trực tuyến để xử lý một phần kết quả.

Ví dụ sau đây cho biết cách triển khai tính năng truyền trực tuyến bằng phương thức streamGenerateContent để tạo văn bản từ lời nhắc nhập chỉ văn bản.


import { GoogleGenerativeAI } from "@google/generative-ai";
const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const prompt = "Explain how AI works";

const result = await model.generateContentStream(prompt);

for await (const chunk of result.stream) {
  const chunkText = chunk.text();
  process.stdout.write(chunkText);
}
Tạo cuộc trò chuyện
SDK Gemini cho phép bạn thu thập nhiều vòng câu hỏi và câu trả lời, cho phép người dùng từng bước tìm ra câu trả lời hoặc được trợ giúp về các vấn đề gồm nhiều phần. Tính năng SDK này cung cấp một giao diện để theo dõi nhật ký cuộc trò chuyện, nhưng ở hậu trường, tính năng này sử dụng cùng một phương thức generateContent để tạo phản hồi.

Ví dụ về mã sau đây cho thấy cách triển khai tính năng trò chuyện cơ bản:


import { GoogleGenerativeAI } from "@google/generative-ai";
const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
const chat = model.startChat({
  history: [
    {
      role: "user",
      parts: [{ text: "Hello" }],
    },
    {
      role: "model",
      parts: [{ text: "Great to meet you. What would you like to know?" }],
    },
  ],
});

let result = await chat.sendMessage("I have 2 dogs in my house.");
console.log(result.response.text());
let result2 = await chat.sendMessage("How many paws are in my house?");
console.log(result2.response.text());
Bạn cũng có thể sử dụng tính năng phát trực tiếp kèm theo tính năng trò chuyện, như trong ví dụ sau:


import { GoogleGenerativeAI } from "@google/generative-ai";
const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const chat = model.startChat({
  history: [
    {
      role: "user",
      parts: [{ text: "Hello" }],
    },
    {
      role: "model",
      parts: [{ text: "Great to meet you. What would you like to know?" }],
    },
  ],
});

let result = await chat.sendMessageStream("I have 2 dogs in my house.");
for await (const chunk of result.stream) {
  const chunkText = chunk.text();
  process.stdout.write(chunkText);
}
let result2 = await chat.sendMessageStream("How many paws are in my house?");
for await (const chunk of result2.stream) {
  const chunkText = chunk.text();
  process.stdout.write(chunkText);
}
Định cấu hình tính năng tạo văn bản
Mỗi câu lệnh mà bạn gửi đến mô hình đều bao gồm các thông số kiểm soát cách mô hình tạo câu trả lời. Bạn có thể sử dụng GenerationConfig để định cấu hình các tham số này. Nếu bạn không định cấu hình các tham số, mô hình sẽ sử dụng các tuỳ chọn mặc định, tuỳ theo mô hình.

Ví dụ sau đây cho thấy cách định cấu hình một số tuỳ chọn có sẵn.


import { GoogleGenerativeAI } from "@google/generative-ai";
const genAI = new GoogleGenerativeAI("GEMINI_API_KEY");

const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const result = await model.generateContent({
    contents: [
        {
          role: 'user',
          parts: [
            {
              text: "Explain how AI works",
            }
          ],
        }
    ],
    generationConfig: {
      maxOutputTokens: 1000,
      temperature: 0.1,
    }
});

console.log(result.response.text());
Thêm hướng dẫn hệ thống
Hướng dẫn hệ thống cho phép bạn điều hướng hành vi của một mô hình dựa trên các nhu cầu và trường hợp sử dụng cụ thể của bạn.

Bằng cách đưa ra hướng dẫn cho hệ thống mô hình, bạn cung cấp thêm ngữ cảnh cho mô hình để hiểu được nhiệm vụ, tạo ra các phản hồi được tuỳ chỉnh hơn và tuân thủ các nguyên tắc cụ thể trong toàn bộ quá trình tương tác của người dùng với mô hình. Bạn cũng có thể chỉ định hành vi cấp sản phẩm bằng cách đặt hướng dẫn hệ thống, tách biệt với lời nhắc do người dùng cuối cung cấp.

Bạn có thể đặt hướng dẫn hệ thống khi khởi chạy mô hình:


// Set the system instruction during model initialization
const model = genAI.getGenerativeModel({
  model: "gemini-1.5-flash",
  systemInstruction: "You are a cat. Your name is Neko.",
});
Sau đó, bạn có thể gửi yêu cầu đến mô hình như bình thường.



Gemini 2.0 Flash Experimental hiện đã ra mắt! Tìm hiểu thêm
 Trang này được dịch bởi Cloud Translation API.
Switch to English
Trang chủ
Gemini API
Mô hình
Thông tin này có hữu ích không cho bạn không?

Gửi ý kiến phản hồiKhám phá các chức năng hỗ trợ thị giác với Gemini API

Python Node.js Go REST

API Gemini có thể xử lý hình ảnh và video, cho phép nhiều trường hợp sử dụng thú vị cho nhà phát triển. Một số tính năng thị giác của Gemini bao gồm khả năng:

Chú thích và trả lời các câu hỏi về hình ảnh
Bản chép lời và lý luận trên tệp PDF, bao gồm cả tài liệu dài có cửa sổ ngữ cảnh lên đến 2 triệu mã thông báo
Mô tả, phân đoạn và trích xuất thông tin từ video, bao gồm cả khung hình và âm thanh, dài tối đa 90 phút
Phát hiện các đối tượng trong hình ảnh và trả về toạ độ hộp giới hạn cho các đối tượng đó
Hướng dẫn này minh hoạ một số cách có thể dùng để nhắc Gemini API bằng hình ảnh và đầu vào video, cung cấp ví dụ về mã và trình bày các phương pháp hay nhất để nhắc bằng khả năng thị giác đa phương thức. Tất cả đầu ra đều chỉ ở dạng văn bản.

Trước khi bắt đầu: Thiết lập dự án và khoá API
Trước khi gọi API Gemini, bạn cần thiết lập dự án và định cấu hình khoá API.

 Mở rộng để xem cách thiết lập dự án và khoá API

Lời nhắc bằng hình ảnh
Trong hướng dẫn này, bạn sẽ tải hình ảnh lên bằng File API hoặc dưới dạng dữ liệu nội tuyến và tạo nội dung dựa trên những hình ảnh đó.

Thông tin kỹ thuật (hình ảnh)
Gemini 1.5 Pro và 1.5 Flash hỗ trợ tối đa 3.600 tệp hình ảnh.

Hình ảnh phải ở một trong các loại MIME dữ liệu hình ảnh sau:

PNG – image/png
JPEG – image/jpeg
WEBP – image/webp
HEIC – image/heic
HEIF – image/heif
Mỗi hình ảnh tương đương với 258 mã thông báo.

Mặc dù không có giới hạn cụ thể về số pixel trong hình ảnh ngoài cửa sổ ngữ cảnh của mô hình, nhưng hình ảnh lớn hơn sẽ được điều chỉnh theo tỷ lệ xuống độ phân giải tối đa là 3072x3072 trong khi vẫn giữ nguyên tỷ lệ khung hình ban đầu, còn hình ảnh nhỏ hơn sẽ được điều chỉnh theo tỷ lệ lên 768x768 pixel. Không có sự giảm chi phí đối với hình ảnh ở kích thước thấp hơn, ngoài băng thông hoặc cải thiện hiệu suất đối với hình ảnh ở độ phân giải cao hơn.

Để có kết quả tốt nhất:

Xoay hình ảnh theo hướng chính xác trước khi tải lên.
Tránh sử dụng hình ảnh bị mờ.
Nếu sử dụng một hình ảnh, hãy đặt câu lệnh văn bản sau hình ảnh.
Nhập hình ảnh
Đối với tổng kích thước tải trọng hình ảnh dưới 20 MB, bạn nên tải hình ảnh được mã hoá base64 lên hoặc tải trực tiếp các tệp hình ảnh được lưu trữ cục bộ lên.

Hình ảnh được mã hoá Base64
Bạn có thể tải URL hình ảnh công khai lên bằng cách mã hoá các URL đó dưới dạng tải trọng Base64. Bạn nên sử dụng thư viện httpx để tìm nạp URL hình ảnh. Ví dụ về mã sau đây cho biết cách thực hiện việc này:


import { GoogleGenerativeAI } from "@google/generative-ai";

// Access your API key as an environment variable (see "Set up your API key" above)
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

const model = genAI.getGenerativeModel({ model: 'models/gemini-1.5-pro' });

const imageResp = await fetch(
    'https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Palace_of_Westminster_from_the_dome_on_Methodist_Central_Hall.jpg/2560px-Palace_of_Westminster_from_the_dome_on_Methodist_Central_Hall.jpg'
)
    .then((response) => response.arrayBuffer());

const result = await model.generateContent([
    {
        inlineData: {
            data: Buffer.from(imageResp).toString("base64"),
            mimeType: "image/jpeg",
        },
    },
    'Caption this image.',
]);
console.log(result.response.text());
Nhiều hình ảnh
Để nhắc bằng nhiều hình ảnh ở định dạng mã hoá Base64, bạn có thể làm như sau:


import { GoogleGenerativeAI } from "@google/generative-ai";

// Access your API key as an environment variable (see "Set up your API key" above)
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

const model = genAI.getGenerativeModel({ model: 'models/gemini-1.5-pro' });

const imageResp1 = await fetch(IMAGE_PATH_1).then((response) => response.arrayBuffer());
const imageResp2 = await fetch(IMAGE_PATH_2).then((response) => response.arrayBuffer());

const result = await model.generateContent([
    {
        inlineData: {
            data: Buffer.from(imageResp1).toString("base64"),
            mimeType: "image/jpeg",
        },
    },
    {
        inlineData: {
            data: Buffer.from(imageResp2).toString("base64"),
            mimeType: "image/jpeg",
        },
    },
    'Generate a list of all the objects contained in both images.',
]);
console.log(result.response.text());

Tải hình ảnh lên và tạo nội dung
Khi tổ hợp các tệp và hướng dẫn hệ thống mà bạn định gửi có kích thước lớn hơn 20 MB, hãy sử dụng File API để tải các tệp đó lên.

Sử dụng phương thức media.upload của API Tệp để tải hình ảnh lên ở mọi kích thước.

Lưu ý: File API cho phép bạn lưu trữ tối đa 20 GB tệp cho mỗi dự án, với kích thước tối đa cho mỗi tệp là 2 GB. Các tệp được lưu trữ trong 48 giờ. Bạn có thể truy cập vào các tệp đó trong khoảng thời gian đó bằng khoá API, nhưng không thể tải xuống từ API. API này được cung cấp miễn phí ở tất cả các khu vực có Gemini API.
Sau khi tải tệp lên, bạn có thể tạo các yêu cầu GenerateContent tham chiếu đến URI API tệp. Chọn mô hình tạo sinh và cung cấp cho mô hình này một câu lệnh dạng văn bản và hình ảnh đã tải lên.


// Make sure to include these imports:
// import { GoogleAIFileManager } from "@google/generative-ai/server";
// import { GoogleGenerativeAI } from "@google/generative-ai";
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

const uploadResult = await fileManager.uploadFile(
  `${mediaPath}/jetpack.jpg`,
  {
    mimeType: "image/jpeg",
    displayName: "Jetpack drawing",
  },
);
// View the response.
console.log(
  `Uploaded file ${uploadResult.file.displayName} as: ${uploadResult.file.uri}`,
);

const genAI = new GoogleGenerativeAI(process.env.API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
const result = await model.generateContent([
  "Tell me about this image.",
  {
    fileData: {
      fileUri: uploadResult.file.uri,
      mimeType: uploadResult.file.mimeType,
    },
  },
]);
console.log(result.response.text());

Xác minh việc tải tệp hình ảnh lên và nhận siêu dữ liệu
Bạn có thể xác minh API đã lưu trữ thành công tệp đã tải lên và lấy siêu dữ liệu của tệp đó bằng cách gọi files.get. Chỉ name (và theo đó là uri) là duy nhất.


// Make sure to include these imports:
// import { GoogleAIFileManager } from "@google/generative-ai/server";
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

const uploadResponse = await fileManager.uploadFile(
  `${mediaPath}/jetpack.jpg`,
  {
    mimeType: "image/jpeg",
    displayName: "Jetpack drawing",
  },
);

// Get the previously uploaded file's metadata.
const getResponse = await fileManager.getFile(uploadResponse.file.name);

// View the response.
console.log(
  `Retrieved file ${getResponse.displayName} as ${getResponse.uri}`,
);

Gọi một hoặc nhiều tệp hình ảnh được lưu trữ cục bộ
Ngoài ra, bạn có thể tải tệp của riêng mình lên.

Khi tổ hợp các tệp và hướng dẫn hệ thống mà bạn định gửi có kích thước lớn hơn 20 MB, hãy sử dụng File API để tải các tệp đó lên, như đã trình bày trước đó. Thay vào đó, bạn có thể gọi các tệp nhỏ hơn trên máy từ Gemini API:


import { GoogleGenerativeAI } from "@google/generative-ai";
import fs from "fs";

// Access your API key as an environment variable (see "Set up your API key" above)
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

// Converts local file information to a GoogleGenerativeAI.Part object.
function fileToGenerativePart(path, mimeType) {
  return {
    inlineData: {
      data: Buffer.from(fs.readFileSync(path)).toString("base64"),
      mimeType
    },
  };
}

// Turn images to Part objects
const filePart1 = fileToGenerativePart("jetpack.jpg", "image/jpeg")
const filePart2 = fileToGenerativePart("piranha.jpg", "image/jpeg")
const filePart3 = fileToGenerativePart("firefighter.jpg", "image/jpeg")
Xin lưu ý rằng các lệnh gọi dữ liệu nội tuyến này không bao gồm nhiều tính năng có sẵn thông qua File API, chẳng hạn như nhận siêu dữ liệu tệp, liệt kê hoặc xoá tệp.

Lời nhắc có nhiều hình ảnh
Bạn có thể cung cấp cho Gemini API bất kỳ tổ hợp hình ảnh và văn bản nào phù hợp với cửa sổ ngữ cảnh của mô hình. Ví dụ này cung cấp một câu lệnh văn bản ngắn và 3 hình ảnh đã tải lên trước đó.


async function run() {
  // Choose a Gemini model.
  const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });

  const prompt = "Write an advertising jingle showing how the product in the first image could solve the problems shown in the second two images.";

  const imageParts = [
    filePart1,
    filePart2,
    filePart3,
  ];

  const generatedContent = await model.generateContent([prompt, ...imageParts]);
  
  console.log(generatedContent.response.text());
}

run();
Khả năng tương thích với OpenAI
Bạn có thể sử dụng các thư viện OpenAI để khai thác khả năng hiểu hình ảnh của Gemini. Điều này cho phép bạn tích hợp Gemini vào quy trình làm việc hiện có của OpenAI bằng cách cập nhật 3 dòng mã và sử dụng khoá API Gemini. Hãy xem Ví dụ về việc hiểu hình ảnh để biết mã minh hoạ cách gửi hình ảnh được mã hoá dưới dạng tải trọng Base64.

Tính năng
Phần này trình bày các chức năng thị giác cụ thể của mô hình Gemini, bao gồm cả tính năng phát hiện đối tượng và toạ độ hộp giới hạn.

Lấy hộp giới hạn cho một đối tượng
Các mô hình Gemini được huấn luyện để trả về toạ độ hộp giới hạn dưới dạng chiều rộng hoặc chiều cao tương đối trong khoảng [0, 1]. Sau đó, các giá trị này được điều chỉnh theo tỷ lệ 1000 và chuyển đổi thành số nguyên. Về cơ bản, toạ độ thể hiện hộp giới hạn trên phiên bản hình ảnh 1000x1000 pixel. Do đó, bạn cần chuyển đổi các toạ độ này trở lại kích thước của hình ảnh ban đầu để ánh xạ chính xác các hộp giới hạn.


// filePart = ...
// filePart2 has the piranha.

async function findBox(filePart) {
  // Choose a Gemini model.
  const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });

  const prompt = "Return a bounding box for the piranha. \n [ymin, xmin, ymax, xmax]";

  const generatedContent = await model.generateContent([prompt, filePart]);
  
  console.log(generatedContent.response.text());
}

run(filePart);
Mô hình trả về toạ độ hộp giới hạn ở định dạng [ymin, xmin, ymax, xmax]. Để chuyển đổi các toạ độ chuẩn hoá này thành toạ độ pixel của hình ảnh gốc, hãy làm theo các bước sau:

Chia mỗi toạ độ đầu ra cho 1000.
Nhân toạ độ x với chiều rộng hình ảnh gốc.
Nhân toạ độ y với chiều cao hình ảnh ban đầu.
Lời nhắc bằng video
Trong hướng dẫn này, bạn sẽ tải video lên bằng File API và tạo nội dung dựa trên các hình ảnh đó.

Lưu ý: Bạn cần có File API để tải tệp video lên do kích thước của tệp. Tuy nhiên, File API chỉ có sẵn cho Python, Node.js, Go và REST.
Thông tin chi tiết về kỹ thuật (video)
Gemini 1.5 Pro và Flash hỗ trợ tối đa khoảng một giờ dữ liệu video.

Video phải ở một trong các loại MIME định dạng video sau:

video/mp4
video/mpeg
video/mov
video/avi
video/x-flv
video/mpg
video/webm
video/wmv
video/3gpp
Dịch vụ API tệp trích xuất khung hình ảnh từ video với tốc độ 1 khung hình/giây (FPS) và âm thanh ở tốc độ 1 Kb/giây, một kênh, thêm dấu thời gian mỗi giây. Các tỷ lệ này có thể thay đổi trong tương lai để cải thiện khả năng suy luận.

Lưu ý: Thông tin chi tiết về các cảnh hành động nhanh có thể bị mất ở tốc độ lấy mẫu khung hình 1 FPS. Hãy cân nhắc việc làm chậm các đoạn video tốc độ cao để cải thiện chất lượng suy luận.
Mỗi khung hình là 258 mã thông báo và âm thanh là 32 mã thông báo mỗi giây. Với siêu dữ liệu, mỗi giây video sẽ trở thành khoảng 300 mã thông báo, tức là cửa sổ ngữ cảnh 1 triệu mã thông báo có thể chứa một video dài chưa đến một giờ.

Để đặt câu hỏi về vị trí được gắn dấu thời gian, hãy sử dụng định dạng MM:SS, trong đó hai chữ số đầu tiên thể hiện phút và hai chữ số cuối cùng thể hiện giây.

Để có kết quả tốt nhất:

Sử dụng một video cho mỗi câu lệnh.
Nếu bạn sử dụng một video, hãy đặt lời nhắc bằng văn bản sau video đó.
Tải tệp video lên bằng File API
Lưu ý: File API cho phép bạn lưu trữ tối đa 20 GB tệp cho mỗi dự án, với kích thước tối đa cho mỗi tệp là 2 GB. Các tệp được lưu trữ trong 48 giờ. Bạn có thể truy cập vào các tệp đó trong khoảng thời gian đó bằng khoá API, nhưng không thể tải xuống bằng bất kỳ API nào. Bạn có thể sử dụng tính năng này mà không mất phí ở tất cả các khu vực có API Gemini.
File API chấp nhận trực tiếp các định dạng tệp video. Ví dụ này sử dụng phim ngắn của NASA "Vết đỏ lớn trên sao Mộc co lại và phát triển". Nguồn: Trung tâm bay vũ trụ Goddard (GSFC)/David Ladd (2018).

"Vết đỏ lớn trên sao Mộc co lại và phát triển" thuộc phạm vi công cộng và không cho thấy những người có thể nhận dạng được. (Nguyên tắc sử dụng hình ảnh và nội dung nghe nhìn của NASA.)

Bắt đầu bằng cách truy xuất video ngắn:


wget https://storage.googleapis.com/generativeai-downloads/images/GreatRedSpot.mp4
Tải video lên bằng File API và in URI.


// To use the File API, use this import path for GoogleAIFileManager.
// Note that this is a different import path than what you use for generating content.
// For versions lower than @google/generative-ai@0.13.0
// use "@google/generative-ai/files"
import { GoogleAIFileManager } from "@google/generative-ai/server";

// Initialize GoogleAIFileManager with your API_KEY.
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

// Upload the file and specify a display name.
const uploadResponse = await fileManager.uploadFile("GreatRedSpot.mp4", {
  mimeType: "video/mp4",
  displayName: "Jupiter's Great Red Spot",
});

// View the response.
console.log(`Uploaded file ${uploadResponse.file.displayName} as: ${uploadResponse.file.uri}`);
Xác minh quá trình tải tệp lên và kiểm tra trạng thái
Xác minh API đã nhận được các tệp thành công bằng cách gọi phương thức files.get.

Lưu ý: Tệp video có trường State trong API Tệp. Khi được tải lên, video sẽ ở trạng thái PROCESSING cho đến khi sẵn sàng để dự đoán. Chỉ có thể sử dụng tệp ACTIVE để suy luận mô hình.

// To use the File API, use this import path for GoogleAIFileManager.
// Note that this is a different import path than what you use for generating content.
// For versions lower than @google/generative-ai@0.13.0
// use "@google/generative-ai/files"
import { GoogleAIFileManager, FileState } from "@google/generative-ai/server";

// Initialize GoogleAIFileManager with your API_KEY.
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

// Upload the video file using the File API
// uploadResponse = ...
const name = uploadResponse.file.name;

// Poll getFile() on a set interval (10 seconds here) to check file state.
let file = await fileManager.getFile(name);
while (file.state === FileState.PROCESSING) {
  process.stdout.write(".")
  // Sleep for 10 seconds
  await new Promise((resolve) => setTimeout(resolve, 10_000));
  // Fetch the file from the API again
  file = await fileManager.getFile(name)
}

if (file.state === FileState.FAILED) {
  throw new Error("Video processing failed.");
}

// When file.state is ACTIVE, the file is ready to be used for inference.
console.log(`File ${file.displayName} is ready for inference as ${file.uri}`);

Lời nhắc bằng video và văn bản
Sau khi video đã tải lên ở trạng thái ACTIVE, bạn có thể tạo các yêu cầu GenerateContent chỉ định URI API tệp cho video đó. Chọn mô hình tạo sinh và cung cấp cho mô hình đó video đã tải lên cùng một câu lệnh văn bản.


// To generate content, use this import path for GoogleGenerativeAI.
// Note that this is a different import path than what you use for the File API.
import { GoogleGenerativeAI } from "@google/generative-ai";

// Initialize GoogleGenerativeAI with your API_KEY.
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

// Choose a Gemini model.
const model = genAI.getGenerativeModel({
  model: "gemini-1.5-pro",
});

// Upload the video file using the File API
// uploadResponse = ...

// Generate content using text and the URI reference for the uploaded file.
const result = await model.generateContent([
    {
      fileData: {
        mimeType: uploadResponse.file.mimeType,
        fileUri: uploadResponse.file.uri
      }
    },
    { text: "Summarize this video. Then create a quiz with answer key based on the information in the video." },
  ]);

// Handle the response of generated text
console.log(result.response.text())

Tham khảo dấu thời gian trong nội dung
Bạn có thể sử dụng dấu thời gian ở dạng MM:SS để tham chiếu đến những khoảnh khắc cụ thể trong video.


// To generate content, use this import path for GoogleGenerativeAI.
// Note that this is a different import path than what you use for the File API.
import { GoogleGenerativeAI } from "@google/generative-ai";

// Initialize GoogleGenerativeAI with your API_KEY.
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

// Choose a Gemini model.
const model = genAI.getGenerativeModel({
  model: "gemini-1.5-pro",
});

// Upload the video file using the File API
// uploadResponse = ...

// Generate content using text and the URI reference for the uploaded file.
const result = await model.generateContent([
    {
      fileData: {
        mimeType: uploadResponse.file.mimeType,
        fileUri: uploadResponse.file.uri
      }
    },
    { text: "What are the examples given at 01:05 and 01:19 supposed to show us?" },
  ]);

// Handle the response of generated text
console.log(result.response.text())

Chép lời video và cung cấp nội dung mô tả bằng hình ảnh
Nếu video có tốc độ không nhanh (chỉ lấy mẫu 1 khung hình/giây video), bạn có thể chép lời video bằng nội dung mô tả bằng hình ảnh cho từng cảnh quay.


// To generate content, use this import path for GoogleGenerativeAI.
// Note that this is a different import path than what you use for the File API.
import { GoogleGenerativeAI } from "@google/generative-ai";

// Initialize GoogleGenerativeAI with your API_KEY.
const genAI = new GoogleGenerativeAI(process.env.API_KEY);

// Choose a Gemini model.
const model = genAI.getGenerativeModel({
  model: "gemini-1.5-pro",
});

// Upload the video file using the File API
// uploadResponse = ...

// Generate content using text and the URI reference for the uploaded file.
const result = await model.generateContent([
    {
      fileData: {
        mimeType: uploadResponse.file.mimeType,
        fileUri: uploadResponse.file.uri
      }
    },
    { text: "Transcribe the audio, giving timestamps. Also provide visual descriptions." },
  ]);

// Handle the response of generated text
console.log(result.response.text())

Liệt kê tệp
Bạn có thể liệt kê tất cả tệp được tải lên bằng API Tệp và URI của các tệp đó bằng cách sử dụng files.list.


// Make sure to include these imports:
// import { GoogleAIFileManager } from "@google/generative-ai/server";
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

const listFilesResponse = await fileManager.listFiles();

// View the response.
for (const file of listFilesResponse.files) {
  console.log(`name: ${file.name} | display name: ${file.displayName}`);
}

Xóa tệp
Các tệp được tải lên bằng File API sẽ tự động bị xoá sau 2 ngày. Bạn cũng có thể xoá các tệp đó theo cách thủ công bằng files.delete.


// Make sure to include these imports:
// import { GoogleAIFileManager } from "@google/generative-ai/server";
const fileManager = new GoogleAIFileManager(process.env.API_KEY);

const uploadResult = await fileManager.uploadFile(
  `${mediaPath}/jetpack.jpg`,
  {
    mimeType: "image/jpeg",
    displayName: "Jetpack drawing",
  },
);

// Delete the file.
await fileManager.deleteFile(uploadResult.file.name);

console.log(`Deleted ${uploadResult.file.displayName}`);
