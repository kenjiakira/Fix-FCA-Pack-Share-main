const fs = require("fs");
const path = require("path");

const DB_FOLDER = path.join(__dirname, "json", "dragonball");
const DB_FILE = path.join(DB_FOLDER, "players.json");
const DB_BALL_FILE = path.join(DB_FOLDER, "ball.json");
const PVP_INVITES = {};
const PVP_INVITE_TIMEOUT = 300000; 

const DRAGON_WISHES = {
    ZENI: {
        name: "T√∫i Zeni kh·ªïng l·ªì",
        reward: "100,000 Zeni",
        effect: (player) => {
            player.stats.zeni += 100000;
        }
    },
    POWER: {
        name: "S·ª©c m·∫°nh v√¥ h·∫°n",
        reward: "200,000,000 s·ª©c m·∫°nh",
        effect: (player) => {
            player.stats.power += 200000000;
        }
    },
    EXP: {
        name: "Kinh nghi·ªám chi·∫øn ƒë·∫•u",
        reward: "200,000 EXP",
        effect: (player) => {
            if (player.stats.exp + 200000 > MAX_EXP_STORAGE) {
                player.stats.exp = MAX_EXP_STORAGE;
            } else {
                player.stats.exp += 200000;
            }
        }
    }
};
function hasAllDragonBalls(player, planet) {
    if (!player.inventory || !player.inventory.dragonBalls) return false;

    const planetBalls = player.inventory.dragonBalls.filter(ball => ball.planet === planet);

    if (planetBalls.length === 7) {
        const stars = planetBalls.map(ball => ball.star).sort((a, b) => a - b);
        if (stars.join(",") === "1,2,3,4,5,6,7") return true;
    }

    return false;
}

function removeDragonBalls(player, planet) {
    if (!player.inventory || !player.inventory.dragonBalls) return;

    player.inventory.dragonBalls = player.inventory.dragonBalls.filter(ball => ball.planet !== planet);
}

const SHOP_ITEMS = {
    SENZU: {
        id: "senzu",
        name: "ƒê·∫≠u Th·∫ßn",
        price: 5000,
        description: "H·ªìi ph·ª•c to√†n b·ªô HP KI v√† tƒÉng 5% s·ª©c m·∫°nh",
        type: "consumable",
        emoji: "üå±"
    },
    SCOUTER: {
        id: "scouter",
        name: "Thi·∫øt B·ªã ƒêo S·ª©c M·∫°nh",
        price: 10000,
        description: "TƒÉng 10% Ki khi ƒëeo",
        type: "equipment",
        emoji: "üîã"
    },
    DRAGON_RADAR: {
        id: "radar",
        name: "Rada D√≤ Ng·ªçc R·ªìng",
        price: 75000,
        description: "TƒÉng t·ª∑ l·ªá t√¨m th·∫•y Ng·ªçc R·ªìng l√™n 3 l·∫ßn",
        type: "equipment",
        emoji: "üì°"
    },
    ARMOR: {
        id: "armor",
        name: "√Åo Gi√°p Saiyan",
        price: 15000,
        description: "TƒÉng 15% HP",
        type: "equipment",
        emoji: "üõ°Ô∏è"
    },
    POWER_CRYSTAL: {
        id: "crystal",
        name: "Tinh Th·ªÉ S·ª©c M·∫°nh",
        price: 50000,
        description: "TƒÉng vƒ©nh vi·ªÖn 1000 s·ª©c m·∫°nh",
        type: "special",
        emoji: "üíé"
    }
};
const QUEST_TYPES = {
    COMBAT: "combat",       // ƒê√°nh qu√°i v·∫≠t
    POWER: "power",         // ƒê·∫°t m·ª©c s·ª©c m·∫°nh
    TRAINING: "training",   // Luy·ªán t·∫≠p x l·∫ßn
    COLLECT: "collect",     // Thu th·∫≠p v·∫≠t ph·∫©m
    MASTER: "master"        // G·∫∑p s∆∞ ph·ª•
};
const PLANET_QUEST_PROGRESSION = {
    EARTH: [
        "BEGINNER_1",      // Luy·ªán t·∫≠p
        "BEGINNER_2",      // S·ª©c m·∫°nh c∆° b·∫£n
        "EARTH_WOLF",      // ƒê√°nh s√≥i (qu√°i y·∫øu nh·∫•t Tr√°i ƒê·∫•t)
        "MEET_MASTER_1",   // G·∫∑p s∆∞ ph·ª•
        "EARTH_SAIBAMEN",  // ƒê√°nh Saibamen (qu√°i m·∫°nh h∆°n)
        "POWER_LV1",       // ƒê·∫°t s·ª©c m·∫°nh 10k
        "DRAGON_BALL_1",   // Thu th·∫≠p 3 vi√™n ng·ªçc r·ªìng
        "POWER_LV2",       // ƒê·∫°t s·ª©c m·∫°nh 50k
        "EARTH_BOSS",      // ƒê√°nh boss Tr√°i ƒê·∫•t
        "DRAGON_BALL_ALL"  // Thu th·∫≠p ƒë·ªß 7 vi√™n ng·ªçc
    ],
    NAMEK: [
        "BEGINNER_1",      // Luy·ªán t·∫≠p
        "BEGINNER_2",      // S·ª©c m·∫°nh c∆° b·∫£n  
        "NAMEK_APPULE",    // ƒê√°nh Appule (qu√°i y·∫øu nh·∫•t Namek)
        "MEET_MASTER_1",   // G·∫∑p s∆∞ ph·ª•
        "NAMEK_SOLDIER",   // ƒê√°nh l√≠nh Freeza (qu√°i m·∫°nh h∆°n)
        "POWER_LV1",       // ƒê·∫°t s·ª©c m·∫°nh 10k
        "DRAGON_BALL_1",   // Thu th·∫≠p 3 vi√™n ng·ªçc r·ªìng
        "POWER_LV2",       // ƒê·∫°t s·ª©c m·∫°nh 50k
        "NAMEK_BOSS",      // ƒê√°nh boss Namek
        "DRAGON_BALL_ALL"  // Thu th·∫≠p ƒë·ªß 7 vi√™n ng·ªçc
    ],
    SAIYAN: [
        "BEGINNER_1",      // Luy·ªán t·∫≠p
        "BEGINNER_2",      // S·ª©c m·∫°nh c∆° b·∫£n
        "SAIYAN_RADITZ",   // ƒê√°nh Raditz (qu√°i y·∫øu nh·∫•t Saiyan)
        "MEET_MASTER_1",   // G·∫∑p s∆∞ ph·ª•
        "SAIYAN_NAPPA",    // ƒê√°nh Nappa (qu√°i m·∫°nh h∆°n)
        "POWER_LV1",       // ƒê·∫°t s·ª©c m·∫°nh 10k
        "DRAGON_BALL_1",   // Thu th·∫≠p 3 vi√™n ng·ªçc r·ªìng
        "POWER_LV2",       // ƒê·∫°t s·ª©c m·∫°nh 50k
        "SAIYAN_BOSS",     // ƒê√°nh boss Saiyan
        "DRAGON_BALL_ALL"  // Thu th·∫≠p ƒë·ªß 7 vi√™n ng·ªçc
    ]
};
const QUESTS = {

    BEGINNER_1: {
        id: "BEGINNER_1",
        name: "B·∫Øt ƒë·∫ßu h√†nh tr√¨nh",
        description: "Luy·ªán t·∫≠p 3 l·∫ßn ƒë·ªÉ l√†m quen v·ªõi s·ª©c m·∫°nh",
        type: QUEST_TYPES.TRAINING,
        target: 3,
        reward: {
            exp: 500,
            zeni: 1000,
            description: "500 EXP, 1000 Zeni"
        },
        requiredLevel: 0
    },
    BEGINNER_2: {
        id: "BEGINNER_2",
        name: "T√¨m ki·∫øm s·ª©c m·∫°nh",
        description: "ƒê·∫°t 2,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 2000,
        reward: {
            exp: 1000,
            zeni: 2000,
            description: "1000 EXP, 2000 Zeni"
        },
        requiredLevel: 0
    },

    // Nhi·ªám v·ª• ƒë√°nh qu√°i
    EARTH_WOLF: {
        id: "EARTH_WOLF",
        name: "Nh·ªØng k·∫ª sƒÉn m·ªìi",
        description: "ƒê√°nh b·∫°i 5 con s√≥i hoang",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "wolf",
        reward: {
            exp: 1000,
            zeni: 2000,
            description: "1000 EXP, 2000 Zeni"
        },
        requiredLevel: 1
    },
    EARTH_SAIBAMEN: {
        id: "EARTH_SAIBAMEN",
        name: "ƒê√°nh b·∫°i Saibamen",
        description: "ƒê√°nh b·∫°i 8 Saibamen",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "saibamen",
        reward: {
            exp: 3000,
            zeni: 4000,
            description: "3000 EXP, 4000 Zeni"
        },
        requiredLevel: 2
    },
    EARTH_BOSS: {
        id: "EARTH_BOSS",
        name: "Th·ª≠ th√°ch cu·ªëi c√πng",
        description: "ƒê√°nh b·∫°i Mercenary Tao",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "mercenary_tao",
        reward: {
            exp: 10000,
            zeni: 20000,
            item: "armor",
            quantity: 1,
            description: "10000 EXP, 20000 Zeni, 1 √Åo Gi√°p Saiyan"
        },
        requiredLevel: 15
    },

    // Nhi·ªám v·ª• ƒë√°nh qu√°i - Namek
    NAMEK_APPULE: {
        id: "NAMEK_APPULE",
        name: "S√°t th·ªß c·ªßa Freeza",
        description: "ƒê√°nh b·∫°i 5 Appule",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "appule",
        reward: {
            exp: 1500,
            zeni: 2500,
            description: "1500 EXP, 2500 Zeni"
        },
        requiredLevel: 1
    },
    NAMEK_SOLDIER: {
        id: "NAMEK_SOLDIER",
        name: "Qu√¢n ƒë·ªôi c·ªßa Freeza",
        description: "ƒê√°nh b·∫°i 8 binh l√≠nh Freeza",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "freeza_soldier",
        reward: {
            exp: 3500,
            zeni: 5000,
            description: "3500 EXP, 5000 Zeni"
        },
        requiredLevel: 2
    },
    NAMEK_BOSS: {
        id: "NAMEK_BOSS",
        name: "ƒê·ªëi ƒë·∫ßu v·ªõi Cui",
        description: "ƒê√°nh b·∫°i Cui",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "cui",
        reward: {
            exp: 12000,
            zeni: 25000,
            item: "scouter",
            quantity: 1,
            description: "12000 EXP, 25000 Zeni, 1 Thi·∫øt b·ªã ƒëo s·ª©c m·∫°nh"
        },
        requiredLevel: 15
    },

    // Nhi·ªám v·ª• ƒë√°nh qu√°i - Saiyan
    SAIYAN_RADITZ: {
        id: "SAIYAN_RADITZ",
        name: "Anh trai Kakarot",
        description: "ƒê√°nh b·∫°i 5 Raditz",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "raditz",
        reward: {
            exp: 2000,
            zeni: 3000,
            description: "2000 EXP, 3000 Zeni"
        },
        requiredLevel: 1
    },
    SAIYAN_NAPPA: {
        id: "SAIYAN_NAPPA",
        name: "T∆∞·ªõng qu√¢n Saiyan",
        description: "ƒê√°nh b·∫°i 8 Nappa",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "nappa",
        reward: {
            exp: 4000,
            zeni: 6000,
            description: "4000 EXP, 6000 Zeni"
        },
        requiredLevel: 2
    },
    SAIYAN_BOSS: {
        id: "SAIYAN_BOSS",
        name: "Th√°ch ƒë·∫•u Vegeta",
        description: "ƒê√°nh b·∫°i Ho√†ng t·ª≠ Vegeta",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "vegeta",
        reward: {
            exp: 15000,
            zeni: 30000,
            item: "crystal",
            quantity: 3,
            description: "15000 EXP, 30000 Zeni, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        requiredLevel: 15
    },

    // Nhi·ªám v·ª• g·∫∑p s∆∞ ph·ª•
    MEET_MASTER_1: {
        id: "MEET_MASTER_1",
        name: "T√¨m ki·∫øm ng∆∞·ªùi h∆∞·ªõng d·∫´n",
        description: "G·∫∑p s∆∞ ph·ª• ƒë·∫ßu ti√™n c·ªßa b·∫°n",
        type: QUEST_TYPES.MASTER,
        target: 1,
        reward: {
            exp: 2000,
            item: "senzu",
            quantity: 2,
            description: "2000 EXP, 2 ƒê·∫≠u Th·∫ßn"
        },
        requiredLevel: 1
    },

    // Nhi·ªám v·ª• thu th·∫≠p
    DRAGON_BALL_1: {
        id: "DRAGON_BALL_1",
        name: "Ng·ªçc R·ªìng huy·ªÅn tho·∫°i",
        description: "Thu th·∫≠p 3 vi√™n Ng·ªçc R·ªìng b·∫•t k·ª≥",
        type: QUEST_TYPES.COLLECT,
        itemType: "dragonBall",
        target: 3,
        reward: {
            exp: 5000,
            zeni: 10000,
            description: "5000 EXP, 10000 Zeni"
        },
        requiredLevel: 3
    },

    // Nhi·ªám v·ª• s·ª©c m·∫°nh cao c·∫•p
    POWER_LV1: {
        id: "POWER_LV1",
        name: "S·ª©c m·∫°nh th·∫≠t s·ª±",
        description: "ƒê·∫°t 10,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 10000,
        reward: {
            exp: 8000,
            zeni: 15000,
            description: "8000 EXP, 15000 Zeni"
        },
        requiredLevel: 5
    },
    POWER_LV2: {
        id: "POWER_LV2",
        name: "Si√™u Chi·∫øn Binh",
        description: "ƒê·∫°t 50,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 50000,
        reward: {
            exp: 20000,
            zeni: 30000,
            description: "20000 EXP, 30000 Zeni"
        },
        requiredLevel: 10
    },

    // Nhi·ªám v·ª• h∆∞·ªõng ƒë·∫øn R·ªìng Th·∫ßn
    DRAGON_BALL_ALL: {
        id: "DRAGON_BALL_ALL",
        name: "Tri·ªáu h·ªìi R·ªìng Th·∫ßn",
        description: "Thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ m·ªôt h√†nh tinh",
        type: QUEST_TYPES.COLLECT,
        itemType: "dragonBall7",
        target: 7,
        reward: {
            exp: 50000,
            item: "crystal",
            quantity: 3,
            description: "50000 EXP, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        requiredLevel: 20
    }
};

const EVOLUTION_SYSTEM = {
    EARTH: {
        // Tr√°i ƒê·∫•t kh√¥ng c√≥ ti·∫øn h√≥a
    },
    NAMEK: {
        forms: [
            {
                name: "Namek th∆∞·ªùng",
                powerRequired: 0,
                description: "Chi·∫øn binh Namek b√¨nh th∆∞·ªùng",
                powerBonus: 1.0,
                kiBonus: 1.0,
                healthBonus: 1.0,
                damageBonus: 1.0
            },
            {
                name: "Namek Warrior",
                powerRequired: 100000,
                description: "Chi·∫øn binh Namek ∆∞u t√∫",
                powerBonus: 1.2,
                kiBonus: 1.3,
                healthBonus: 1.2,
                damageBonus: 1.2
            },
            {
                name: "Super Namek",
                powerRequired: 1000000,
                description: "Namek si√™u c·∫•p v·ªõi s·ª©c m·∫°nh phi th∆∞·ªùng",
                powerBonus: 1.5,
                kiBonus: 1.8,
                healthBonus: 1.5,
                damageBonus: 1.5
            },
            {
                name: "Namek Fusion",
                powerRequired: 10000000,
                description: "Namek h·ª£p th·ªÉ v·ªõi s·ª©c m·∫°nh c·ªßa nhi·ªÅu Namek",
                powerBonus: 2.0,
                kiBonus: 2.5,
                healthBonus: 2.0,
                damageBonus: 2.2
            }
        ]
    },
    SAIYAN: {
        forms: [
            {
                name: "Saiyan th∆∞·ªùng",
                powerRequired: 0,
                description: "Chi·∫øn binh Saiyan b√¨nh th∆∞·ªùng",
                powerBonus: 1.0,
                kiBonus: 1.0,
                healthBonus: 1.0,
                damageBonus: 1.0
            },
            // ƒê√£ lo·∫°i b·ªè d·∫°ng Oozaru (kh·ªâ kh·ªïng l·ªì)
            {
                name: "Super Saiyan",
                powerRequired: 1000000,
                description: "Truy·ªÅn thuy·∫øt c·ªßa t·ªôc Saiyan",
                powerBonus: 1.5,
                kiBonus: 1.4,
                healthBonus: 1.3,
                damageBonus: 1.7
            },
            {
                name: "Super Saiyan 2",
                powerRequired: 10000000,
                description: "Si√™u Saiyan c·∫•p 2 v·ªõi s·ª©c m·∫°nh kinh ho√†ng",
                powerBonus: 2.0,
                kiBonus: 1.8,
                healthBonus: 1.6,
                damageBonus: 2.2
            },
            {
                name: "Super Saiyan 3",
                powerRequired: 50000000,
                description: "Si√™u Saiyan c·∫•p 3 v·ªõi s·ª©c m·∫°nh h·ªßy di·ªát",
                powerBonus: 3.0,
                kiBonus: 2.5,
                healthBonus: 2.0,
                damageBonus: 3.0
            },
            {
                name: "Super Saiyan God",
                powerRequired: 100000000,
                description: "S·ª©c m·∫°nh th·∫ßn th√°nh c·ªßa c√°c v·ªã th·∫ßn",
                powerBonus: 5.0,
                kiBonus: 4.0,
                healthBonus: 3.0,
                damageBonus: 5.0
            },
            {
                name: "Ultra Instinct",
                powerRequired: 1000000000,
                description: "B·∫£n nƒÉng v√¥ c·ª±c - s·ª©c m·∫°nh c·ªßa c√°c thi√™n s·ª©",
                powerBonus: 10.0,
                kiBonus: 8.0,
                healthBonus: 6.0,
                damageBonus: 10.0
            }
        ]
    }
};


const MONSTERS = {
    saibamen: {
        name: "Saibamen",
        hp: 500,
        power: 300,
        exp: 100,
        zeni: 50,
        dropChance: 0.05,
        dropItem: "senzu",
        planet: "EARTH"
    },
    freeza_soldier: {
        name: "Binh l√≠nh Freeza",
        hp: 1000,
        power: 800,
        exp: 250,
        zeni: 120,
        dropChance: 0.08,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    wolf: {
        name: "S√≥i hoang",
        hp: 300,
        power: 200,
        exp: 80,
        zeni: 40,
        dropChance: 0.03,
        dropItem: null,
        planet: "EARTH"
    },
    nappa: {
        name: "Nappa",
        hp: 3000,
        power: 3000,
        exp: 1000,
        zeni: 500,
        dropChance: 0.15,
        dropItem: "crystal",
        planet: "SAIYAN"
    },
    raditz: {
        name: "Raditz",
        hp: 2000,
        power: 1800,
        exp: 800,
        zeni: 400,
        dropChance: 0.10,
        dropItem: "senzu",
        planet: "SAIYAN"
    },
    appule: {
        name: "Appule",
        hp: 1500,
        power: 1000,
        exp: 300,
        zeni: 200,
        dropChance: 0.07,
        dropItem: "senzu",
        planet: "NAMEK"
    }
};


const PLANETS = {
    EARTH: {
        name: "Tr√°i ƒê·∫•t",
        powerBonus: 1.0,
        description: "H√†nh tinh c·ªßa c√°c chi·∫øn binh Z",
        masters: ["KAME"]
    },
    NAMEK: {
        name: "Namek",
        powerBonus: 1.2,
        description: "H√†nh tinh c·ªßa t·ªôc Namek",
        masters: ["PICCOLO"]
    },
    SAIYAN: {
        name: "H√†nh tinh Vegeta",
        powerBonus: 1.5,
        description: "H√†nh tinh c·ªßa t·ªôc Saiyan",
        masters: ["GOKU"]
    }
};
const DRAGON_BALL_INFO = {
    FIND_CHANCE: 0.05,
    RADAR_BOOST: 3.0,
    DESCRIPTIONS: {
        1: "Ng·ªçc R·ªìng 1 sao",
        2: "Ng·ªçc R·ªìng 2 sao",
        3: "Ng·ªçc R·ªìng 3 sao",
        4: "Ng·ªçc R·ªìng 4 sao",
        5: "Ng·ªçc R·ªìng 5 sao",
        6: "Ng·ªçc R·ªìng 6 sao",
        7: "Ng·ªçc R·ªìng 7 sao"
    }
};
const DRAGON_BALLS = {
    EARTH: { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null },
    NAMEK: { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null },
    SAIYAN: { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null }
};

const MASTERS = {
    KAME: {
        name: "L√£o r√πa Kame",
        race: "Human",
        description: "B·∫≠c th·∫ßy v√µ thu·∫≠t Tr√°i ƒê·∫•t",
        skills: {
            DRAGON_PUNCH: {
                name: "ƒê·∫•m Dragon",
                powerScale: 1.2,
                kiCost: 0.2,
                powerRequired: 0,
                description: "ƒê·∫•m Dragon c∆° b·∫£n c·ªßa ng∆∞·ªùi Tr√°i ƒê·∫•t"
            },
            KAMEJOKO: {
                name: "Kamejoko",
                powerScale: 1.5,
                kiCost: 0.3,
                powerRequired: 10000,
                description: "Kamehameha phi√™n b·∫£n l·ªói c·ªßa Goku"
            },
            SOLAR_FLARE: {
                name: "Th√°i D∆∞∆°ng H·∫° San",
                powerScale: 0,
                kiCost: 0.4,
                powerRequired: 50000,
                description: "Cho√°ng ƒë·ªëi th·ªß 10s"
            },
            KAIOKEN: {
                name: "Kaioken",
                powerScale: 0,
                kiCost: 0.5,
                powerRequired: 100000,
                description: "TƒÉng x30 HP, KI, S·ª©c ƒë√°nh"
            },
            SPIRIT_BOMB: {
                name: "Qu·∫£ C·∫ßu Kinh Kh√≠",
                powerScale: 8.0,
                kiCost: 1.0,
                powerRequired: 2000000,
                description: "T·∫°o qu·∫£ c·∫ßu c·ª±c m·∫°nh t·ªën 100% ki"
            },
            HYPNOSIS: {
                name: "Th√¥i Mi√™n",
                powerScale: 0,
                kiCost: 0.6,
                powerRequired: 5000000,
                description: "Cho√°ng ƒë·ªëi th·ªß 30s"
            },
            ENERGY_SHIELD: {
                name: "Khi√™n NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: 0.7,
                powerRequired: 50000000,
                description: "Ch·ªãu m·ªçi s√°t th∆∞∆°ng trong 40s"
            }
        }
    },

    PICCOLO: {
        name: "Piccolo",
        race: "Namek",
        description: "Chi·∫øn binh t·ªôc Namek",
        skills: {
            SPECIAL_BEAM_CANNON: {
                name: "Makankosappo",
                powerScale: 2.5,
                kiCost: 0.4,
                powerRequired: 100000,
                description: "Xo√°y ma khoan xuy√™n th·ªßng"
            },
            LIGHT_GRENADE: {
                name: "Light Grenade",
                powerScale: 3.0,
                kiCost: 0.5,
                powerRequired: 500000,
                description: "Qu·∫£ c·∫ßu √°nh s√°ng h·ªßy di·ªát"
            },
            HELLZONE_GRENADE: {
                name: "Hellzone Grenade",
                powerScale: 4.0,
                kiCost: 0.6,
                powerRequired: 5000000,
                description: "B·∫´y ƒë·ªãa ng·ª•c kh√¥ng l·ªëi tho√°t"
            },
            MULTIFORM: {
                name: "Ph√¢n Th√¢n",
                powerScale: 5.0,
                kiCost: 0.7,
                powerRequired: 10000000,
                description: "T·∫°o nhi·ªÅu b·∫£n sao chi·∫øn ƒë·∫•u"
            },
            REGENERATION: {
                name: "T√°i T·∫°o",
                powerScale: 0,
                kiCost: -0.3,
                powerRequired: 50000,
                description: "H·ªìi ph·ª•c 30% HP"
            },
            DEMONICAL_FLAVOR: {
                name: "H∆∞∆°ng V·ªã Qu·ª∑ D·ªØ",
                powerScale: 3.5,
                kiCost: 0.55,
                powerRequired: 7500000,
                description: "T·∫•n c√¥ng b·∫±ng nƒÉng l∆∞·ª£ng qu·ª∑ d·ªØ"
            },
            EXPLODING_STORM: {
                name: "B√£o NƒÉng L∆∞·ª£ng",
                powerScale: 4.5,
                kiCost: 0.65,
                powerRequired: 15000000,
                description: "T·∫°o ra c∆°n b√£o nƒÉng l∆∞·ª£ng"
            }
        }
    },

    GOKU: {
        name: "Kakarot",
        race: "Saiyan",
        description: "Chi·∫øn binh Saiyan huy·ªÅn tho·∫°i",
        skills: {
            ATOMIC: {
                name: "ƒê·∫•m Galick",
                powerScale: 1.2,
                kiCost: 0.2,
                powerRequired: 0,
                description: "ƒê·∫•m Galick c∆° b·∫£n c·ªßa ng∆∞·ªùi Saiyan"
            },
            REGENERATE_ENERGY: {
                name: "T√°i T·∫°o NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: -0.5,
                powerRequired: 100000,
                description: "H·ªìi ph·ª•c Ki nhanh ch√≥ng"
            },
            SELF_DESTRUCT: {
                name: "T·ª± Ph√°t N·ªï",
                powerScale: 10.0,
                kiCost: 1.0,
                powerRequired: 2000000,
                description: "Hy sinh b·∫£n th√¢n ƒë·ªÉ g√¢y s√°t th∆∞∆°ng l·ªõn"
            },
            WHISTLE: {
                name: "Hu√Ωt S√°o",
                powerScale: 0,
                kiCost: -0.3,
                powerRequired: 500000,
                description: "H·ªìi HP v√† Ki cho b·∫£n th√¢n"
            },
            BIND: {
                name: "Tr√≥i",
                powerScale: 0,
                kiCost: 0.3,
                powerRequired: 1000000,
                description: "Tr√≥i ƒë·ªëi th·ªß trong 15 gi√¢y"
            },
            CADICH_LIEN_HOAN_TRUONG: {
                name: "Cadich Li√™n Ho√†n Tr∆∞·ªüng",
                powerScale: 6.0,
                kiCost: 0.8,
                powerRequired: 10000000,
                description: "T·∫•n c√¥ng li√™n ho√†n b·∫±ng ch∆∞·ªüng"
            },
            ENERGY_SHIELD: {
                name: "Khi√™n NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: 0.5,
                powerRequired: 50000000,
                description: "T·∫°o khi√™n b·∫£o v·ªá trong 40 gi√¢y"
            }
        }
    }
};
const STAT_LIMITS = {
    POWER: 100000000000,
    DAMAGE: 50000000,
    KI: 50000000,
    HP: 50000000
};
const EXP_SYSTEM = {
    BASE_EXP: { min: 100, max: 300 },
    POWER_BONUS: {
        thresholds: [
            { percent: 1, bonus: 1.2 },
            { percent: 5, bonus: 1.5 },
            { percent: 10, bonus: 2.0 },
            { percent: 25, bonus: 2.5 },
            { percent: 50, bonus: 3.0 },
            { percent: 75, bonus: 4.0 },
            { percent: 90, bonus: 5.0 }
        ],
        MAX_POWER: 100000000000
    }
};
const MAX_EXP_STORAGE = 50000000;
const UPGRADE_COSTS = {
    damage: (currentValue) => Math.floor(currentValue * 5),
    ki: (currentValue) => Math.floor(currentValue * 4),
    health: (currentValue) => Math.floor(currentValue * 3)
};
const ZENI_INFO = {
    TRAIN_MIN: 50,
    TRAIN_MAX: 200,
    FIND_CHANCE: 0.25,
    SPECIAL_MIN: 500,
    SPECIAL_MAX: 2000
};
const DEFAULT_STATS = {
    power: 1000,
    damage: 100,
    ki: 100,
    health: 1000,
    exp: 0,
    zeni: 1000,
    inventory: {
        items: [],
        equipped: []
    },

    quests: {
        active: [],
        completed: [],
        progress: {}
    }
};
function updateQuestProgress(player, type, data = {}) {
    if (!player.quests || !player.quests.active) return;

    player.quests.active.forEach(questId => {
        const quest = QUESTS[questId];
        if (!quest || quest.type !== type) return;

        switch (type) {
            case QUEST_TYPES.TRAINING:

                if (!player.quests.progress[questId]) player.quests.progress[questId] = 0;
                player.quests.progress[questId]++;
                break;

            case QUEST_TYPES.POWER:

                if (player.stats.power >= quest.target) {
                    player.quests.progress[questId] = quest.target;
                }
                break;

            case QUEST_TYPES.COMBAT:

                if (data.monster === quest.monster) {
                    if (!player.quests.progress[questId]) player.quests.progress[questId] = 0;
                    player.quests.progress[questId]++;
                }
                break;

            case QUEST_TYPES.COLLECT:

                if (quest.itemType === "dragonBall") {

                    const dragonBalls = player.inventory?.dragonBalls || [];
                    player.quests.progress[questId] = dragonBalls.length;
                } else if (quest.itemType === "dragonBall7") {

                    const planets = ["EARTH", "NAMEK", "SAIYAN"];
                    let hasComplete = false;

                    for (const planet of planets) {
                        if (hasAllDragonBalls(player, planet)) {
                            hasComplete = true;
                            break;
                        }
                    }

                    player.quests.progress[questId] = hasComplete ? 7 : 0;
                }
                break;

            case QUEST_TYPES.MASTER:
                player.quests.progress[questId] = player.masters?.length || 0;
                break;
        }
    });
}
function checkStatLimit(value, type) {
    const limit = STAT_LIMITS[type];
    return value > limit ? limit : value;
}
// S·ª≠a h√†m calculateExpGain ƒë·ªÉ t√≠nh th√™m bonus t·ª´ s·ª©c ƒë√°nh
function calculateExpGain(power, damage) {
    // Base EXP t·ª´ s·ª©c m·∫°nh
    const baseExp = Math.floor(Math.random() *
        (EXP_SYSTEM.BASE_EXP.max - EXP_SYSTEM.BASE_EXP.min + 1)) +
        EXP_SYSTEM.BASE_EXP.min;

    // Bonus t·ª´ s·ª©c m·∫°nh
    const powerPercent = (power / EXP_SYSTEM.POWER_BONUS.MAX_POWER) * 100;
    let powerBonus = 1.0;
    
    for (const threshold of EXP_SYSTEM.POWER_BONUS.thresholds) {
        if (powerPercent >= threshold.percent) {
            powerBonus = threshold.bonus;
        } else {
            break;
        }
    }
    
    // Bonus m·ªõi t·ª´ s·ª©c ƒë√°nh: m·ªói 1000 s·ª©c ƒë√°nh tƒÉng 5% EXP
    const damageBonus = 1.0 + Math.floor(damage / 1000) * 0.05;
    
    // K·∫øt h·ª£p c·∫£ hai bonus
    return Math.floor(baseExp * powerBonus * damageBonus);
}
function checkAndUpdateEvolution(player) {
    if (player.planet === "EARTH" || !EVOLUTION_SYSTEM[player.planet]) {
        return false;
    }

    const evolutionForms = EVOLUTION_SYSTEM[player.planet].forms;
    if (!evolutionForms || evolutionForms.length === 0) return false;

    let highestForm = evolutionForms[0];
    for (let i = 1; i < evolutionForms.length; i++) {
        const form = evolutionForms[i];
        if (player.stats.power >= form.powerRequired) {
            highestForm = form;
        } else {
            break;
        }
    }

    if (!player.evolution || player.evolution.name !== highestForm.name) {
        const oldPower = player.stats.power;
        const oldDamage = player.stats.damage;
        const oldKi = player.stats.ki;
        const oldHealth = player.stats.health;

        if (player.evolution) {
            const oldForm = evolutionForms.find(form => form.name === player.evolution.name);
            if (oldForm) {
                player.stats.power = Math.floor(player.stats.power / oldForm.powerBonus);
                player.stats.damage = Math.floor(player.stats.damage / oldForm.damageBonus);
                player.stats.ki = Math.floor(player.stats.ki / oldForm.kiBonus);
                player.stats.health = Math.floor(player.stats.health / oldForm.healthBonus);
            }
        }

        player.evolution = {
            name: highestForm.name,
            level: evolutionForms.findIndex(form => form.name === highestForm.name),
            description: highestForm.description,
            achievedAt: new Date().toISOString()
        };

        player.stats.power = Math.floor(player.stats.power * highestForm.powerBonus);
        player.stats.damage = Math.floor(player.stats.damage * highestForm.damageBonus);
        player.stats.ki = Math.floor(player.stats.ki * highestForm.kiBonus);
        player.stats.health = Math.floor(player.stats.health * highestForm.healthBonus);

        return {
            name: highestForm.name,
            oldPower: oldPower,
            newPower: player.stats.power,
            oldDamage: oldDamage,
            newDamage: player.stats.damage,
            oldKi: oldKi,
            newKi: player.stats.ki,
            oldHealth: oldHealth,
            newHealth: player.stats.health
        };
    }

    return false;
}
function loadDragonBallData() {
    try {
        if (fs.existsSync(DB_BALL_FILE)) {
            return JSON.parse(fs.readFileSync(DB_BALL_FILE));
        }
    } catch (err) {
        console.error("Error loading dragon ball data:", err);
    }
    return JSON.parse(JSON.stringify(DRAGON_BALLS));
}

function saveDragonBallData(data) {
    fs.writeFileSync(DB_BALL_FILE, JSON.stringify(data, null, 2));
}
module.exports = {
    name: "dball",
    version: "1.1.2",
    usedby: 0,
    onPrefix: true,
    dev: "HNT",
    info: "Game Dragon Ball Z",
    category: "Games",
    usages: ".dball",
    cooldowns: 5,

    onLoad: function () {
        if (!fs.existsSync(DB_FOLDER)) {
            fs.mkdirSync(DB_FOLDER, { recursive: true });
        }

        if (!fs.existsSync(DB_FILE)) {
            fs.writeFileSync(DB_FILE, JSON.stringify({}, null, 2));
        }

        if (!fs.existsSync(DB_BALL_FILE)) {
            fs.writeFileSync(DB_BALL_FILE, JSON.stringify(DRAGON_BALLS, null, 2));
        }
    },


    onLaunch: async function ({ api, event, target }) {
        const { threadID, messageID, senderID } = event;
        const userData = JSON.parse(fs.readFileSync(path.join(__dirname, "../events/cache/userData.json")));

        const playerData = loadPlayerData();
        const command = target[0]?.toLowerCase();

        if (!target[0]) {
            if (playerData[senderID]) {
                return api.sendMessage(
                    "üêâ DRAGON BALL Z üêâ\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    "C√°c l·ªánh c√≥ s·∫µn:\n\n" +
                    "‚Ä¢ info - Xem th√¥ng tin nh√¢n v·∫≠t\n" +
                    "‚Ä¢ train - Luy·ªán t·∫≠p tƒÉng EXP\n" +
                    "‚Ä¢ Shop - Shop V·∫≠t Ph·∫©m\n" +
                    "‚Ä¢ give - T·∫∑ng Ng·ªçc R·ªìng cho ng∆∞·ªùi kh√°c\n" +
                    "‚Ä¢ fight - Th√°ch ƒë·∫•u ng∆∞·ªùi ch∆°i kh√°c\n" +
                    "‚Ä¢ quest - Xem nhi·ªám v·ª•\n" +
                    "‚Ä¢ rank - Xem b·∫£ng x·∫øp h·∫°ng\n\n" +
                    "C√°ch d√πng: .dball <l·ªánh>",
                    threadID, messageID
                );
            }

            return api.sendMessage(
                "üêâ DRAGON BALL Z üêâ\n" +
                "Ch·ªçn h√†nh tinh ƒë·ªÉ b·∫Øt ƒë·∫ßu:\n\n" +
                Object.entries(PLANETS).map(([key, data]) =>
                    `${key}: ${data.name}\n` +
                    `‚Ä¢ ${data.description}`
                ).join("\n\n") + "\n\n" +
                "C√°ch d√πng: .dball <t√™n_h√†nh_tinh>\n" +
                "VD: .dball earth",
                threadID, messageID
            );
        }
        if (!playerData[senderID] && Object.keys(PLANETS).some(p => p.toLowerCase() === command)) {
            const planet = Object.keys(PLANETS).find(p => p.toLowerCase() === command);
            const userName = userData[senderID]?.name || "Ng∆∞·ªùi ch∆°i";

            playerData[senderID] = {
                name: userName,
                planet: planet,
                stats: { ...DEFAULT_STATS },
                skills: [],
                masters: [],
                lastTrain: 0,
                created: Date.now(),
                inventory: {
                    dragonBalls: []
                }
            };

            const player = playerData[senderID];
            updateQuestProgress(player, QUEST_TYPES.MASTER);

            savePlayerData(playerData);

            return api.sendMessage(
                "üéâ NH√ÇN V·∫¨T ƒê√É ƒê∆Ø·ª¢C T·∫†O!\n" +
                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                `üë§ T√™n: ${userName}\n` +
                `üåç T·ªôc ng∆∞·ªùi: ${PLANETS[planet].name}\n` +
                `üí™ S·ª©c m·∫°nh c∆° b·∫£n: ${DEFAULT_STATS.power}\n` +
                `‚ú® Ki: ${DEFAULT_STATS.ki}\n` +
                `‚ù§Ô∏è HP: ${DEFAULT_STATS.health}\n` +
                `üí∞ Zeni: ${DEFAULT_STATS.zeni.toLocaleString()}\n\n` +
                "üí° D√πng .dball train ƒë·ªÉ b·∫Øt ƒë·∫ßu luy·ªán t·∫≠p!",
                threadID, messageID
            );
        }

        switch (command) {

            case "info": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }


                let skillList = "";
                if (player.skills.length > 0) {
                    skillList = "\n\n‚öîÔ∏è K·ª∏ NƒÇNG ƒê√É H·ªåC:\n" + player.skills.map(skill => {
                        const [master, skillName] = skill.split(":");
                        const skillData = MASTERS[master].skills[skillName];

                        const damage = skillData.powerScale > 0 ?
                            Math.floor(player.stats.damage * skillData.powerScale) : 0;

                        const kiCost = skillData.kiCost != 0 ?
                            Math.abs(Math.floor(player.stats.ki * skillData.kiCost)) : 0;

                        if (skillData.powerScale > 0) {
                            return `- ${skillData.name} (‚öîÔ∏è ${damage.toLocaleString()} DMG, ${skillData.kiCost > 0 ? "‚ú® -" + kiCost + " Ki" : ""})`;
                        } else if (skillData.kiCost < 0) {
                            return `- ${skillData.name} (${skillData.description}, ‚ú® +${kiCost} Ki)`;
                        } else {
                            return `- ${skillData.name} (${skillData.description}, ‚ú® -${kiCost} Ki)`;
                        }
                    }).join("\n");
                }

                let masterList = "";
                if (player.masters.length > 0) {
                    masterList = "\n\nüë®‚Äçüè´ S∆∞ ph·ª• ƒë√£ g·∫∑p:\n" + player.masters.map(master =>
                        `- ${MASTERS[master].name}`
                    ).join("\n");
                }

                let inventoryList = "";
                if (player.inventory?.items?.length > 0) {
                    inventoryList = "\n\nüì¶ KHO ƒê·ªí:\n";

                    const equipped = player.inventory.items.filter(item => item.equipped);
                    if (equipped.length > 0) {
                        inventoryList += "üéΩ ƒêang s·ª≠ d·ª•ng:\n";
                        equipped.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryList += `${itemData.emoji} ${itemData.name}\n`;
                            }
                        });
                    }

                    const nonEquipped = player.inventory.items.filter(item => !item.equipped);
                    if (nonEquipped.length > 0) {
                        inventoryList += "\nüíº T√∫i ƒë·ªì:\n";
                        nonEquipped.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryList += `${itemData.emoji} ${itemData.name} x${item.quantity}\n`;
                            }
                        });
                    }
                }

                // Hi·ªÉn th·ªã Ng·ªçc R·ªìng
                if (player.inventory?.dragonBalls?.length > 0) {
                    inventoryList += "\nüîÆ NG·ªåC R·ªíNG:\n";
                    const dragonBallsByPlanet = {};

                    player.inventory.dragonBalls.forEach(ball => {
                        if (!dragonBallsByPlanet[ball.planet]) {
                            dragonBallsByPlanet[ball.planet] = [];
                        }
                        dragonBallsByPlanet[ball.planet].push(ball.star);
                    });

                    Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                        stars.sort((a, b) => a - b);
                        inventoryList += `${PLANETS[planet].name}: ${stars.map(s => `${s}‚≠ê`).join(", ")}\n`;
                    });

                    // Th√™m th√¥ng b√°o v·ªÅ vi·ªác c√≥ ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng
                    Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                        if (stars.length === 7) {
                            inventoryList += `\nüêâ B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng ${PLANETS[planet].name}!\n`;
                            inventoryList += "üí° D√πng .dball wish ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc\n";
                        }
                    });
                }
                let evolutionInfo = "";
                if (player.evolution) {
                    evolutionInfo = "\n\nüåü TI·∫æN H√ìA:\n" +
                        `${player.evolution.name}\n` +
                        `üìù ${player.evolution.description}\n`;

                    if (player.evolution.level > 0) {
                        const evolutionForm = EVOLUTION_SYSTEM[player.planet].forms[player.evolution.level];
                        evolutionInfo += `üí™ x${evolutionForm.powerBonus} S·ª©c m·∫°nh\n`;
                        evolutionInfo += `‚öîÔ∏è x${evolutionForm.damageBonus} S·ª©c ƒë√°nh\n`;
                        evolutionInfo += `‚ú® x${evolutionForm.kiBonus} Ki\n`;
                        evolutionInfo += `‚ù§Ô∏è x${evolutionForm.healthBonus} HP\n`;
                    }
                }
                return api.sendMessage(
                    "üìä TH√îNG TIN NH√ÇN V·∫¨T üìä\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `üë§ T√™n: ${player.name}\n` +
                    `üåç T·ªôc Ng∆∞·ªùi: ${PLANETS[player.planet].name}\n` +
                    `üí™ S·ª©c m·∫°nh: ${player.stats.power.toLocaleString()}\n` +
                    `‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage.toLocaleString()}\n` +
                    `‚ú® Ki: ${player.stats.ki.toLocaleString()}\n` +
                    `‚ù§Ô∏è HP: ${player.stats.health.toLocaleString()}\n` +
                    `üí∞ Zeni: ${(player.stats.zeni || 0).toLocaleString()}\n` +
                    `üìä EXP: ${player.stats.exp.toLocaleString()}` +
                    evolutionInfo +
                    skillList + masterList + inventoryList,
                    threadID, messageID
                );
            }
            case "use": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (!target[1]) {
                    return api.sendMessage(
                        "‚ùå Vui l√≤ng nh·∫≠p ID v·∫≠t ph·∫©m!\n" +
                        "C√°ch d√πng: .dball use <id_v·∫≠t_ph·∫©m>\n" +
                        "üí° Xem ID v·∫≠t ph·∫©m trong shop ho·∫∑c inventory",
                        threadID, messageID
                    );
                }

                const itemId = target[1].toLowerCase();
                const shopItem = Object.values(SHOP_ITEMS).find(item => item.id === itemId);

                if (!shopItem) {
                    return api.sendMessage("‚ùå V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                }

                if (!player.inventory?.items?.some(item => item.id === itemId)) {
                    return api.sendMessage(
                        `‚ùå B·∫°n kh√¥ng c√≥ ${shopItem.name} trong kho ƒë·ªì!`,
                        threadID, messageID
                    );
                }

                const inventoryItem = player.inventory.items.find(item => item.id === itemId);

                switch (shopItem.type) {
                    case "consumable": {
                        inventoryItem.quantity--;

                        switch (itemId) {
                            case "senzu": {
                                const oldPower = player.stats.power;
                                const oldKi = player.stats.ki;
                                
                                player.stats.health = Math.max(player.stats.health, 1000);
                                
                                player.stats.ki = player.stats.ki; 
                                player.stats.ki = Math.max(player.stats.ki, 1000); 
                                
                                player.stats.power = Math.floor(player.stats.power * 1.05);
                            
                                if (inventoryItem.quantity <= 0) {
                                    player.inventory.items = player.inventory.items.filter(item => item.id !== itemId);
                                }
                            
                                return api.sendMessage(
                                    "‚ú® S·ª¨ D·ª§NG ƒê·∫¨U TH·∫¶N TH√ÄNH C√îNG!\n" +
                                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                    "‚ù§Ô∏è HP ƒë√£ ƒë∆∞·ª£c h·ªìi ph·ª•c ho√†n to√†n!\n" +
                                    "‚ú® Ki ƒë√£ ƒë∆∞·ª£c h·ªìi ph·ª•c ho√†n to√†n!\n" +
                                    `üí™ S·ª©c m·∫°nh: ${oldPower} ‚Üí ${player.stats.power}\n` +
                                    `üì¶ C√≤n l·∫°i: ${inventoryItem.quantity} ƒê·∫≠u Th·∫ßn`,
                                    threadID, messageID
                                );
                            }
                            case "crystal": {
                                const oldPower = player.stats.power;
                                player.stats.power += 1000;

                                if (inventoryItem.quantity <= 0) {
                                    player.inventory.items = player.inventory.items.filter(item => item.id !== itemId);
                                }

                                return api.sendMessage(
                                    "üíé S·ª¨ D·ª§NG TINH TH·ªÇ TH√ÄNH C√îNG!\n" +
                                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                    `üí™ S·ª©c m·∫°nh: ${oldPower} ‚Üí ${player.stats.power}\n` +
                                    `üì¶ C√≤n l·∫°i: ${inventoryItem.quantity} Tinh Th·ªÉ`,
                                    threadID, messageID
                                );
                            }
                        }
                        break;
                    }
                    case "radar": {
                        return api.sendMessage(
                            "üì° TRANG B·ªä TH√ÄNH C√îNG!\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                            "üîç T·ª∑ l·ªá t√¨m th·∫•y Ng·ªçc R·ªìng tƒÉng x3",
                            threadID, messageID
                        );
                    }
                    case "equipment": {
                        if (inventoryItem.equipped) {
                            return api.sendMessage(
                                `‚ùå B·∫°n ƒë√£ trang b·ªã ${shopItem.name} r·ªìi!`,
                                threadID, messageID
                            );
                        }

                        inventoryItem.equipped = true;

                        switch (itemId) {
                            case "scouter": {
                                const oldKi = player.stats.ki;
                                player.stats.ki = Math.floor(player.stats.ki * 1.1);

                                return api.sendMessage(
                                    "üîã TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                    `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                    `‚ú® Ki: ${oldKi} ‚Üí ${player.stats.ki}`,
                                    threadID, messageID
                                );
                            }
                            case "armor": {
                                const oldHealth = player.stats.health;
                                player.stats.health = Math.floor(player.stats.health * 1.15);

                                return api.sendMessage(
                                    "üõ°Ô∏è TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                    `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                    `‚ù§Ô∏è HP: ${oldHealth} ‚Üí ${player.stats.health}`,
                                    threadID, messageID
                                );
                            }
                        }
                        break;
                    }
                }

                savePlayerData(playerData);
            }
            case "shop": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                const shopItemsArray = Object.values(SHOP_ITEMS);

                if (!target[1]) {
                    let msg = "üè™ SHOP V·∫¨T PH·∫®M üè™\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";

                    shopItemsArray.forEach((item, index) => {
                        msg += `${index + 1}. ${item.emoji} ${item.name}\n`;
                        msg += `üí∞ Gi√°: ${item.price.toLocaleString()} Zeni\n`;
                        msg += `üìù ${item.description}\n`;
                        msg += `üì¶ Lo·∫°i: ${item.type === "consumable" ? "Ti√™u hao" : item.type === "equipment" ? "Trang b·ªã" : "ƒê·∫∑c bi·ªát"}\n\n`;
                    });

                    msg += "C√°ch d√πng:\n";
                    msg += "‚Ä¢ .dball shop <s·ªë th·ª© t·ª±> <s·ªë l∆∞·ª£ng>\n";
                    msg += "‚Ä¢ VD: .dball shop 1 1 (Mua v·∫≠t ph·∫©m s·ªë 1, s·ªë l∆∞·ª£ng 1)\n\n";
                    msg += `üí∞ Zeni hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}`;

                    return api.sendMessage(msg, threadID, messageID);
                }

                const itemIndex = parseInt(target[1]) - 1;
                const quantity = parseInt(target[2]) || 1;

                if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= shopItemsArray.length) {
                    return api.sendMessage("‚ùå S·ªë th·ª© t·ª± v·∫≠t ph·∫©m kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                }

                const item = shopItemsArray[itemIndex];
                const totalCost = item.price * quantity;

                if (player.stats.zeni < totalCost) {
                    return api.sendMessage(
                        `‚ùå Kh√¥ng ƒë·ªß Zeni ƒë·ªÉ mua!\n` +
                        `üí∞ Zeni hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                        `üí∞ C·∫ßn: ${totalCost.toLocaleString()}`,
                        threadID, messageID
                    );
                }

                if (!player.inventory) player.inventory = { items: [] };
                if (!player.inventory.items) player.inventory.items = [];

                const existingItem = player.inventory.items.find(i => i.id === item.id);

                if (existingItem) {
                    existingItem.quantity += quantity;
                } else {
                    player.inventory.items.push({
                        id: item.id,
                        quantity: quantity,
                        type: item.type
                    });
                }

                player.stats.zeni -= totalCost;
                savePlayerData(playerData);

                return api.sendMessage(
                    "üõçÔ∏è MUA TH√ÄNH C√îNG!\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `${item.emoji} ƒê√£ mua: ${item.name} x${quantity}\n` +
                    `üí∞ T·ªïng gi√°: ${totalCost.toLocaleString()} Zeni\n` +
                    `üí∞ S·ªë Zeni c√≤n l·∫°i: ${player.stats.zeni.toLocaleString()}\n\n` +
                    `üí° D√πng .dball use ${item.id} ƒë·ªÉ s·ª≠ d·ª•ng/trang b·ªã`,
                    threadID, messageID
                );
            }
            case "train": {
                
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }
                const powerGain = Math.floor(Math.random() * 50) + 50;

                player.stats.power = checkStatLimit(
                    player.stats.power + powerGain,
                    'POWER'
                );

                const now = Date.now();
                const cooldown = 60000;
                if (now - player.lastTrain < cooldown) {
                    const timeLeft = Math.ceil((cooldown - (now - player.lastTrain)) / 1000);
                    return api.sendMessage(
                        `‚è≥ Vui l√≤ng ƒë·ª£i ${timeLeft}s ƒë·ªÉ h·ªìi ph·ª•c s·ª©c!`,
                        threadID, messageID
                    );
                }

                // √Åp d·ª•ng c√°c hi·ªáu ·ª©ng t·ª´ trang b·ªã
                let expBonus = 1.0;
                let hasRadar = false;

                if (player.inventory?.items) {
                    const equippedItems = player.inventory.items.filter(item => item.equipped);
                    equippedItems.forEach(item => {
                        if (item.id === "gravity") {
                            expBonus *= 1.2; // TƒÉng 20% EXP
                        }
                        if (item.id === "radar") {
                            hasRadar = true;
                        }
                    });
                }

                const expGain = Math.floor(calculateExpGain(player.stats.power, player.stats.damage) * expBonus);
                const powerPercent = (player.stats.damage / EXP_SYSTEM.POWER_BONUS.MAX_POWER) * 100;

                if (player.stats.exp + expGain > MAX_EXP_STORAGE) {
                    player.stats.exp = MAX_EXP_STORAGE;
                } else {
                    player.stats.exp += expGain;
                }

                const normalZeni = Math.floor(Math.random() * (ZENI_INFO.TRAIN_MAX - ZENI_INFO.TRAIN_MIN + 1)) + ZENI_INFO.TRAIN_MIN;
                if (!player.stats.zeni) player.stats.zeni = 0;
                player.stats.zeni += normalZeni;

                let zeniMessage = `\nüí∞ Zeni +${normalZeni}`;
                if (Math.random() < ZENI_INFO.FIND_CHANCE) {
                    const specialZeni = Math.floor(Math.random() * (ZENI_INFO.SPECIAL_MAX - ZENI_INFO.SPECIAL_MIN + 1)) + ZENI_INFO.SPECIAL_MIN;
                    player.stats.zeni += specialZeni;
                    zeniMessage += `\nüåü B·∫†N T√åM TH·∫§Y T√öI ZENI ƒê·∫∂C BI·ªÜT! +${specialZeni} ZENI`;
                }

                player.lastTrain = now;

                const meetMaster = Math.random() < 0.3;
                let masterMessage = "";
                let dragonBallMessage = "";

                // T√≠nh t·ª∑ l·ªá t√¨m th·∫•y Ng·ªçc R·ªìng (c√≥/kh√¥ng c√≥ radar)
                let dragonBallChance = DRAGON_BALL_INFO.FIND_CHANCE;
                if (hasRadar) {
                    dragonBallChance *= DRAGON_BALL_INFO.RADAR_BOOST;
                    dragonBallMessage += "\nüì° Rada D√≤ Ng·ªçc R·ªìng ƒëang ho·∫°t ƒë·ªông!";
                }

                if (Math.random() < dragonBallChance) {
                    const dragonBallData = loadDragonBallData();

                    const availableBalls = Object.entries(dragonBallData[player.planet])
                        .filter(([star, owner]) => owner === null)
                        .map(([star]) => parseInt(star));

                    if (availableBalls.length > 0) {
                        const randomStar = availableBalls[Math.floor(Math.random() * availableBalls.length)];

                        dragonBallData[player.planet][randomStar] = senderID;
                        saveDragonBallData(dragonBallData);

                        if (!player.inventory) player.inventory = { dragonBalls: [] };
                        if (!player.inventory.dragonBalls) player.inventory.dragonBalls = [];

                        player.inventory.dragonBalls.push({
                            planet: player.planet,
                            star: randomStar
                        });

                        dragonBallMessage += `\n\nüåü B·∫†N ƒê√É T√åM TH·∫§Y NG·ªåC R·ªíNG ${randomStar} SAO!`;

                        if (hasAllDragonBalls(player, player.planet)) {
                            dragonBallMessage += "\n\nüêâ B·∫†N ƒê√É THU TH·∫¨P ƒê·ª¶ 7 VI√äN NG·ªåC R·ªíNG!\n";
                            dragonBallMessage += "üí° D√πng .dball wish ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc!";
                        }
                    }
                }
                const damageBonus = 1.0 + Math.floor(player.stats.damage / 1000) * 0.05;
                const evolution = checkAndUpdateEvolution(player);
                let evolutionMessage = "";
                if (evolution) {
                    evolutionMessage = "\n\nüåü TI·∫æN H√ìA M·ªöI! üåü\n" +
                        `B·∫°n ƒë√£ ti·∫øn h√≥a th√†nh: ${evolution.name}\n` +
                        `üí™ S·ª©c m·∫°nh: ${evolution.oldPower.toLocaleString()} ‚Üí ${evolution.newPower.toLocaleString()}\n` +
                        `‚öîÔ∏è S·ª©c ƒë√°nh: ${evolution.oldDamage.toLocaleString()} ‚Üí ${evolution.newDamage.toLocaleString()}\n` +
                        `‚ú® Ki: ${evolution.oldKi.toLocaleString()} ‚Üí ${evolution.newKi.toLocaleString()}\n` +
                        `‚ù§Ô∏è HP: ${evolution.oldHealth.toLocaleString()} ‚Üí ${evolution.newHealth.toLocaleString()}`;
                }

                updateQuestProgress(player, QUEST_TYPES.TRAINING);
                updateQuestProgress(player, QUEST_TYPES.POWER);
                savePlayerData(playerData);

                return api.sendMessage(
                    "‚öîÔ∏è K·∫æT QU·∫¢ LUY·ªÜN T·∫¨P ‚öîÔ∏è\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `üìä EXP +${expGain}` + 
                    (expBonus > 1 ? ` (x${expBonus.toFixed(1)} t·ª´ trang b·ªã)` : "") +
                    (damageBonus > 1 ? ` (x${damageBonus.toFixed(2)} t·ª´ s·ª©c ƒë√°nh)` : "") +
                    zeniMessage + "\n" +
                    `\nüí° Ch·ªâ s·ªë hi·ªán t·∫°i:\n` +
                    `üí™ S·ª©c m·∫°nh: ${player.stats.power}\n` +
                    `‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage}\n` +
                    `‚ú® Ki: ${player.stats.ki}\n` +
                    `‚ù§Ô∏è HP: ${player.stats.health}\n` +
                    `üí∞ Zeni: ${player.stats.zeni.toLocaleString()}\n` +
                    `üìä EXP: ${player.stats.exp.toLocaleString()}\n\n` +
                    `üí° D√πng .dball upgrade ƒë·ªÉ n√¢ng c·∫•p ch·ªâ s·ªë\n` +
                    `üí° D√πng .dball learn ƒë·ªÉ h·ªçc kƒ© nƒÉng` +
                    masterMessage +
                    dragonBallMessage +
                    evolutionMessage,
                    threadID, messageID
                );
            }
            case "wish": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                const planets = ["EARTH", "NAMEK", "SAIYAN"];
                let wishPlanet = null;

                for (const planet of planets) {
                    if (hasAllDragonBalls(player, planet)) {
                        wishPlanet = planet;
                        break;
                    }
                }

                if (!wishPlanet) {
                    return api.sendMessage(
                        "‚ùå B·∫°n ch∆∞a thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ b·∫•t k·ª≥ h√†nh tinh n√†o!\n" +
                        "Ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ t√¨m th·∫•y c√°c Ng·ªçc R·ªìng c√≤n thi·∫øu.",
                        threadID, messageID
                    );
                }

                if (!target[1]) {
                    return api.sendMessage(
                        "üêâ TH·ª∞C HI·ªÜN ƒêI·ªÄU ∆Ø·ªöC üêâ\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        "B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ " + PLANETS[wishPlanet].name + "!\n\n" +
                        "Ch·ªçn ƒëi·ªÅu ∆∞·ªõc c·ªßa b·∫°n:\n\n" +
                        "1. üí∞ " + DRAGON_WISHES.ZENI.name + " - " + DRAGON_WISHES.ZENI.reward + "\n" +
                        "2. üí™ " + DRAGON_WISHES.POWER.name + " - " + DRAGON_WISHES.POWER.reward + "\n" +
                        "3. üìä " + DRAGON_WISHES.EXP.name + " - " + DRAGON_WISHES.EXP.reward + "\n\n" +
                        "C√°ch d√πng: .dball wish <1-3>",
                        threadID, messageID
                    );
                }

                const choice = parseInt(target[1]);
                if (isNaN(choice) || choice < 1 || choice > 3) {
                    return api.sendMessage(
                        "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn t·ª´ 1 ƒë·∫øn 3.",
                        threadID, messageID
                    );
                }

                let wish, wishName, wishMessage;
                switch (choice) {
                    case 1:
                        wish = DRAGON_WISHES.ZENI;
                        wishName = "ZENI";
                        break;
                    case 2:
                        wish = DRAGON_WISHES.POWER;
                        wishName = "POWER";
                        break;
                    case 3:
                        wish = DRAGON_WISHES.EXP;
                        wishName = "EXP";
                        break;
                }

                wish.effect(player);

                const dragonBallData = loadDragonBallData();
                for (let i = 1; i <= 7; i++) {
                    dragonBallData[wishPlanet][i] = null;
                }
                saveDragonBallData(dragonBallData);

                removeDragonBalls(player, wishPlanet);

                savePlayerData(playerData);

                return api.sendMessage(
                    "üåü ƒêI·ªÄU ∆Ø·ªöC ƒê√É ƒê∆Ø·ª¢C TH·ª∞C HI·ªÜN! üåü\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `R·ªìng th·∫ßn ${wishPlanet === "EARTH" ? "Shenron" : wishPlanet === "NAMEK" ? "Porunga" : "Super Shenron"} ƒë√£ ban cho b·∫°n:\n` +
                    `${wish.name} - ${wish.reward}\n\n` +
                    "üí° C√°c Ng·ªçc R·ªìng ƒë√£ bay ƒëi kh·∫Øp h√†nh tinh sau khi th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc!\n\n" +
                    "Ch·ªâ s·ªë hi·ªán t·∫°i:\n" +
                    `üí™ S·ª©c m·∫°nh: ${player.stats.power.toLocaleString()}\n` +
                    `‚ú® Ki: ${player.stats.ki}\n` +
                    `‚ù§Ô∏è HP: ${player.stats.health}\n` +
                    `üí∞ Zeni: ${player.stats.zeni.toLocaleString()}\n` +
                    `üìä EXP: ${player.stats.exp.toLocaleString()}/${MAX_EXP_STORAGE.toLocaleString()}`,
                    threadID, messageID
                );
            }
            case "give": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                const mention = Object.keys(event.mentions)[0];
                if (!mention) {
                    return api.sendMessage("‚ùå Vui l√≤ng tag ng∆∞·ªùi mu·ªën t·∫∑ng Ng·ªçc R·ªìng!", threadID, messageID);
                }

                const targetPlayer = playerData[mention];
                if (!targetPlayer) {
                    return api.sendMessage("‚ùå Ng∆∞·ªùi n√†y ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (!target[1] || isNaN(parseInt(target[1]))) {
                    return api.sendMessage(
                        "‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá!\n" +
                        "C√°ch d√πng: .dball give @mention <s·ªë_sao>\n" +
                        "V√≠ d·ª•: .dball give @TenNguoiChoi 3",
                        threadID, messageID
                    );
                }

                const starNumber = parseInt(target[1]);
                if (starNumber < 1 || starNumber > 7) {
                    return api.sendMessage("‚ùå S·ªë sao ph·∫£i t·ª´ 1 ƒë·∫øn 7!", threadID, messageID);
                }

                if (!player.inventory?.dragonBalls?.some(ball => ball.star === starNumber)) {
                    return api.sendMessage(
                        `‚ùå B·∫°n kh√¥ng s·ªü h·ªØu Ng·ªçc R·ªìng ${starNumber} sao ƒë·ªÉ t·∫∑ng!`,
                        threadID, messageID
                    );
                }

                const ball = player.inventory.dragonBalls.find(ball => ball.star === starNumber);

                const dragonBallData = loadDragonBallData();
                dragonBallData[ball.planet][starNumber] = mention;
                saveDragonBallData(dragonBallData);

                player.inventory.dragonBalls = player.inventory.dragonBalls.filter(b =>
                    !(b.star === starNumber && b.planet === ball.planet)
                );

                if (!targetPlayer.inventory) targetPlayer.inventory = { dragonBalls: [] };
                if (!targetPlayer.inventory.dragonBalls) targetPlayer.inventory.dragonBalls = [];

                targetPlayer.inventory.dragonBalls.push({
                    planet: ball.planet,
                    star: starNumber
                });

                savePlayerData(playerData);

                return api.sendMessage(
                    "üéÅ T·∫∂NG NG·ªåC R·ªíNG TH√ÄNH C√îNG! üéÅ\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `${player.name} ƒë√£ t·∫∑ng Ng·ªçc R·ªìng ${starNumber} sao cho ${targetPlayer.name}.\n\n` +
                    "üí° Ki·ªÉm tra kho ƒë·ªì b·∫±ng l·ªánh .dball info",
                    threadID, messageID
                );
            }
            case "upgrade": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (!target[1]) {
                    const damageCost = UPGRADE_COSTS.damage(player.stats.damage);
                    const kiCost = UPGRADE_COSTS.ki(player.stats.ki);
                    const healthCost = UPGRADE_COSTS.health(player.stats.health);

                    return api.sendMessage(
                        "‚ö° N√ÇNG C·∫§P CH·ªà S·ªê ‚ö°\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `üìä EXP hi·ªán t·∫°i: ${player.stats.exp.toLocaleString()}\n\n` +
                        "Ch·ªçn ch·ªâ s·ªë ƒë·ªÉ n√¢ng c·∫•p:\n\n" +
                        `1. ‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage} (+10) - C·∫ßn ${damageCost.toLocaleString()} EXP\n` +
                        `2. ‚ú® Ki: ${player.stats.ki} (+10) - C·∫ßn ${kiCost.toLocaleString()} EXP\n` +
                        `3. ‚ù§Ô∏è HP: ${player.stats.health} (+100) - C·∫ßn ${healthCost.toLocaleString()} EXP\n\n` +
                        "C√°ch d√πng: .dball upgrade <1/2/3> [s·ªë l∆∞·ª£ng]",
                        threadID, messageID
                    );
                }

                const choice = parseInt(target[1]);
                const amount = parseInt(target[2]) || 1;

                if (isNaN(choice) || choice < 1 || choice > 3) {
                    return api.sendMessage("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn 1 (S·ª©c ƒë√°nh), 2 (Ki) ho·∫∑c 3 (HP).", threadID, messageID);
                }

                if (isNaN(amount) || amount < 1) {
                    return api.sendMessage("‚ùå S·ªë l∆∞·ª£ng n√¢ng c·∫•p kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                }

                let statToUpgrade, costFunction, increaseAmount, statName;

                switch (choice) {
                    case 1:
                        statToUpgrade = "damage";
                        costFunction = UPGRADE_COSTS.damage;
                        increaseAmount = 10;
                        statName = "S·ª©c ƒë√°nh";

                        if (player.stats.damage + (increaseAmount * amount) > STAT_LIMITS.DAMAGE) {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                "S·ª©c ƒë√°nh ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                threadID, messageID
                            );
                        }
                        break;

                    case 2:
                        statToUpgrade = "ki";
                        costFunction = UPGRADE_COSTS.ki;
                        increaseAmount = 10;
                        statName = "Ki";

                        if (player.stats.ki + (increaseAmount * amount) > STAT_LIMITS.KI) {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                "Ki ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                threadID, messageID
                            );
                        }
                        break;

                    case 3:
                        statToUpgrade = "health";
                        costFunction = UPGRADE_COSTS.health;
                        increaseAmount = 100;
                        statName = "HP";

                        if (player.stats.health + (increaseAmount * amount) > STAT_LIMITS.HP) {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                "HP ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                threadID, messageID
                            );
                        }
                        break;

                    default:
                        return api.sendMessage("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                }

                let totalCost = 0;
                const currentValue = player.stats[statToUpgrade];

                for (let i = 0; i < amount; i++) {
                    totalCost += costFunction(currentValue + (i * increaseAmount));
                }

                if (player.stats.exp < totalCost) {
                    return api.sendMessage(
                        `‚ùå Kh√¥ng ƒë·ªß EXP ƒë·ªÉ n√¢ng c·∫•p!\n` +
                        `üìä EXP hi·ªán t·∫°i: ${player.stats.exp.toLocaleString()}\n` +
                        `üìä EXP c·∫ßn: ${totalCost.toLocaleString()}\n` +
                        `üìä C√≤n thi·∫øu: ${(totalCost - player.stats.exp).toLocaleString()} EXP`,
                        threadID, messageID
                    );
                }

                player.stats.exp -= totalCost;
                player.stats[statToUpgrade] += increaseAmount * amount;

                savePlayerData(playerData);

                return api.sendMessage(
                    "üéâ N√ÇNG C·∫§P TH√ÄNH C√îNG!\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `${statName} +${increaseAmount * amount}\n` +
                    `üìä EXP -${totalCost.toLocaleString()}\n\n` +
                    "üí° Ch·ªâ s·ªë hi·ªán t·∫°i:\n" +
                    `üí™ S·ª©c m·∫°nh: ${player.stats.power.toLocaleString()}\n` +
                    `‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage.toLocaleString()}\n` +
                    `‚ú® Ki: ${player.stats.ki.toLocaleString()}\n` +
                    `‚ù§Ô∏è HP: ${player.stats.health.toLocaleString()}\n` +
                    `üìä EXP: ${player.stats.exp.toLocaleString()}/${MAX_EXP_STORAGE.toLocaleString()}`,
                    threadID, messageID
                );
            }
            case "quest": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (!player.quests) {
                    player.quests = {
                        active: [],
                        completed: [],
                        progress: {}
                    };

                    const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
                    if (planetQuests && planetQuests.length > 0) {
                        player.quests.active.push(planetQuests[0]);
                        player.quests.progress[planetQuests[0]] = 0;
                        savePlayerData(playerData);
                    }
                }

                if (target[1] === "ho√†n" || target[1] === "hoan" || target[1] === "complete") {
                    if (player.quests.active.length === 0) {
                        return api.sendMessage("‚ùå B·∫°n kh√¥ng c√≥ nhi·ªám v·ª• n√†o ƒëang l√†m!", threadID, messageID);
                    }

                    const questId = player.quests.active[0];
                    const quest = QUESTS[questId];

                    if (!quest) {
                        return api.sendMessage("‚ùå Nhi·ªám v·ª• kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }

                    const progress = player.quests.progress[questId] || 0;

                    if (progress < quest.target) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ch∆∞a ho√†n th√†nh nhi·ªám v·ª• n√†y!\n" +
                            `‚è≥ Ti·∫øn ƒë·ªô: ${progress}/${quest.target}\n\n` +
                            "üí° H√£y ti·∫øp t·ª•c th·ª±c hi·ªán nhi·ªám v·ª•!",
                            threadID, messageID
                        );
                    }

                    if (quest.reward.exp) {
                        player.stats.exp += quest.reward.exp;
                        if (player.stats.exp > MAX_EXP_STORAGE) {
                            player.stats.exp = MAX_EXP_STORAGE;
                        }
                    }

                    if (quest.reward.zeni) {
                        player.stats.zeni += quest.reward.zeni;
                    }

                    if (quest.reward.item) {
                        if (!player.inventory) player.inventory = {};
                        if (!player.inventory.items) player.inventory.items = [];

                        const existingItem = player.inventory.items.find(i => i.id === quest.reward.item);
                        if (existingItem) {
                            existingItem.quantity += (quest.reward.quantity || 1);
                        } else {
                            player.inventory.items.push({
                                id: quest.reward.item,
                                quantity: quest.reward.quantity || 1,
                                type: SHOP_ITEMS[quest.reward.item.toUpperCase()]?.type || "quest_item"
                            });
                        }
                    }

                    player.quests.active = player.quests.active.filter(id => id !== questId);
                    player.quests.completed.push(questId);

                    const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
                    const nextQuestIndex = player.quests.completed.length;

                    if (planetQuests && nextQuestIndex < planetQuests.length) {
                        const nextQuestId = planetQuests[nextQuestIndex];
                        player.quests.active.push(nextQuestId);
                        player.quests.progress[nextQuestId] = 0;
                    }

                    if (player.quests.completed.length % 3 === 0) {
                        if (!player.stats.level) player.stats.level = 1;
                        player.stats.level += 1;
                    }

                    savePlayerData(playerData);

                    let rewardMsg = "";
                    if (quest.reward.exp) rewardMsg += `üìä EXP +${quest.reward.exp}\n`;
                    if (quest.reward.zeni) rewardMsg += `üí∞ Zeni +${quest.reward.zeni}\n`;
                    if (quest.reward.item) {
                        const itemName = SHOP_ITEMS[quest.reward.item.toUpperCase()]?.name || quest.reward.item;
                        rewardMsg += `üéÅ ${itemName} x${quest.reward.quantity || 1}\n`;
                    }

                    let nextQuestMsg = "";
                    if (planetQuests && nextQuestIndex < planetQuests.length) {
                        const nextQuestId = planetQuests[nextQuestIndex];
                        const nextQuest = QUESTS[nextQuestId];
                        nextQuestMsg = "\nüÜï Nhi·ªám v·ª• m·ªõi ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a!\n";
                        nextQuestMsg += `üìù ${nextQuest.name}: ${nextQuest.description}\n`;
                    } else {
                        nextQuestMsg = "\nüèÜ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ nhi·ªám v·ª•!";
                    }

                    return api.sendMessage(
                        "üéâ HO√ÄN TH√ÄNH NHI·ªÜM V·ª§!\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `‚úÖ ${quest.name}\n\n` +
                        "üéÅ Ph·∫ßn th∆∞·ªüng:\n" +
                        rewardMsg +
                        (player.quests.completed.length % 3 === 0 ? `üÜô L√™n c·∫•p! Level ${player.stats.level}\n` : "") +
                        nextQuestMsg + "\n" +
                        "üí° D√πng .dball quest ƒë·ªÉ xem th√¥ng tin nhi·ªám v·ª•",
                        threadID, messageID
                    );
                }

                let activeQuests = [];
                let completedCount = player.quests.completed.length;
                let planetQuests = PLANET_QUEST_PROGRESSION[player.planet] || [];

                player.quests.active.forEach(questId => {
                    const quest = QUESTS[questId];
                    if (quest) {
                        let progress = player.quests.progress[questId] || 0;
                        activeQuests.push({
                            ...quest,
                            progress: progress
                        });
                    }
                });

                let msg = "üìã H·ªÜ TH·ªêNG NHI·ªÜM V·ª§ üìã\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";
                msg += `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n\n`;

                if (activeQuests.length > 0) {
                    msg += "üîµ NHI·ªÜM V·ª§ HI·ªÜN T·∫†I:\n";
                    activeQuests.forEach((quest, index) => {
                        msg += `${index + 1}. ${quest.name}\n`;
                        msg += `üìù ${quest.description}\n`;
                        msg += `‚è≥ Ti·∫øn ƒë·ªô: ${quest.progress}/${quest.target}\n`;
                        msg += `üéÅ Ph·∫ßn th∆∞·ªüng: ${quest.reward.description}\n\n`;
                    });
                } else if (completedCount >= planetQuests.length) {
                    msg += "‚úÖ CH√öC M·ª™NG! B·∫†N ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ NHI·ªÜM V·ª§!\n\n";
                } else {
                    msg += "‚ùì KH√îNG C√ì NHI·ªÜM V·ª§ N√ÄO ƒêANG HO·∫†T ƒê·ªòNG!\n\n";
                }

                if (planetQuests && completedCount < planetQuests.length && activeQuests.length === 0) {
                    const nextQuestId = planetQuests[completedCount];
                    const nextQuest = QUESTS[nextQuestId];

                    if (nextQuest) {
                        msg += "üü¢ NHI·ªÜM V·ª§ TI·∫æP THEO:\n";
                        msg += `${nextQuest.name}\n`;
                        msg += `üìù ${nextQuest.description}\n`;
                        msg += `üéÅ Ph·∫ßn th∆∞·ªüng: ${nextQuest.reward.description}\n\n`;

                        player.quests.active.push(nextQuestId);
                        player.quests.progress[nextQuestId] = 0;
                        savePlayerData(playerData);
                    }
                }

                const totalQuests = planetQuests ? planetQuests.length : 0;
                msg += `üìä Ti·∫øn ƒë·ªô: ${completedCount}/${totalQuests} nhi·ªám v·ª•\n\n`;
                msg += "üí° C√°ch d√πng: .dball quest ho√†n - Ho√†n th√†nh nhi·ªám v·ª• hi·ªán t·∫°i";

                return api.sendMessage(msg, threadID, messageID);
            }
            case "learn": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (!player.planet || !PLANETS[player.planet]) {
                    return api.sendMessage("‚ùå H√†nh tinh c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                }

                const planetMasters = PLANETS[player.planet].masters;
                if (!planetMasters || planetMasters.length === 0) {
                    return api.sendMessage(
                        "‚ùå Ch·ªâ c√≥ th·ªÉ h·ªçc k·ªπ nƒÉng khi ƒë√£ ch·ªçn s∆∞ ph·ª•!\n" +
                        "üí° M·ªói h√†nh tinh c√≥ s∆∞ ph·ª• ri√™ng:\n" +
                        "‚Ä¢ Tr√°i ƒê·∫•t - Master Roshi\n" +
                        "‚Ä¢ Namek - Piccolo\n" +
                        "‚Ä¢ Saiyan - Goku",
                        threadID, messageID
                    );
                }

                if (!target[1]) {
                    let msg = "üë®‚Äçüè´ C√ÅC S∆Ø PH·ª§ C√ì TH·ªÇ H·ªåC:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                    let skillIndex = 1;
                    let allSkills = [];

                    planetMasters.forEach(masterId => {
                        const master = MASTERS[masterId];
                        msg += `${master.name} (${master.race})\n`;
                        msg += `üìù ${master.description}\n\n`;
                        msg += "C√°c k·ªπ nƒÉng:\n";

                        Object.entries(master.skills).forEach(([skillId, skill]) => {
                            const canLearn = player.stats.power >= skill.powerRequired;
                            // T√≠nh to√°n s√°t th∆∞∆°ng d·ª± ki·∫øn d·ª±a theo powerScale
                            const estimatedDamage = skill.powerScale > 0 ? Math.floor(player.stats.damage * skill.powerScale) : 0;
                            // T√≠nh to√°n chi ph√≠ ki d·ª± ki·∫øn
                            const estimatedKi = Math.abs(Math.floor(player.stats.ki * skill.kiCost));

                            msg += `${skillIndex}. ${skill.name} (${estimatedDamage > 0 ? `${estimatedDamage} DMG` : 'H·ªó tr·ª£'}${skill.kiCost < 0 ? ', H·ªìi Ki' : `, ${estimatedKi} Ki`})\n`;
                            msg += `   ${canLearn ? "‚úÖ" : "‚ùå"} Y√™u c·∫ßu s·ª©c m·∫°nh: ${skill.powerRequired.toLocaleString()}\n`;

                            allSkills.push({
                                masterId,
                                skillId,
                                ...skill
                            });

                            skillIndex++;
                        });
                        msg += "\n";
                    });

                    msg += "üí° C√°ch h·ªçc: .dball learn <s·ªë th·ª© t·ª± k·ªπ nƒÉng>";
                    return api.sendMessage(msg, threadID, messageID);
                }

                const skillIndex = parseInt(target[1]) - 1;
                const availableMasters = PLANETS[player.planet].masters;
                let allSkills = [];

                availableMasters.forEach(masterId => {
                    Object.entries(MASTERS[masterId].skills).forEach(([skillId, skill]) => {
                        allSkills.push({ masterId, skillId, ...skill });
                    });
                });

                if (isNaN(skillIndex) || skillIndex < 0 || skillIndex >= allSkills.length) {
                    return api.sendMessage(
                        "‚ùå S·ªë th·ª© t·ª± k·ªπ nƒÉng kh√¥ng h·ª£p l·ªá!\n" +
                        "Vui l√≤ng ch·ªçn t·ª´ 1 ƒë·∫øn " + allSkills.length,
                        threadID, messageID
                    );
                }

                const chosenSkill = allSkills[skillIndex];
                const skillId = `${chosenSkill.masterId}:${chosenSkill.skillId}`;

                if (player.skills.includes(skillId)) {
                    return api.sendMessage("‚ùå B·∫°n ƒë√£ h·ªçc k·ªπ nƒÉng n√†y r·ªìi!", threadID, messageID);
                }

                if (player.stats.power < chosenSkill.powerRequired) {
                    return api.sendMessage(
                        "‚ùå S·ª©c m·∫°nh kh√¥ng ƒë·ªß ƒë·ªÉ h·ªçc k·ªπ nƒÉng n√†y!\n" +
                        `üí™ S·ª©c m·∫°nh hi·ªán t·∫°i: ${player.stats.power.toLocaleString()}\n` +
                        `‚ö° Y√™u c·∫ßu: ${chosenSkill.powerRequired.toLocaleString()}\n\n` +
                        "üí° H√£y ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ tƒÉng s·ª©c m·∫°nh!",
                        threadID, messageID
                    );
                }

                player.skills.push(skillId);
                savePlayerData(playerData);

                // T√≠nh to√°n ch·ªâ s·ªë th·ª±c t·∫ø ƒë·ªÉ hi·ªÉn th·ªã
                const estimatedDamage = chosenSkill.powerScale > 0 ?
                    Math.floor(player.stats.damage * chosenSkill.powerScale) : 0;
                const kiText = chosenSkill.kiCost < 0 ?
                    `H·ªìi ${Math.abs(Math.floor(player.stats.ki * chosenSkill.kiCost))} Ki` :
                    `T·ªën ${Math.floor(player.stats.ki * chosenSkill.kiCost)} Ki`;

                return api.sendMessage(
                    "üéâ H·ªåC K·ª∏ NƒÇNG TH√ÄNH C√îNG!\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `ƒê√£ h·ªçc ${chosenSkill.name} t·ª´ ${MASTERS[chosenSkill.masterId].name}\n` +
                    (estimatedDamage > 0 ? `üí• S√°t th∆∞∆°ng: ${estimatedDamage}\n` : "") +
                    `‚ú® Ki: ${kiText}\n` +
                    `üìù M√¥ t·∫£: ${chosenSkill.description}`,
                    threadID, messageID
                );
            }
            case "inventory":
            case "inv": {
                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                let inventoryMsg = "üì¶ KHO ƒê·ªí üì¶\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";

                // Display equipped items
                const equippedItems = player.inventory?.items?.filter(item => item.equipped) || [];
                if (equippedItems.length > 0) {
                    inventoryMsg += "üéΩ ƒêANG TRANG B·ªä:\n";
                    equippedItems.forEach(item => {
                        const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                        if (itemData) {
                            inventoryMsg += `${itemData.emoji} ${itemData.name} - ${itemData.description}\n`;
                        }
                    });
                    inventoryMsg += "\n";
                }

                // Display consumable items
                const consumables = player.inventory?.items?.filter(item => !item.equipped &&
                    Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "consumable") || [];

                if (consumables.length > 0) {
                    inventoryMsg += "üß™ V·∫¨T PH·∫®M TI√äU HAO:\n";
                    consumables.forEach(item => {
                        const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                        if (itemData) {
                            inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                        }
                    });
                    inventoryMsg += "\n";
                }

                // Display equipment not equipped
                const unusedEquipment = player.inventory?.items?.filter(item => !item.equipped &&
                    Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "equipment") || [];

                if (unusedEquipment.length > 0) {
                    inventoryMsg += "üéÆ TRANG B·ªä CH∆ØA D√ôNG:\n";
                    unusedEquipment.forEach(item => {
                        const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                        if (itemData) {
                            inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                        }
                    });
                    inventoryMsg += "\n";
                }

                // Display special items
                const specialItems = player.inventory?.items?.filter(item =>
                    Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "special") || [];

                if (specialItems.length > 0) {
                    inventoryMsg += "‚ú® V·∫¨T PH·∫®M ƒê·∫∂C BI·ªÜT:\n";
                    specialItems.forEach(item => {
                        const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                        if (itemData) {
                            inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                        }
                    });
                    inventoryMsg += "\n";
                }

                // Display Dragon Balls
                if (player.inventory?.dragonBalls?.length > 0) {
                    inventoryMsg += "üîÆ NG·ªåC R·ªíNG:\n";
                    const dragonBallsByPlanet = {};

                    player.inventory.dragonBalls.forEach(ball => {
                        if (!dragonBallsByPlanet[ball.planet]) {
                            dragonBallsByPlanet[ball.planet] = [];
                        }
                        dragonBallsByPlanet[ball.planet].push(ball.star);
                    });

                    Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                        stars.sort((a, b) => a - b);
                        inventoryMsg += `${PLANETS[planet].name}: ${stars.map(s => `${s}‚≠ê`).join(", ")}\n`;

                        // Check if player has all 7 Dragon Balls for this planet
                        if (stars.length === 7) {
                            inventoryMsg += `\nüêâ B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng ${PLANETS[planet].name}!\n`;
                            inventoryMsg += "üí° D√πng .dball wish ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc\n\n";
                        }
                    });
                }

                // If inventory is empty
                if (!player.inventory ||
                    (!player.inventory.items?.length && !player.inventory.dragonBalls?.length)) {
                    inventoryMsg += "‚ùå Kho ƒë·ªì tr·ªëng!\n\n";
                    inventoryMsg += "üí° H√£y mua v·∫≠t ph·∫©m t·ª´ shop ho·∫∑c t√¨m Ng·ªçc R·ªìng!";
                }

                inventoryMsg += "\nüí° D√πng .dball shop ƒë·ªÉ mua th√™m v·∫≠t ph·∫©m";

                return api.sendMessage(inventoryMsg, threadID, messageID);
            }
            case "fight": {

                const player = playerData[senderID];
                if (!player) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                }

                if (target[1]?.toLowerCase() === "monster" || target[1]?.toLowerCase() === "quai") {
                    const now = Date.now();
                    const fightCooldown = 30000;
                    if (player.lastMonsterFight && now - player.lastMonsterFight < fightCooldown) {
                        const timeLeft = Math.ceil((fightCooldown - (now - player.lastMonsterFight)) / 1000);
                        return api.sendMessage(
                            `‚è≥ Vui l√≤ng ƒë·ª£i ${timeLeft}s ƒë·ªÉ ph·ª•c h·ªìi s·ª©c!`,
                            threadID, messageID
                        );
                    }

                    const planetMonsters = Object.entries(MONSTERS)
                        .filter(([id, monster]) => monster.planet === player.planet)
                        .map(([id, monster]) => ({ id, ...monster }));

                    if (planetMonsters.length === 0) {
                        return api.sendMessage(
                            `‚ùå Kh√¥ng c√≥ qu√°i v·∫≠t n√†o ·ªü ${PLANETS[player.planet].name}!`,
                            threadID, messageID
                        );
                    }

                    const randomMonster = planetMonsters[Math.floor(Math.random() * planetMonsters.length)];
                    const monsterType = randomMonster.id;
                    const monster = randomMonster;

                    // Kh·ªüi t·∫°o th√¥ng s·ªë chi·∫øn ƒë·∫•u ban ƒë·∫ßu
                    let playerHP = player.stats.health;
                    let playerKi = player.stats.ki;
                    let playerDamage = player.stats.damage; // ƒê·ªãnh nghƒ©a playerDamage d·ª±a tr√™n stats.damage
                    let monsterHP = monster.hp;
                    let monsterDamage = monster.power / 10;
                    let battleLog = [];

                    const originalPlayerKi = player.stats.ki;

                    if (player.inventory?.items) {
                        const equipped = player.inventory.items.filter(item => item.equipped);
                        equipped.forEach(item => {
                            if (item.id === "armor") {
                                playerHP *= 1.15;
                            }
                            if (item.id === "scouter") {
                                playerDamage *= 1.1;
                            }
                        });
                    }

                    // Kh·ªüi t·∫°o tr·∫°ng th√°i hi·ªáu ·ª©ng
                    let playerStates = {
                        stunned: 0,           // S·ªë l∆∞·ª£t b·ªã cho√°ng
                        shielded: 0,          // S·ªë l∆∞·ª£t ƒë∆∞·ª£c b·∫£o v·ªá b·ªüi khi√™n
                        bound: 0,             // S·ªë l∆∞·ª£t b·ªã tr√≥i
                        powerBoosted: 0,      // S·ªë l∆∞·ª£t ƒë∆∞·ª£c tƒÉng s·ª©c m·∫°nh (Kaioken)
                        powerBoostMultiplier: 1.0  // H·ªá s·ªë tƒÉng s·ª©c m·∫°nh
                    };

                    let monsterStates = {
                        stunned: 0,           // S·ªë l∆∞·ª£t b·ªã cho√°ng
                        bound: 0              // S·ªë l∆∞·ª£t b·ªã tr√≥i
                    };

                    battleLog.push(`‚öîÔ∏è ${player.name} ƒëang ƒë√°nh v·ªõi ${monster.name}!`);

                    // ƒê·∫£m b·∫£o player c√≥ skill, n·∫øu kh√¥ng c√≥ th√¨ s·∫Ω ch·ªâ ƒë√°nh th∆∞·ªùng
                    if (!player.skills) player.skills = [];

                    let turn = 0;
                    const MAX_TURNS = 20; // T·ªëi ƒëa 20 l∆∞·ª£t ƒë·ªÉ tr√°nh tr·∫≠n ƒë·∫•u qu√° d√†i

                    while (playerHP > 0 && monsterHP > 0 && turn < MAX_TURNS) {
                        turn++;

                        // L∆∞·ª£t c·ªßa ng∆∞·ªùi ch∆°i
                        if (!playerStates.stunned && !playerStates.bound) {
                            // 70% c∆° h·ªôi d√πng skill n·∫øu c√≥
                            if (player.skills.length > 0 && Math.random() < 0.7) {
                                const skillChoice = player.skills[Math.floor(Math.random() * player.skills.length)];
                                const [master, skillName] = skillChoice.split(":");
                                const skillData = MASTERS[master].skills[skillName];

                                // T√≠nh to√°n s√°t th∆∞∆°ng v√† chi ph√≠ ki
                                const skillDamage = Math.floor(playerDamage * skillData.powerScale);
                                const kiRequired = Math.floor(playerKi * skillData.kiCost);
                                if (playerKi >= kiRequired || skillData.kiCost < 0) {
                                    // X·ª≠ l√Ω c√°c lo·∫°i skill kh√°c nhau
                                    if (skillData.powerScale > 0) {
                                        // Skill g√¢y s√°t th∆∞∆°ng
                                        monsterHP -= playerStates.powerBoosted > 0 ?
                                            skillDamage * playerStates.powerBoostMultiplier : skillDamage;

                                        if (skillData.kiCost > 0) playerKi -= kiRequired;

                                        const actualDamage = playerStates.powerBoosted > 0 ?
                                            Math.floor(skillDamage * playerStates.powerBoostMultiplier) : skillDamage;

                                        battleLog.push(
                                            `üéØ ${player.name} d√πng ${skillData.name} g√¢y ${actualDamage.toLocaleString()} s√°t th∆∞∆°ng!` +
                                            (skillData.kiCost > 0 ? `\n‚ú® -${kiRequired} Ki` : "")
                                        );

                                        // X·ª≠ l√Ω c√°c skill ƒë·∫∑c bi·ªát theo t√™n
                                        if (skillName === "SELF_DESTRUCT") {
                                            playerHP = 1; // G·∫ßn ch·∫øt nh∆∞ng kh√¥ng ch·∫øt h·∫≥n
                                            battleLog.push(`üí• ${player.name} ƒë√£ t·ª± ph√°t n·ªï! M·∫•t g·∫ßn h·∫øt HP!`);
                                        }
                                    } else {
                                        // X·ª≠ l√Ω c√°c skill phi s√°t th∆∞∆°ng
                                        switch (skillName) {
                                            case "SOLAR_FLARE":
                                                monsterStates.stunned = 2; // Cho√°ng 2 l∆∞·ª£t
                                                if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                battleLog.push(`‚òÄÔ∏è ${player.name} d√πng Th√°i D∆∞∆°ng H·∫° San! ${monster.name} b·ªã cho√°ng trong 2 l∆∞·ª£t!`);
                                                break;

                                            case "HYPNOSIS":
                                                monsterStates.stunned = 3; // Cho√°ng 3 l∆∞·ª£t
                                                if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                battleLog.push(`üåÄ ${player.name} d√πng Th√¥i Mi√™n! ${monster.name} b·ªã cho√°ng trong 3 l∆∞·ª£t!`);
                                                break;

                                            case "KAIOKEN":
                                                playerStates.powerBoosted = 3; // TƒÉng s·ª©c m·∫°nh trong 3 l∆∞·ª£t
                                                playerStates.powerBoostMultiplier = 3.0;
                                                if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                battleLog.push(`üî• ${player.name} d√πng Kaioken! S·ª©c m·∫°nh tƒÉng x3 trong 3 l∆∞·ª£t!`);
                                                break;

                                            case "BIND":
                                                monsterStates.bound = 2; // Tr√≥i 2 l∆∞·ª£t
                                                if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                battleLog.push(`üîó ${player.name} d√πng Tr√≥i! ${monster.name} b·ªã tr√≥i trong 2 l∆∞·ª£t!`);
                                                break;

                                            case "ENERGY_SHIELD":
                                                playerStates.shielded = 4; // Khi√™n b·∫£o v·ªá trong 4 l∆∞·ª£t
                                                if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                battleLog.push(`üõ°Ô∏è ${player.name} d√πng Khi√™n NƒÉng L∆∞·ª£ng! ƒê∆∞·ª£c b·∫£o v·ªá trong 4 l∆∞·ª£t!`);
                                                break;

                                            case "REGENERATION":
                                            case "WHISTLE":
                                                // H·ªìi HP v√†/ho·∫∑c Ki
                                                const oldHP = playerHP;
                                                playerHP = Math.min(player.stats.health, playerHP + Math.floor(player.stats.health * 0.3));

                                                // X·ª≠ l√Ω h·ªìi ki n·∫øu l√† skill c√≥ kiCost √¢m
                                                if (skillData.kiCost < 0) {
                                                    const kiRestore = Math.abs(kiRequired);
                                                    playerKi = Math.min(player.stats.ki, playerKi + kiRestore);
                                                    battleLog.push(`‚ú® ${player.name} h·ªìi ${kiRestore} Ki!`);

                                                    battleLog.push(
                                                        `üíö ${player.name} d√πng ${skillData.name}!` +
                                                        `\n‚ù§Ô∏è HP: ${oldHP} ‚Üí ${playerHP}` +
                                                        `\n‚ú® Ki: ${oldKi} ‚Üí ${player.stats.ki}`
                                                    );
                                                } else {
                                                    if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                    battleLog.push(`üíö ${player.name} d√πng ${skillData.name}! HP: ${oldHP} ‚Üí ${playerHP}`);
                                                }
                                                break;

                                            default:
                                                if (skillData.kiCost < 0) {
                                                    // H·ªìi ki
                                                    const kiRestore = Math.abs(kiRequired);
                                                    const oldKi = player.stats.ki;
                                                    player.stats.ki = Math.min(player.stats.ki + kiRestore, player.stats.health); // Gi·∫£ s·ª≠ ki t·ªëi ƒëa = health
                                                    battleLog.push(`‚ú® ${player.name} d√πng ${skillData.name}! Ki: ${oldKi} ‚Üí ${player.stats.ki}`);
                                                } else {
                                                    // Skill kh√°c ch∆∞a x√°c ƒë·ªãnh
                                                    if (skillData.kiCost > 0) playerKi -= kiRequired;
                                                    battleLog.push(`‚ö° ${player.name} d√πng ${skillData.name}!`);
                                                }
                                        }
                                    }
                                } else {
                                    // Kh√¥ng ƒë·ªß ki, ƒë√°nh th∆∞·ªùng
                                    const normalDamage = Math.floor(playerDamage * 0.8); // Gi·∫£m 20% s√°t th∆∞∆°ng khi ƒë√°nh th∆∞·ªùng
                                    monsterHP -= normalDamage;
                                    battleLog.push(`üëä ${player.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                }
                            } else {
                                // ƒê√°nh th∆∞·ªùng n·∫øu kh√¥ng d√πng skill
                                const normalDamage = playerStates.powerBoosted > 0 ?
                                    Math.floor(playerDamage * playerStates.powerBoostMultiplier * 0.8) :
                                    Math.floor(playerDamage * 0.8);

                                monsterHP -= normalDamage;
                                battleLog.push(`üëä ${player.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                            }
                        } else if (playerStates.stunned > 0) {
                            battleLog.push(`üòµ ${player.name} ƒëang b·ªã cho√°ng! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
                            playerStates.stunned--;
                        } else if (playerStates.bound > 0) {
                            battleLog.push(`üîó ${player.name} ƒëang b·ªã tr√≥i! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
                            playerStates.bound--;
                        }

                        if (monsterHP <= 0) break;

                        // L∆∞·ª£t c·ªßa qu√°i v·∫≠t
                        if (!monsterStates.stunned && !monsterStates.bound) {
                            const monsterAttack = Math.floor(monsterDamage * (0.8 + Math.random() * 0.4));

                            // N·∫øu c√≥ khi√™n, kh√¥ng nh·∫≠n s√°t th∆∞∆°ng
                            if (playerStates.shielded > 0) {
                                battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${player.name} ƒë√£ ch·∫∑n ${monsterAttack.toLocaleString()} s√°t th∆∞∆°ng!`);
                                playerStates.shielded--;

                                // Th√¥ng b√°o khi khi√™n s·∫Øp h·∫øt
                                if (playerStates.shielded === 1) {
                                    battleLog.push(`‚ö†Ô∏è Khi√™n nƒÉng l∆∞·ª£ng s·∫Ω bi·∫øn m·∫•t sau l∆∞·ª£t ti·∫øp theo!`);
                                }
                            } else {
                                // Nh·∫≠n s√°t th∆∞∆°ng b√¨nh th∆∞·ªùng
                                playerHP -= monsterAttack;
                                battleLog.push(`üí• ${monster.name} t·∫•n c√¥ng g√¢y ${monsterAttack.toLocaleString()} s√°t th∆∞∆°ng!`);
                            }
                        } else if (monsterStates.stunned > 0) {
                            battleLog.push(`üòµ ${monster.name} ƒëang b·ªã cho√°ng! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
                            monsterStates.stunned--;
                        } else if (monsterStates.bound > 0) {
                            battleLog.push(`üîó ${monster.name} ƒëang b·ªã tr√≥i! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
                            monsterStates.bound--;
                        }

                        // C·∫≠p nh·∫≠t c√°c tr·∫°ng th√°i
                        if (playerStates.powerBoosted > 0) {
                            playerStates.powerBoosted--;
                            if (playerStates.powerBoosted === 0) {
                                battleLog.push(`‚ö†Ô∏è Hi·ªáu ·ª©ng Kaioken c·ªßa ${player.name} ƒë√£ h·∫øt!`);
                            }
                        }
                    }

                    player.lastMonsterFight = now;

                    if (playerHP > 0) {

                        const kiLost = originalPlayerKi - playerKi;
                        const kiRestore = Math.floor(kiLost * 0.7);
                        player.stats.ki = Math.min(originalPlayerKi, playerKi + kiRestore);

                        player.stats.ki = playerKi;
                        let expGain = monster.exp;
                        let zeniGain = monster.zeni;

                        const playerLevel = player.stats.level || 1;
                        expGain = Math.floor(expGain * (1 + playerLevel * 0.05));
                        zeniGain = Math.floor(zeniGain * (1 + playerLevel * 0.03));

                        if (player.stats.exp + expGain > MAX_EXP_STORAGE) {
                            player.stats.exp = MAX_EXP_STORAGE;
                        } else {
                            player.stats.exp += expGain;
                        }

                        player.stats.zeni += zeniGain;

                        let dropMessage = "";
                        if (monster.dropChance > 0 && Math.random() < monster.dropChance) {
                            const dropItem = monster.dropItem;
                            if (dropItem && SHOP_ITEMS[dropItem.toUpperCase()]) {
                                if (!player.inventory) player.inventory = { items: [] };
                                if (!player.inventory.items) player.inventory.items = [];

                                const item = SHOP_ITEMS[dropItem.toUpperCase()];
                                const existingItem = player.inventory.items.find(i => i.id === dropItem);

                                if (existingItem) {
                                    existingItem.quantity += 1;
                                } else {
                                    player.inventory.items.push({
                                        id: dropItem,
                                        quantity: 1,
                                        type: item.type
                                    });
                                }

                                dropMessage = `\nüéÅ ${monster.name} r∆°i ra: ${item.name}!`;
                            }
                        }

                        updateQuestProgress(player, QUEST_TYPES.COMBAT, { monster: monsterType });
                        savePlayerData(playerData);

                        return api.sendMessage(
                            "üèÜ CHI·∫æN TH·∫ÆNG! üèÜ\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n` +
                            battleLog.slice(-5).join("\n") + "\n\n" +
                            "üí° K·∫øt qu·∫£:\n" +
                            `üìä EXP +${expGain.toLocaleString()}\n` +
                            `üí∞ Zeni +${zeniGain.toLocaleString()}` +
                            dropMessage + "\n\n" +
                            "üí° G√µ .dball fight monster ƒë·ªÉ ƒë√°nh ti·∫øp",
                            threadID, messageID
                        );
                    } else {
                        return api.sendMessage(
                            "üíÄ TH·∫§T B·∫†I! üíÄ\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n` +
                            battleLog.slice(-5).join("\n") + "\n\n" +
                            `‚ùå B·∫°n ƒë√£ b·ªã ƒë√°nh b·∫°i b·ªüi ${monster.name}!\n` +
                            "üí° H√£y luy·ªán t·∫≠p th√™m ƒë·ªÉ tr·ªü n√™n m·∫°nh h∆°n!",
                            threadID, messageID
                        );
                    }
                } else {
                    const mention = Object.keys(event.mentions)[0];
                    if (!mention) {
                        return api.sendMessage(
                            "‚ùì B·∫°n mu·ªën ƒë√°nh ai?\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            "‚Ä¢ .dball fight @ng∆∞·ªùi_ch∆°i - PvP v·ªõi ng∆∞·ªùi ch∆°i kh√°c\n" +
                            "‚Ä¢ .dball fight monster - ƒê√°nh qu√°i v·∫≠t\n" +
                            "‚Ä¢ .dball fight monster list - Danh s√°ch qu√°i v·∫≠t\n" +
                            "‚Ä¢ .dball fight monster <t√™n_qu√°i> - ƒê√°nh qu√°i c·ª• th·ªÉ",
                            threadID, messageID
                        );
                    }

                    const opponent = playerData[mention];
                    if (!opponent) {
                        return api.sendMessage("‚ùå ƒê·ªëi th·ªß ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    const originalPlayerKi = player.stats.ki;
                    const originalOpponentKi = opponent.stats.ki;

                    let playerHP = player.stats.health;
                    let playerDamage = player.stats.damage;
                    let playerKi = player.stats.ki;
                    let oppHP = opponent.stats.health;
                    let oppDamage = opponent.stats.damage;
                    let oppKi = opponent.stats.ki;
                    let battleLog = [];

                    // Player states for PvP
                    let playerPowerBoosted = 0;
                    let playerPowerBoostMultiplier = 1.0;
                    let oppPowerBoosted = 0;
                    let oppPowerBoostMultiplier = 1.0;

                    while (playerHP > 0 && oppHP > 0) {
                        // Player's turn
                        if (player.skills.length > 0) {
                            const skill = player.skills[Math.floor(Math.random() * player.skills.length)];
                            const [master, skillName] = skill.split(":");
                            const skillData = MASTERS[master].skills[skillName];

                            const skillDamage = Math.floor(playerDamage * skillData.powerScale);
                            const kiRequired = Math.floor(playerKi * Math.abs(skillData.kiCost));

                            if (playerKi >= kiRequired || skillData.kiCost < 0) {
                                if (skillData.powerScale > 0) {
                                    // Fix: use oppHP instead of monsterHP
                                    const actualDamage = playerPowerBoosted > 0
                                        ? Math.floor(skillDamage * playerPowerBoostMultiplier)
                                        : skillDamage;

                                    oppHP -= actualDamage;

                                    if (skillData.kiCost > 0) playerKi -= kiRequired;

                                    battleLog.push(
                                        `üéØ ${player.name} d√πng ${skillData.name} g√¢y ${actualDamage.toLocaleString()} s√°t th∆∞∆°ng!` +
                                        (skillData.kiCost > 0 ? `\n‚ú® -${kiRequired} Ki` : "")
                                    );
                                } else if (skillData.kiCost < 0) {
                                    // Skill h·ªìi ph·ª•c
                                    const kiRestore = kiRequired;
                                    playerKi = Math.min(player.stats.ki, playerKi + kiRestore);
                                    battleLog.push(`‚ú® ${player.name} d√πng ${skillData.name}, h·ªìi ph·ª•c ${kiRestore} Ki!`);
                                } else {
                                    // C√°c k·ªπ nƒÉng ƒë·∫∑c bi·ªát kh√°c (d·ª±a theo t√™n)
                                    if (skillName === "KAIOKEN") {
                                        playerPowerBoosted = 3;
                                        playerPowerBoostMultiplier = 3.0;
                                        if (skillData.kiCost > 0) playerKi -= kiRequired;
                                        battleLog.push(`üî• ${player.name} d√πng Kaioken! S·ª©c m·∫°nh tƒÉng x3 trong 3 l∆∞·ª£t!`);
                                    } else {
                                        if (skillData.kiCost > 0) playerKi -= kiRequired;
                                        battleLog.push(`‚ö° ${player.name} d√πng ${skillData.name}!`);
                                    }
                                }
                            } else {
                                // Kh√¥ng ƒë·ªß ki, ƒë√°nh th∆∞·ªùng
                                const normalDamage = Math.floor(playerDamage * 0.8);
                                oppHP -= normalDamage;
                                battleLog.push(`üëä ${player.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                            }
                        } else {
                            // ƒê√°nh th∆∞·ªùng n·∫øu kh√¥ng c√≥ k·ªπ nƒÉng
                            const normalDamage = Math.floor(playerDamage * 0.8);
                            oppHP -= normalDamage;
                            battleLog.push(`üëä ${player.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                        }

                        if (oppHP <= 0) break;

                        // Opponent's turn
                        if (opponent.skills.length > 0) {
                            const skill = opponent.skills[Math.floor(Math.random() * opponent.skills.length)];
                            const [master, skillName] = skill.split(":");
                            const skillData = MASTERS[master].skills[skillName];

                            const skillDamage = Math.floor(oppDamage * skillData.powerScale);
                            const kiRequired = Math.floor(oppKi * Math.abs(skillData.kiCost));

                            if (oppKi >= kiRequired || skillData.kiCost < 0) {
                                if (skillData.powerScale > 0) {
                                    const actualDamage = oppPowerBoosted > 0
                                        ? Math.floor(skillDamage * oppPowerBoostMultiplier)
                                        : skillDamage;

                                    playerHP -= actualDamage;

                                    if (skillData.kiCost > 0) oppKi -= kiRequired;

                                    battleLog.push(
                                        `üéØ ${opponent.name} d√πng ${skillData.name} g√¢y ${actualDamage.toLocaleString()} s√°t th∆∞∆°ng!` +
                                        (skillData.kiCost > 0 ? `\n‚ú® -${kiRequired} Ki` : "")
                                    );
                                } else if (skillData.kiCost < 0) {

                                    const kiRestore = kiRequired;
                                    oppKi = Math.min(opponent.stats.ki, oppKi + kiRestore);
                                    battleLog.push(`‚ú® ${opponent.name} d√πng ${skillData.name}, h·ªìi ph·ª•c ${kiRestore} Ki!`);
                                }
                            } else {
                                const normalDamage = Math.floor(oppDamage * 0.8);
                                playerHP -= normalDamage;
                                battleLog.push(`üëä ${opponent.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                            }
                        } else {
                            const normalDamage = Math.floor(oppDamage * 0.8);
                            playerHP -= normalDamage;
                            battleLog.push(`üëä ${opponent.name} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                        }

                        if (playerPowerBoosted > 0) {
                            playerPowerBoosted--;
                            if (playerPowerBoosted === 0) {
                                battleLog.push(`‚ö†Ô∏è Hi·ªáu ·ª©ng Kaioken c·ªßa ${player.name} ƒë√£ h·∫øt!`);
                            }
                        }

                        if (oppPowerBoosted > 0) {
                            oppPowerBoosted--;
                            if (oppPowerBoosted === 0) {
                                battleLog.push(`‚ö†Ô∏è Hi·ªáu ·ª©ng Kaioken c·ªßa ${opponent.name} ƒë√£ h·∫øt!`);
                            }
                        }
                    }

                    const winner = playerHP > 0 ? player : opponent;
                    const loser = playerHP > 0 ? opponent : player;

                    const playerKiLost = originalPlayerKi - playerKi;
                    const opponentKiLost = originalOpponentKi - oppKi;

                    player.stats.ki = Math.min(originalPlayerKi, playerKi + Math.floor(playerKiLost * 0.6));
                    opponent.stats.ki = Math.min(originalOpponentKi, oppKi + Math.floor(opponentKiLost * 0.6));

                    winner.stats.exp += 20;
                    savePlayerData(playerData);

                    return api.sendMessage(
                        "‚öîÔ∏è K·∫æT QU·∫¢ TR·∫¨N ƒê·∫§U ‚öîÔ∏è\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        battleLog.slice(-5).join("\n") + "\n\n" +
                        `üèÜ Ng∆∞·ªùi th·∫Øng: ${winner.name}\n` +
                        `üíî Ng∆∞·ªùi thua: ${loser.name}\n\n` +
                        `üìä EXP th∆∞·ªüng: +20\n` +
                        `‚ú® Ki ƒë√£ ƒë∆∞·ª£c h·ªìi ph·ª•c m·ªôt ph·∫ßn!`,
                        threadID, messageID
                    );
                }
            }

            case "rank": {
                const players = Object.entries(playerData)
                    .map(([id, data]) => ({
                        id,
                        name: data.name,
                        power: data.stats.power
                    }))
                    .sort((a, b) => b.power - a.power)
                    .slice(0, 10);

                let ranking = "üèÜ B·∫¢NG X·∫æP H·∫†NG üèÜ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";
                players.forEach((player, index) => {
                    const medal = index === 0 ? "ü•á" : index === 1 ? "ü•à" : index === 2 ? "ü•â" : "üéñÔ∏è";
                    ranking += `${medal} ${index + 1}. ${player.name}\n`;
                    ranking += `üí™ S·ª©c m·∫°nh: ${player.power}\n\n`;
                });

                return api.sendMessage(ranking, threadID, messageID);
            }

            default: {
                if (!playerData[senderID]) {
                    return api.sendMessage(
                        "‚ùå Vui l√≤ng ch·ªçn h√†nh tinh h·ª£p l·ªá!\n\n" +
                        "C√°c h√†nh tinh:\n" +
                        Object.entries(PLANETS).map(([key, data]) =>
                            `- ${key}: ${data.name} (x${data.powerBonus})`
                        ).join("\n"),
                        threadID, messageID
                    );
                }
                return api.sendMessage(
                    "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!\n\n" +
                    "C√°c l·ªánh:\n" +
                    "‚Ä¢ info - Xem th√¥ng tin\n" +
                    "‚Ä¢ train - Luy·ªán t·∫≠p\n" +
                    "‚Ä¢ fight - ƒê·∫•u v·ªõi ng∆∞·ªùi kh√°c\n" +
                    "‚Ä¢ rank - Xem b·∫£ng x·∫øp h·∫°ng",
                    threadID, messageID
                );
            }
        }
    }
};

function loadPlayerData() {
    try {
        return JSON.parse(fs.readFileSync(DB_FILE));
    } catch (err) {
        return {};
    }
}

function savePlayerData(data) {
    fs.writeFileSync(DB_FILE, JSON.stringify(data, null, 2));
}
