const fs = require("fs");
const path = require("path");
const createTrainImage = require("../game/canvas/dballTrainCanvas.js");
const createMenuImage = require("../game/canvas/dballMenuCanvas.js");
const createAmuletShopImage = require("../game/canvas/dballShopbuaCanvas.js");
const createLearnImage = require("../game/canvas/dballLearnCanvas.js");
const createRadarShopImage = require("../game/canvas/dballShopRadaCanvas.js");

function getFontPath(fontName) {
    return path.join(__dirname, "../fonts", fontName);
}

const DB_FOLDER = path.join(__dirname, "json", "dragonball");
const DB_FILE = path.join(DB_FOLDER, "players.json");
const DB_BALL_FILE = path.join(DB_FOLDER, "ball.json");
const TOURNAMENT_DB = path.join(DB_FOLDER, "tournaments.json");


const EQUIPMENT_ITEMS = {

    EARTH_ARMOR_1: {
        id: "turtle_gi",
        name: "ƒê·ªì V√µ Quy L√£o",
        price: 2500000,
        description: "ƒê·ªìng ph·ª•c c·ªßa v√µ ƒë∆∞·ªùng Quy L√£o",
        type: "armor",
        planet: "EARTH",
        boost: 1.2,
        emoji: "üß•",
        requiredPower: 10000
    },
    EARTH_ARMOR_2: {
        id: "z_fighter_armor",
        name: "Gi√°p Chi·∫øn Binh Z",
        price: 10000000,
        description: "Gi√°p ƒë·∫∑c bi·ªát c·ªßa c√°c chi·∫øn binh Z",
        type: "armor",
        planet: "EARTH",
        boost: 1.5,
        emoji: "üõ°Ô∏è",
        requiredPower: 100000
    },
    EARTH_ARMOR_3: {
        id: "weighted_clothing",
        name: "√Åo N·∫∑ng Piccolo",
        price: 20000000,
        description: "√Åo n·∫∑ng d√πng ƒë·ªÉ luy·ªán t·∫≠p nh∆∞ Piccolo",
        type: "armor",
        planet: "EARTH",
        boost: 1.8,
        emoji: "üß•",
        requiredPower: 500000
    },
    EARTH_GLOVES_1: {
        id: "turtle_gloves",
        name: "GƒÉng Quy L√£o",
        price: 3000000,
        description: "GƒÉng tay v√µ ƒë∆∞·ªùng Quy L√£o",
        type: "gloves",
        planet: "EARTH",
        boost: 1.25,
        emoji: "ü•ä",
        requiredPower: 15000
    },
    EARTH_GLOVES_2: {
        id: "champion_gloves",
        name: "GƒÉng Tay V√µ Sƒ©",
        price: 15000000,
        description: "GƒÉng tay c·ªßa nh·ªØng nh√† v√¥ ƒë·ªãch ƒê·∫°i H·ªôi V√µ Thu·∫≠t",
        type: "gloves",
        planet: "EARTH",
        boost: 1.6,
        emoji: "ü•ä",
        requiredPower: 200000
    },
    EARTH_BOOTS_1: {
        id: "weighted_boots",
        name: "Gi√†y N·∫∑ng",
        price: 15000000,
        description: "Gi√†y t·∫≠p luy·ªán v·ªõi tr·ªçng l∆∞·ª£ng cao",
        type: "boots",
        planet: "EARTH",
        boost: 1.3,
        emoji: "üëü",
        requiredPower: 25000
    },
    EARTH_BOOTS_2: {
        id: "gravity_boots",
        name: "Gi√†y Tr·ªçng L·ª±c",
        price: 25000000,
        description: "Gi√†y ƒë∆∞·ª£c thi·∫øt k·∫ø b·ªüi Bulma, tƒÉng tr·ªçng l·ª±c",
        type: "boots",
        planet: "EARTH",
        boost: 1.7,
        emoji: "üëü",
        requiredPower: 300000
    },


    NAMEK_ARMOR_1: {
        id: "namek_robe",
        name: "√Åo Cho√†ng Namek",
        price: 400000,
        description: "√Åo cho√†ng c·ªßa chi·∫øn binh t·ªôc Namek",
        type: "armor",
        planet: "NAMEK",
        boost: 1.3,
        emoji: "üëò",
        requiredPower: 20000
    },
    NAMEK_ARMOR_2: {
        id: "elder_robe",
        name: "√Åo Cho√†ng Tr∆∞·ªüng L√£o",
        price: 1800000,
        description: "√Åo cho√†ng c·ªßa Tr∆∞·ªüng l√£o Namek",
        type: "armor",
        planet: "NAMEK",
        boost: 1.6,
        emoji: "üëò",
        requiredPower: 300000
    },
    NAMEK_ARMOR_3: {
        id: "fusion_armor",
        name: "√Åo Gi√°p H·ª£p Th·ªÉ",
        price: 35000000,
        description: "Gi√°p ƒë·∫∑c bi·ªát sau khi h·ª£p th·ªÉ v·ªõi nhi·ªÅu Namek",
        type: "armor",
        planet: "NAMEK",
        boost: 2.0,
        emoji: "üõ°Ô∏è",
        requiredPower: 1000000
    },
    NAMEK_GLOVES_1: {
        id: "namek_gauntlets",
        name: "GƒÉng Tay Namek",
        price: 5000000,
        description: "GƒÉng tay tƒÉng s·ª©c m·∫°nh c·ªßa t·ªôc Namek",
        type: "gloves",
        planet: "NAMEK",
        boost: 1.35,
        emoji: "üß§",
        requiredPower: 30000
    },
    NAMEK_GLOVES_2: {
        id: "dragon_clan_gloves",
        name: "GƒÉng Tay T·ªôc R·ªìng",
        price: 22000000,
        description: "GƒÉng tay c·ªßa t·ªôc R·ªìng Namek",
        type: "gloves",
        planet: "NAMEK",
        boost: 1.75,
        emoji: "üß§",
        requiredPower: 500000
    },
    NAMEK_BOOTS_1: {
        id: "namek_boots",
        name: "Gi√†y Namek",
        price: 4500000,
        description: "Gi√†y c·ªßa chi·∫øn binh Namek",
        type: "boots",
        planet: "NAMEK",
        boost: 1.4,
        emoji: "üë¢",
        requiredPower: 25000
    },
    NAMEK_BOOTS_2: {
        id: "porunga_boots",
        name: "Gi√†y Porunga",
        price: 30000000,
        description: "Gi√†y ƒë∆∞·ª£c ban ph√©p b·ªüi Porunga",
        type: "boots",
        planet: "NAMEK",
        boost: 1.9,
        emoji: "üë¢",
        requiredPower: 800000
    },


    SAIYAN_ARMOR_1: {
        id: "saiyan_armor",
        name: "√Åo Gi√°p Saiyan",
        price: 600000,
        description: "Gi√°p chi·∫øn ƒë·∫•u c·ªßa t·ªôc Saiyan",
        type: "armor",
        planet: "SAIYAN",
        boost: 1.4,
        emoji: "ü¶∫",
        requiredPower: 30000
    },
    SAIYAN_ARMOR_2: {
        id: "royal_armor",
        name: "Gi√°p Ho√†ng Gia Saiyan",
        price: 1500000,
        description: "Gi√°p ƒë·∫∑c bi·ªát c·ªßa ho√†ng t·ªôc Saiyan",
        type: "armor",
        planet: "SAIYAN",
        boost: 1.7,
        emoji: "üëë",
        requiredPower: 150000
    },
    SAIYAN_ARMOR_3: {
        id: "frieza_force_armor",
        name: "Gi√°p Qu√¢n ƒê·ªôi Frieza",
        price: 30000000,
        description: "Gi√°p ti√™n ti·∫øn c·ªßa qu√¢n ƒë·ªôi Frieza",
        type: "armor",
        planet: "SAIYAN",
        boost: 2.0,
        emoji: "ü¶∫",
        requiredPower: 800000
    },
    SAIYAN_GLOVES_1: {
        id: "battle_gloves",
        name: "GƒÉng Chi·∫øn ƒê·∫•u Saiyan",
        price: 700000,
        description: "GƒÉng tay chi·∫øn ƒë·∫•u tƒÉng s·ª©c m·∫°nh c·ªßa Saiyan",
        type: "gloves",
        planet: "SAIYAN",
        boost: 1.45,
        emoji: "üß§",
        requiredPower: 40000
    },
    SAIYAN_GLOVES_2: {
        id: "super_battle_gloves",
        name: "GƒÉng Tay Si√™u Chi·∫øn",
        price: 25000000,
        description: "GƒÉng tay cho nh·ªØng Si√™u Saiyan",
        type: "gloves",
        planet: "SAIYAN",
        boost: 1.8,
        emoji: "üß§",
        requiredPower: 500000
    },
    SAIYAN_BOOTS_1: {
        id: "battle_boots",
        name: "Gi√†y Chi·∫øn ƒê·∫•u Saiyan",
        price: 6500000,
        description: "Gi√†y chi·∫øn ƒë·∫•u tƒÉng Ki c·ªßa Saiyan",
        type: "boots",
        planet: "SAIYAN",
        boost: 1.5,
        emoji: "üë¢",
        requiredPower: 35000
    },
    SAIYAN_BOOTS_2: {
        id: "royal_boots",
        name: "Gi√†y Ho√†ng Gia",
        price: 40000000,
        description: "Gi√†y c·ªßa Ho√†ng t·ªôc Saiyan",
        type: "boots",
        planet: "SAIYAN",
        boost: 2.0,
        emoji: "üë¢",
        requiredPower: 1000000
    },


    RADAR_1: {
        id: "radar_1",
        name: "Rada C·∫•p 1",
        price: 50000000,
        description: "TƒÉng nh·∫π EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+20%)",
        type: "radar",
        boost: 1.2,
        emoji: "üì°",
        requiredPower: 0
    },
    RADAR_2: {
        id: "radar_2",
        name: "Rada C·∫•p 2",
        price: 100000000,
        description: "TƒÉng EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+40%)",
        type: "radar",
        boost: 1.4,
        emoji: "üì°",
        requiredPower: 50000
    },
    RADAR_3: {
        id: "radar_3",
        name: "Rada C·∫•p 3",
        price: 200000000,
        description: "TƒÉng ƒë√°ng k·ªÉ EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+60%)",
        type: "radar",
        boost: 1.6,
        emoji: "üì°",
        requiredPower: 200000
    },
    RADAR_4: {
        id: "radar_4",
        name: "Rada C·∫•p 4",
        price: 400000000,
        description: "TƒÉng nhi·ªÅu EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+80%)",
        type: "radar",
        boost: 1.8,
        emoji: "üì°",
        requiredPower: 500000
    },
    RADAR_5: {
        id: "radar_5",
        name: "Rada C·∫•p 5",
        price: 800000000,
        description: "TƒÉng r·∫•t nhi·ªÅu EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+100%)",
        type: "radar",
        boost: 2.0,
        emoji: "üì°",
        requiredPower: 1000000
    },
    RADAR_6: {
        id: "radar_6",
        name: "Rada C·∫•p 6",
        price: 1500000000,
        description: "TƒÉng c·ª±c nhi·ªÅu EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+130%)",
        type: "radar",
        boost: 2.3,
        emoji: "üì°",
        requiredPower: 5000000
    },
    RADAR_7: {
        id: "radar_7",
        name: "Rada C·∫•p 7",
        price: 3000000000,
        description: "TƒÉng kh·ªïng l·ªì EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+160%)",
        type: "radar",
        boost: 2.6,
        emoji: "üì°",
        requiredPower: 10000000
    },
    RADAR_8: {
        id: "radar_8",
        name: "Rada C·∫•p 8",
        price: 6000000000,
        description: "TƒÉng kinh kh·ªßng EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+200%)",
        type: "radar",
        boost: 3.0,
        emoji: "üì°",
        requiredPower: 50000000
    },
    RADAR_9: {
        id: "radar_9",
        name: "Rada C·∫•p 9",
        price: 10000000000,
        description: "TƒÉng th·∫ßn th√°nh EXP v√† s·ª©c m·∫°nh nh·∫≠n ƒë∆∞·ª£c (+250%)",
        type: "radar",
        boost: 3.5,
        emoji: "üì°",
        requiredPower: 100000000
    }
};

const TOURNAMENT_TYPES = {
    TENKAICHI: {
        id: "tenkaichi",
        name: "ƒê·∫°i H·ªôi V√µ Thu·∫≠t Thi√™n H·∫°",
        description: "Gi·∫£i ƒë·∫•u v√µ thu·∫≠t danh gi√° nh·∫•t th·∫ø gi·ªõi!",
        minPlayers: 4,
        maxPlayers: 16,
        entryFee: 10000,
        rewards: {
            first: { zeni: 100000, exp: 50000, item: "tournament_belt" },
            second: { zeni: 50000, exp: 25000 },
            semifinal: { zeni: 20000, exp: 10000 }
        },
        minPower: 50000,
        maxPower: 10000000000
    },
    CELL_GAMES: {
        id: "cell",
        name: "Cell Games",
        description: "S·ªëng s√≥t qua th·ª≠ th√°ch c·ªßa Perfect Cell!",
        minPlayers: 4,
        maxPlayers: 8,
        entryFee: 20000,
        rewards: {
            first: { zeni: 200000, exp: 100000, item: "cell_medal" },
            second: { zeni: 80000, exp: 40000 },
            semifinal: { zeni: 30000, exp: 15000 }
        },
        minPower: 500000,
        maxPower: 10000000000
    },
    UNIVERSE: {
        id: "universe",
        name: "Gi·∫£i ƒê·∫•u S·ª©c M·∫°nh",
        description: "ƒê·∫•u tr∆∞·ªùng gi·ªØa c√°c v≈© tr·ª• v·ªõi quy t·∫Øc kh·∫Øc nghi·ªát!",
        minPlayers: 8,
        maxPlayers: 32,
        entryFee: 50000,
        rewards: {
            first: { zeni: 500000, exp: 200000, item: "universe_medal" },
            second: { zeni: 200000, exp: 100000 },
            semifinal: { zeni: 80000, exp: 40000 },
            quarterfinal: { zeni: 30000, exp: 20000 }
        },
        minPower: 5000000,
        maxPower: Infinity
    }
};

const CAMP_LEVELS = [
    {
        id: "wall_1",
        name: "T∆∞·ªùng Th√†nh 1",
        enemy: "L√≠nh ƒê·ªôc Nh√£n",
        hp: 5000,
        power: 2500,
        exp: 1500,
        zeni: 800,
        requiredPower: 10000,
        dropChance: 0.15,
        dropItem: "senzu"
    },
    {
        id: "wall_2",
        name: "T∆∞·ªùng Th√†nh 2",
        enemy: "L√≠nh ƒê·ªôc Nh√£n C·∫•p Cao",
        hp: 8000,
        power: 4000,
        exp: 2000,
        zeni: 1200,
        requiredPower: 20000,
        dropChance: 0.15,
        dropItem: "crystal"
    },
    {
        id: "wall_3",
        name: "T∆∞·ªùng Th√†nh 3",
        enemy: "L√≠nh ƒê·ªôc Nh√£n Tinh Nhu·ªá",
        hp: 12000,
        power: 6000,
        exp: 3000,
        zeni: 1800,
        requiredPower: 30000,
        dropChance: 0.2,
        dropItem: "senzu"
    },
    {
        id: "camp_1",
        name: "Tr·∫°i ƒê·ªôc Nh√£n 1",
        enemy: "L√≠nh Canh Tr·∫°i",
        hp: 18000,
        power: 9000,
        exp: 4000,
        zeni: 2500,
        requiredPower: 50000,
        dropChance: 0.2,
        dropItem: "crystal"
    },
    {
        id: "camp_2",
        name: "Tr·∫°i ƒê·ªôc Nh√£n 2",
        enemy: "Bi·ªát ƒê·ªôi Tu·∫ßn Tra",
        hp: 25000,
        power: 12500,
        exp: 5000,
        zeni: 3000,
        requiredPower: 80000,
        dropChance: 0.25,
        dropItem: "senzu"
    },
    {
        id: "camp_3",
        name: "Tr·∫°i ƒê·ªôc Nh√£n 3",
        enemy: "ƒê·ªôi ƒê·∫∑c Nhi·ªám",
        hp: 35000,
        power: 17000,
        exp: 6000,
        zeni: 4000,
        requiredPower: 100000,
        dropChance: 0.25,
        dropItem: "armor"
    },
    {
        id: "floor_1",
        name: "T·∫ßng 1",
        enemy: "Trung √öy Tr·∫Øng",
        hp: 50000,
        power: 25000,
        exp: 8000,
        zeni: 6000,
        requiredPower: 150000,
        dropChance: 0.3,
        dropItem: "scouter"
    },
    {
        id: "floor_2",
        name: "T·∫ßng 2",
        enemy: "Trung √öy Xanh L∆°",
        hp: 70000,
        power: 35000,
        exp: 10000,
        zeni: 8000,
        requiredPower: 200000,
        dropChance: 0.3,
        dropItem: "crystal"
    },
    {
        id: "floor_3",
        name: "T·∫ßng 3",
        enemy: "Robot V·ªá Sƒ©",
        hp: 100000,
        power: 50000,
        exp: 15000,
        zeni: 12000,
        requiredPower: 300000,
        dropChance: 0.35,
        dropItem: "senzu"
    },
    {
        id: "floor_4",
        name: "T·∫ßng 4",
        enemy: "T∆∞·ªõng Qu√¢n ƒê·ªôc Nh√£n",
        hp: 150000,
        power: 75000,
        exp: 20000,
        zeni: 18000,
        requiredPower: 500000,
        dropChance: 0.35,
        dropItem: "armor"
    },
    {
        id: "lab",
        name: "T·∫ßng 5 - Ph√≤ng Th√≠ Nghi·ªám",
        enemy: "Ti·∫øn Sƒ© ƒê·ªôc Nh√£n",
        hp: 200000,
        power: 100000,
        exp: 25000,
        zeni: 25000,
        requiredPower: 800000,
        dropChance: 0.4,
        dropItem: "crystal"
    },
    {
        id: "prison",
        name: "T·∫ßng 6 - Nh√† Giam T·ªëi TƒÉm",
        enemy: "ƒêao Ph·ªß M√°y",
        hp: 300000,
        power: 150000,
        exp: 30000,
        zeni: 35000,
        requiredPower: 1200000,
        dropChance: 0.4,
        dropItem: "senzu"
    },
    {
        id: "armory",
        name: "T·∫ßng 7 - Kho V≈© Kh√≠",
        enemy: "Si√™u Chi·∫øn Binh ƒê·ªôc Nh√£n",
        hp: 500000,
        power: 250000,
        exp: 40000,
        zeni: 50000,
        requiredPower: 2000000,
        dropChance: 0.45,
        dropItem: "crystal"
    },
    {
        id: "command",
        name: "T·∫ßng 8 - Ph√≤ng Ch·ªâ Huy",
        enemy: "ƒê·∫°i T∆∞·ªõng ƒê·ªôc Nh√£n",
        hp: 1000000,
        power: 500000,
        exp: 50000,
        zeni: 100000,
        requiredPower: 5000000,
        dropChance: 0.5,
        dropItem: "radar"
    }
];

const AMULETS = {
    IMMORTAL: {
        id: "immortal_amulet",
        name: "B√πa B·∫•t T·ª≠",
        price: 50000,
        description: "Kh√¥ng ch·∫øt khi ƒë√°nh qu√°i trong 1 ng√†y",
        effect: "immortal",
        duration: 86400000,
        emoji: "üßø"
    },
    POWER: {
        id: "power_amulet",
        name: "B√πa S·ª©c M·∫°nh",
        price: 35000,
        description: "TƒÉng 50% s·ª©c ƒë√°nh trong 1 ng√†y",
        effect: "damage_boost",
        boost: 1.5,
        duration: 86400000,
        emoji: "üí™"
    },
    DEFENSE: {
        id: "defense_amulet",
        name: "B√πa Da Tr√¢u",
        price: 40000,
        description: "TƒÉng 50% HP trong 1 ng√†y",
        effect: "health_boost",
        boost: 1.5,
        duration: 86400000,
        emoji: "üõ°Ô∏è"
    },
    ENERGY: {
        id: "energy_amulet",
        name: "B√πa NƒÉng L∆∞·ª£ng",
        price: 35000,
        description: "TƒÉng 50% Ki trong 1 ng√†y",
        effect: "ki_boost",
        boost: 1.5,
        duration: 86400000,
        emoji: "‚ö°"
    },
    WISDOM: {
        id: "wisdom_amulet",
        name: "B√πa Tr√≠ Tu·ªá",
        price: 45000,
        description: "TƒÉng 100% Exp nh·∫≠n ƒë∆∞·ª£c trong 1 ng√†y",
        effect: "exp_boost",
        boost: 2.0,
        duration: 86400000,
        emoji: "üß†"
    }
};

const DRAGON_WISHES = {
    ZENI: {
        name: "T√∫i ùó≠ùó≤ùóªùó∂ kh·ªïng l·ªì",
        reward: "5,000,000 Zeni",
        effect: (player) => {
            player.stats.zeni += 5000000;
        }
    },
    POWER: {
        name: "ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ v√¥ h·∫°n",
        reward: "200,000,000 s·ª©c m·∫°nh",
        effect: (player) => {
            player.stats.power += 200000000;
        }
    },
    EXP: {
        name: "Kinh nghi·ªám chi·∫øn ƒë·∫•u",
        reward: "1,000,000 EXP",
        effect: (player) => {
            if (player.stats.exp + 1000000 > MAX_EXP_STORAGE) {
                player.stats.exp = MAX_EXP_STORAGE;
            } else {
                player.stats.exp += 1000000;
            }
        }
    }
};
function validatePlayerQuests(player) {
    if (!player.quests) {
        player.quests = {
            active: [],
            completed: [],
            progress: {}
        };
    }

    for (const questId in player.quests.progress) {
        if (!QUESTS[questId]) {
            delete player.quests.progress[questId];
        }
    }

    player.quests.active = player.quests.active.filter(questId => QUESTS[questId]);

    player.quests.completed = player.quests.completed.filter(questId => QUESTS[questId]);

    if (player.quests.active.length === 0) {
        const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
        if (planetQuests && planetQuests.length > player.quests.completed.length) {
            const nextQuestId = planetQuests[player.quests.completed.length];
            if (QUESTS[nextQuestId]) {
                player.quests.active.push(nextQuestId);
                player.quests.progress[nextQuestId] = 0;
            }
        }
    }
}
function hasAllDragonBalls(player, planet) {
    if (!player.inventory || !player.inventory.dragonBalls) return false;

    const planetBalls = player.inventory.dragonBalls.filter(ball => ball.planet === planet);

    if (planetBalls.length === 7) {
        const stars = planetBalls.map(ball => ball.star).sort((a, b) => a - b);
        if (stars.join(",") === "1,2,3,4,5,6,7") return true;
    }

    return false;
}

function removeDragonBalls(player, planet) {
    if (!player.inventory || !player.inventory.dragonBalls) return;

    player.inventory.dragonBalls = player.inventory.dragonBalls.filter(ball => ball.planet !== planet);
}

const SHOP_ITEMS = {
    SENZU: {
        id: "senzu",
        name: "ƒê·∫≠u Th·∫ßn",
        price: 5000,
        description: "H·ªìi ph·ª•c to√†n b·ªô HP KI v√† tƒÉng 5% s·ª©c m·∫°nh",
        type: "consumable",
        emoji: "üå±"
    },
    SCOUTER: {
        id: "scouter",
        name: "Thi·∫øt B·ªã ƒêo S·ª©c M·∫°nh",
        price: 10000,
        description: "TƒÉng 10% Ki khi ƒëeo trong 1 gi·ªù",
        type: "equipment",
        emoji: "üîã",
        duration: 3600000
    },
    DRAGON_RADAR: {
        id: "radar",
        name: "Rada D√≤ Ng·ªçc R·ªìng",
        price: 75000,
        description: "TƒÉng t·ª∑ l·ªá t√¨m th·∫•y Ng·ªçc R·ªìng l√™n 3 l·∫ßn trong 1 gi·ªù",
        type: "equipment",
        emoji: "üì°",
        duration: 3600000
    },
    ARMOR: {
        id: "armor",
        name: "√Åo Gi√°p Saiyan",
        price: 15000,
        description: "TƒÉng 15% HP trong 1 gi·ªù",
        type: "equipment",
        emoji: "üõ°Ô∏è",
        duration: 3600000
    }
};
const QUEST_TYPES = {
    COMBAT: "combat",
    POWER: "power",
    TRAINING: "training",
    COLLECT: "collect",
    MASTER: "master",
    TOURNAMENT: "tournament"
};

const PLANET_THEME_COLORS = {
    EARTH: {
        primary: "#4080FF",
        secondary: "#80C0FF",
        accent: "#0040C0"
    },
    NAMEK: {
        primary: "#40C040",
        secondary: "#80FF80",
        accent: "#008000"
    },
    SAIYAN: {
        primary: "#FF8000",
        secondary: "#FFC080",
        accent: "#C04000"
    }
};
const PLANET_QUEST_PROGRESSION = {
    
    EARTH: [
        "BEGINNER_1",
        "BEGINNER_2",
        "BASIC_TRAINING",
        
        "EARTH_WOLF",
        "EARTH_SAIBAMEN",
        "DRAGON_BALL_1",
        
        "POWER_LV1",
        "EARTH_RED_RIBBON",
        
        "EARTH_TAMBOURINE",
        "POWER_LV2",
        "TOURNAMENT_BEGINNER",
        
        "EARTH_ANDROID19",
        "EARTH_ANDROID18",
        "TOURNAMENT_TENKAICHI",
        
        "EARTH_CELL_JR",
        "EARTH_PERFECT_CELL",
        
        "POWER_LV3",
        "EARTH_DABURA",
        "EARTH_BABIDI",
        "TOURNAMENT_CELL",
        
        "EARTH_SUPER_BUU",
        "EARTH_KID_BUU",
        "TOURNAMENT_UNIVERSE",
        
        "EARTH_COLLECT_ULTIMATE",
        "DRAGON_BALL_ALL"
    ],
    NAMEK: [
        // Kh·ªüi ƒë·ªông
        "BEGINNER_1",
        "BEGINNER_2",
        "BASIC_TRAINING",
        
        // Kh√°m ph√° Namek
        "NAMEK_VILLAGER",
        "NAMEK_APPULE",
        "NAMEK_SOLDIER",
        "DRAGON_BALL_1",
        
        // TƒÉng c∆∞·ªùng l·ª±c l∆∞·ª£ng
        "POWER_LV1",
        "NAMEK_WARRIOR",
        
        // ƒê·ªôi ƒê·∫∑c Nhi·ªám Ginyu
        "NAMEK_GULDO",
        "NAMEK_DODORIA",
        "POWER_LV2",
        "TOURNAMENT_BEGINNER",
        
        // ƒê·ªëi ƒë·∫ßu tinh nhu·ªá Ginyu
        "NAMEK_RECOOME",
        "NAMEK_BURTER_JEICE",
        "NAMEK_ZARBON",
        "TOURNAMENT_TENKAICHI",
        
        // Tr∆∞·ªüng ƒë·ªôi Ginyu
        "NAMEK_GINYU",
        "NAMEK_GINYU_CAPTAIN",
        
        // ƒê·∫°i chi·∫øn Frieza
        "NAMEK_FRIEZA_1",
        "NAMEK_FRIEZA_2",
        "NAMEK_FRIEZA_3",
        "NAMEK_FRIEZA_FINAL",
        
        // H·∫≠u chi·∫øn
        "TOURNAMENT_UNIVERSE",
        "NAMEK_BOSS",
        "DRAGON_BALL_ALL"
    ],
    SAIYAN: [
        // Kh·ªüi nghi·ªáp
        "BEGINNER_1",
        "BEGINNER_2",
        "BASIC_TRAINING",
        
        // X√¢m l∆∞·ª£c Saiyan
        "SAIYAN_RADITZ",
        "SAIYAN_NAPPA",
        "SAIYAN_BOSS",
        "DRAGON_BALL_1",
        
        // Luy·ªán t·∫≠p c·∫•p ƒë·ªô
        "POWER_LV1",
        "SAIYAN_WARRIOR",
        
        // Th√°ch th·ª©c tinh nhu·ªá
        "SAIYAN_ELITE",
        "POWER_LV2",
        "TOURNAMENT_BEGINNER",
        
        // Si√™u Saiyan huy·ªÅn tho·∫°i
        "SAIYAN_TURLES",
        "TOURNAMENT_TENKAICHI",
        
        // ƒê·ªânh cao s·ª©c m·∫°nh
        "TOURNAMENT_UNIVERSE",
        "SAIYAN_BROLY",
        "DRAGON_BALL_ALL"
    ]
};


const SPECIAL_ITEMS = {
    CELL_CORE: {
        id: "cell_core",
        name: "Nh√¢n Cell",
        description: "Nh√¢n t·∫ø b√†o c·ªßa Cell, tƒÉng s·ª©c m·∫°nh khi s·ª≠ d·ª•ng",
        effect: "power_boost",
        boost: 1000000
    },
    BUU_CANDY: {
        id: "buu_candy",
        name: "K·∫πo Buu",
        description: "K·∫πo ma thu·∫≠t c·ªßa Buu, h·ªìi ph·ª•c to√†n b·ªô HP v√† Ki",
        effect: "full_restore"
    },
    BROLY_DISCIPLE: {
        id: "broly_disciple",
        name: "ƒê·ªá T·ª≠ Broly",
        description: "ƒê·ªá t·ª≠ c·ªßa Broly, c√≥ th·ªÉ d√πng ƒë·ªÉ h·ª£p th·ªÉ th√†nh Super Legendary Warrior",
        effect: "fusion",
        power_multiplier: 5.0,
        ki_multiplier: 4.0,
        hp_multiplier: 5.0,
        damage_multiplier: 6.0
    }
};
const QUESTS = {
    EARTH_RED_RIBBON: {
        id: "EARTH_RED_RIBBON",
        name: "Qu√¢n ƒê·ªôi R·ªìng ƒê·ªè",
        description: "ƒê√°nh b·∫°i 10 L√≠nh R·ªìng ƒê·ªè",
        type: QUEST_TYPES.COMBAT,
        target: 10,
        monster: "red_ribbon_soldier",
        reward: {
            exp: 2500,
            zeni: 3000,
            description: "2500 EXP, 3000 Zeni"
        },
            },
    "TOURNAMENT_BEGINNER": {
        id: "TOURNAMENT_BEGINNER",
        name: "Tham Gia Gi·∫£i ƒê·∫•u S∆° C·∫•p",
        description: "ƒê·∫°t top 8 trong Gi·∫£i ƒê·∫•u Thi√™n H·∫°",
        type: "TOURNAMENT",
        target: 1,
        reward: {
            exp: 100000,
            zeni: 50000,
            description: "100,000 EXP, 50,000 Zeni"
        }
    },
    EARTH_ANDROID18: {
        id: "EARTH_ANDROID18",
        name: "C·ªó m√°y s√°t th·ªß",
        description: "ƒê√°nh b·∫°i Android 18",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "android18",
        reward: {
            exp: 10000,
            zeni: 12000,
            item: "crystal",
            quantity: 2,
            description: "10000 EXP, 12000 Zeni, 2 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    EARTH_PERFECT_CELL: {
        id: "EARTH_PERFECT_CELL",
        name: "Kh·ªßng ho·∫£ng Cell",
        description: "ƒê√°nh b·∫°i Perfect Cell",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "perfect_cell",
        reward: {
            exp: 20000,
            zeni: 25000,
            item: "armor",
            quantity: 1,
            description: "20000 EXP, 25000 Zeni, 1 √Åo Gi√°p Saiyan"
        },
        
    },
    EARTH_DABURA: {
        id: "EARTH_DABURA",
        name: "Vua Ma Qu·ª∑",
        description: "ƒê√°nh b·∫°i Dabura, Vua Ma Qu·ª∑",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "dabura",
        reward: {
            exp: 30000,
            zeni: 35000,
            item: "crystal",
            quantity: 3,
            description: "30000 EXP, 35000 Zeni, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    EARTH_BABIDI: {
        id: "EARTH_BABIDI",
        name: "Ph√π Th·ªßy √Åc ƒê·ªôc",
        description: "ƒê√°nh b·∫°i Babidi, ph√π th·ªßy tri·ªáu h·ªìi Majin Buu",
        type: QUEST_TYPES.COMBAT, 
        target: 1,
        monster: "babidi",
        reward: {
            exp: 40000,
            zeni: 45000,
            item: "senzu",
            quantity: 5,
            description: "40000 EXP, 45000 Zeni, 5 ƒê·∫≠u Th·∫ßn"
        },
        
    },
    EARTH_SUPER_BUU: {
        id: "EARTH_SUPER_BUU",
        name: "Ma Buu H·∫Øc √Åm",
        description: "ƒê√°nh b·∫°i Super Buu, k·∫ª h·ªßy di·ªát v≈© tr·ª•",
        type: QUEST_TYPES.COMBAT,
        target: 1, 
        monster: "super_buu",
        reward: {
            exp: 60000,
            zeni: 60000,
            item: "crystal",
            quantity: 5,
            description: "60000 EXP, 60000 Zeni, 5 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    EARTH_KID_BUU: {
        id: "EARTH_KID_BUU",
        name: "Th√°ch Th·ª©c Cu·ªëi C√πng",
        description: "ƒê√°nh b·∫°i Kid Buu, h√¨nh th√°i nguy√™n th·ªßy c·ªßa Ma Buu",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "kid_buu",
        reward: {
            exp: 100000,
            zeni: 100000,
            item: "radar_3",
            quantity: 1,
            description: "100000 EXP, 100000 Zeni, 1 Rada C·∫•p 3"
        },
        
    },
    EARTH_COLLECT_ULTIMATE: {
        id: "EARTH_COLLECT_ULTIMATE",
        name: "V≈© Kh√≠ T·ªëi Th∆∞·ª£ng",
        description: "Thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng",
        type: QUEST_TYPES.COLLECT,
        itemType: "dragonBall7",
        target: 7,
        reward: {
            exp: 120000,
            zeni: 150000,
            item: "crystal",
            quantity: 7,
            description: "120000 EXP, 150000 Zeni, 7 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    "TOURNAMENT_TENKAICHI": {
        id: "TOURNAMENT_TENKAICHI",
        name: "V√¥ ƒê·ªãch Gi·∫£i ƒê·∫•u Thi√™n H·∫°",
        description: "ƒê·∫°t top 4 trong Gi·∫£i ƒê·∫•u Thi√™n H·∫°",
        type: "TOURNAMENT",
        target: 1,
        reward: {
            exp: 200000,
            zeni: 100000,
            description: "200,000 EXP, 100,000 Zeni"
        }
    },
    "TOURNAMENT_CELL": {
        id: "TOURNAMENT_CELL",
        name: "V√¥ ƒê·ªãch Cell Games",
        description: "ƒê·∫°t top 2 trong Cell Games",
        type: "TOURNAMENT",
        target: 1,
        reward: {
            exp: 300000,
            zeni: 150000,
            description: "300,000 EXP, 150,000 Zeni"
        }
    },
    "TOURNAMENT_UNIVERSE": {
        id: "TOURNAMENT_UNIVERSE",
        name: "V√¥ ƒê·ªãch Gi·∫£i ƒê·∫•u V≈© Tr·ª•",
        description: "V√¥ ƒë·ªãch Gi·∫£i ƒê·∫•u V≈© Tr·ª•",
        type: "TOURNAMENT",
        target: 1,
        reward: {
            exp: 500000,
            zeni: 250000,
            description: "500,000 EXP, 250,000 Zeni"
        }
    },
    EARTH_TAMBOURINE: {
        id: "EARTH_TAMBOURINE",
        name: "Thu·ªôc h·∫° c·ªßa Qu·ª∑ V∆∞∆°ng",
        description: "ƒê√°nh b·∫°i Tambourine",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "T√†u b·∫£y b·∫£y",
        reward: {
            exp: 6000,
            zeni: 8000,
            item: "senzu",
            quantity: 3,
            description: "6000 EXP, 8000 Zeni, 3 ƒê·∫≠u Th·∫ßn"
        },
        
    },
    EARTH_ANDROID19: {
        id: "EARTH_ANDROID19",
        name: "C·ªó m√°y h·∫•p th·ª•",
        description: "ƒê√°nh b·∫°i Android 19",
        type: QUEST_TYPES.COMBAT,
        target: 1, 
        monster: "android19",
        reward: {
            exp: 9000,
            zeni: 15000,
            item: "crystal",
            quantity: 2,
            description: "9000 EXP, 15000 Zeni, 2 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    EARTH_CELL_JR: {
        id: "EARTH_CELL_JR",
        name: "Con c√°i ho√†n h·∫£o",
        description: "ƒê√°nh b·∫°i 5 Cell Jr.",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "cell_jr",
        reward: {
            exp: 12000,
            zeni: 20000,
            item: "armor",
            quantity: 1,
            description: "12000 EXP, 20000 Zeni, 1 √Åo Gi√°p Saiyan"
        },
        
    },
    NAMEK_VILLAGER: {
        id: "NAMEK_VILLAGER",
        name: "Gi·∫£i c·ª©u l√†ng Namek",
        description: "C·ª©u 5 d√¢n l√†ng Namek kh·ªèi qu√¢n ƒë·ªôi Frieza",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "namek_villager",
        reward: {
            exp: 1000,
            zeni: 2000,
            description: "1000 EXP, 2000 Zeni"
        },
    },
    NAMEK_GULDO: {
        id: "NAMEK_GULDO",
        name: "ƒê·ªëi ƒë·∫ßu v·ªõi Guldo",
        description: "ƒê√°nh b·∫°i Guldo, th√†nh vi√™n ƒê·ªôi ƒê·∫∑c Nhi·ªám Ginyu",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "guldo",
        reward: {
            exp: 3000,
            zeni: 4000,
            item: "crystal",
            quantity: 1,
            description: "3000 EXP, 4000 Zeni, 1 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
    },
    NAMEK_RECOOME: {
        id: "NAMEK_RECOOME",
        name: "S·ª©c m·∫°nh c·ªßa Recoome",
        description: "ƒê√°nh b·∫°i Recoome, th√†nh vi√™n ƒê·ªôi ƒê·∫∑c Nhi·ªám Ginyu",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "recoome",
        reward: {
            exp: 4000,
            zeni: 5000,
            item: "senzu",
            quantity: 2,
            description: "4000 EXP, 5000 Zeni, 2 ƒê·∫≠u Th·∫ßn"
        },
    },
    NAMEK_BURTER_JEICE: {
        id: "NAMEK_BURTER_JEICE",
        name: "B·ªô ƒë√¥i t·ªëc ƒë·ªô",
        description: "ƒê√°nh b·∫°i Burter v√† Jeice, th√†nh vi√™n ƒê·ªôi ƒê·∫∑c Nhi·ªám Ginyu",
        type: QUEST_TYPES.COMBAT,
        target: 2,
        monster: "burter",
        reward: {
            exp: 5000,
            zeni: 6000,
            item: "scouter",
            quantity: 1,
            description: "5000 EXP, 6000 Zeni, 1 Thi·∫øt b·ªã ƒëo s·ª©c m·∫°nh"
        },
    },
    NAMEK_GINYU_CAPTAIN: {
        id: "NAMEK_GINYU_CAPTAIN",
        name: "Th·ªß lƒ©nh Ginyu",
        description: "ƒê√°nh b·∫°i Captain Ginyu, tr∆∞·ªüng ƒë·ªôi ƒê·∫∑c Nhi·ªám Ginyu",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "captain_ginyu",
        reward: {
            exp: 7000,
            zeni: 8000,
            item: "crystal",
            quantity: 2,
            description: "7000 EXP, 8000 Zeni, 2 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
    },
    NAMEK_FRIEZA_1: {
        id: "NAMEK_FRIEZA_1",
        name: "ƒê·ªëi ƒë·∫ßu Frieza D·∫°ng 1",
        description: "Chi·∫øn ƒë·∫•u v·ªõi Frieza trong d·∫°ng ƒë·∫ßu ti√™n c·ªßa h·∫Øn",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "frieza_1",
        reward: {
            exp: 8000,
            zeni: 10000,
            item: "armor",
            quantity: 1,
            description: "8000 EXP, 10000 Zeni, 1 √Åo Gi√°p Saiyan"
        },
    },
    NAMEK_FRIEZA_2: {
        id: "NAMEK_FRIEZA_2",
        name: "Frieza bi·∫øn h√¨nh",
        description: "ƒê·ªëi m·∫∑t v·ªõi Frieza trong d·∫°ng th·ª© hai",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "frieza_2",
        reward: {
            exp: 10000,
            zeni: 15000,
            item: "crystal",
            quantity: 2,
            description: "10000 EXP, 15000 Zeni, 2 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
    },
    NAMEK_FRIEZA_3: {
        id: "NAMEK_FRIEZA_3",
        name: "N·ªói √°c m·ªông d·∫°ng ba",
        description: "Chi·∫øn ƒë·∫•u v·ªõi Frieza trong d·∫°ng th·ª© ba",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "frieza_3",
        reward: {
            exp: 15000,
            zeni: 20000,
            item: "senzu",
            quantity: 3,
            description: "15000 EXP, 20000 Zeni, 3 ƒê·∫≠u Th·∫ßn"
        },
    },
    NAMEK_FRIEZA_FINAL: {
        id: "NAMEK_FRIEZA_FINAL",
        name: "Tr·∫≠n chi·∫øn cu·ªëi c√πng",
        description: "ƒê·ªëi ƒë·∫ßu v·ªõi Frieza trong d·∫°ng cu·ªëi c√πng c·ªßa h·∫Øn",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "frieza_final",
        reward: {
            exp: 25000,
            zeni: 30000,
            item: "radar",
            quantity: 1,
            description: "25000 EXP, 30000 Zeni, 1 Rada D√≤ Ng·ªçc R·ªìng"
        },
    },
    NAMEK_WARRIOR: {
        id: "NAMEK_WARRIOR",
        name: "Chi·∫øn binh xanh l√°",
        description: "ƒê√°nh b·∫°i 8 Chi·∫øn Binh Namek",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "namekian_warrior",
        reward: {
            exp: 2000,
            zeni: 3500,
            description: "2000 EXP, 3500 Zeni"
        },
            },
    NAMEK_DODORIA: {
        id: "NAMEK_DODORIA",
        name: "K·∫ª h·∫ßu c·∫≠n h·ªìng",
        description: "ƒê√°nh b·∫°i 5 Dodoria",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "dodoria",
        reward: {
            exp: 6500,
            zeni: 9000,
            item: "senzu",
            quantity: 3,
            description: "6500 EXP, 9000 Zeni, 3 ƒê·∫≠u Th·∫ßn"
        },
        
    },
    NAMEK_ZARBON: {
        id: "NAMEK_ZARBON",
        name: "Th√¢n t√≠n c·ªßa Frieza",
        description: "ƒê√°nh b·∫°i 4 Zarbon",
        type: QUEST_TYPES.COMBAT,
        target: 4,
        monster: "zarbon",
        reward: {
            exp: 8000,
            zeni: 12000,
            item: "crystal",
            quantity: 2,
            description: "8000 EXP, 12000 Zeni, 2 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    NAMEK_GINYU: {
        id: "NAMEK_GINYU",
        name: "ƒê·ªôi ƒë·∫∑c nhi·ªám tinh nhu·ªá",
        description: "ƒê√°nh b·∫°i 3 th√†nh vi√™n ƒê·ªôi Ginyu",
        type: QUEST_TYPES.COMBAT,
        target: 3,
        monster: "ginyu_force",
        reward: {
            exp: 10000,
            zeni: 18000,
            item: "scouter",
            quantity: 1,
            description: "10000 EXP, 18000 Zeni, 1 Thi·∫øt b·ªã ƒëo s·ª©c m·∫°nh"
        },
        
    },

    SAIYAN_WARRIOR: {
        id: "SAIYAN_WARRIOR",
        name: "Chi·∫øn binh t·∫ßng l·ªõp th·∫•p",
        description: "ƒê√°nh b·∫°i 10 Chi·∫øn Binh Saiyan",
        type: QUEST_TYPES.COMBAT,
        target: 10,
        monster: "saiyan_warrior",
        reward: {
            exp: 3000,
            zeni: 4000,
            description: "3000 EXP, 4000 Zeni"
        },
            },
    SAIYAN_ELITE: {
        id: "SAIYAN_ELITE",
        name: "Tinh hoa c·ªßa t·ªôc Saiyan",
        description: "ƒê√°nh b·∫°i 7 Saiyan Tinh Nhu·ªá",
        type: QUEST_TYPES.COMBAT,
        target: 7,
        monster: "saiyan_elite",
        reward: {
            exp: 7000,
            zeni: 10000,
            item: "senzu",
            quantity: 4,
            description: "7000 EXP, 10000 Zeni, 4 ƒê·∫≠u Th·∫ßn"
        },
        
    },
    SAIYAN_TURLES: {
        id: "SAIYAN_TURLES",
        name: "K·∫ª ƒÉn tr·ªôm sinh m·ªánh",
        description: "ƒê√°nh b·∫°i 3 Turles",
        type: QUEST_TYPES.COMBAT,
        target: 3,
        monster: "turles",
        reward: {
            exp: 10000,
            zeni: 15000,
            item: "crystal",
            quantity: 3,
            description: "10000 EXP, 15000 Zeni, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },
    SAIYAN_BROLY: {
        id: "SAIYAN_BROLY",
        name: "Si√™u Saiyan huy·ªÅn tho·∫°i",
        description: "ƒê√°nh b·∫°i 2 Broly",
        type: QUEST_TYPES.COMBAT,
        target: 2,
        monster: "broly",
        reward: {
            exp: 15000,
            zeni: 25000,
            item: "armor",
            quantity: 2,
            description: "15000 EXP, 25000 Zeni, 2 √Åo Gi√°p Saiyan"
        },
        
    },
    BEGINNER_1: {
        id: "BEGINNER_1",
        name: "B·∫Øt ƒë·∫ßu h√†nh tr√¨nh",
        description: "Luy·ªán t·∫≠p 3 l·∫ßn ƒë·ªÉ l√†m quen v·ªõi s·ª©c m·∫°nh",
        type: QUEST_TYPES.TRAINING,
        target: 3,
        reward: {
            exp: 500,
            zeni: 1000,
            description: "500 EXP, 1000 Zeni"
        },
            },
    BEGINNER_2: {
        id: "BEGINNER_2",
        name: "T√¨m ki·∫øm s·ª©c m·∫°nh",
        description: "ƒê·∫°t 2,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 2000,
        reward: {
            exp: 1000,
            zeni: 2000,
            description: "1000 EXP, 2000 Zeni"
        },
            },


    EARTH_WOLF: {
        id: "EARTH_WOLF",
        name: "Nh·ªØng k·∫ª sƒÉn m·ªìi",
        description: "ƒê√°nh b·∫°i 5 con s√≥i hoang",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "wolf",
        reward: {
            exp: 1000,
            zeni: 2000,
            description: "1000 EXP, 2000 Zeni"
        },
            },
    EARTH_SAIBAMEN: {
        id: "EARTH_SAIBAMEN",
        name: "ƒê√°nh b·∫°i Saibamen",
        description: "ƒê√°nh b·∫°i 8 Saibamen",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "saibamen",
        reward: {
            exp: 3000,
            zeni: 4000,
            description: "3000 EXP, 4000 Zeni"
        },
            },

    NAMEK_APPULE: {
        id: "NAMEK_APPULE",
        name: "S√°t th·ªß c·ªßa Freeza",
        description: "ƒê√°nh b·∫°i 5 Appule",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "appule",
        reward: {
            exp: 1500,
            zeni: 2500,
            description: "1500 EXP, 2500 Zeni"
        },
            },
    NAMEK_SOLDIER: {
        id: "NAMEK_SOLDIER",
        name: "Qu√¢n ƒë·ªôi c·ªßa Freeza",
        description: "ƒê√°nh b·∫°i 8 binh l√≠nh Freeza",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "freeza_soldier",
        reward: {
            exp: 3500,
            zeni: 5000,
            description: "3500 EXP, 5000 Zeni"
        },
            },
    NAMEK_BOSS: {
        id: "NAMEK_BOSS",
        name: "ƒê·ªëi ƒë·∫ßu v·ªõi Cui",
        description: "ƒê√°nh b·∫°i Cui",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "cui",
        reward: {
            exp: 12000,
            zeni: 25000,
            item: "scouter",
            quantity: 1,
            description: "12000 EXP, 25000 Zeni, 1 Thi·∫øt b·ªã ƒëo s·ª©c m·∫°nh"
        },
        
    },

    SAIYAN_RADITZ: {
        id: "SAIYAN_RADITZ",
        name: "Anh trai Kakarot",
        description: "ƒê√°nh b·∫°i 5 Raditz",
        type: QUEST_TYPES.COMBAT,
        target: 5,
        monster: "raditz",
        reward: {
            exp: 2000,
            zeni: 3000,
            description: "2000 EXP, 3000 Zeni"
        },
            },
    SAIYAN_NAPPA: {
        id: "SAIYAN_NAPPA",
        name: "T∆∞·ªõng qu√¢n Saiyan",
        description: "ƒê√°nh b·∫°i 8 Nappa",
        type: QUEST_TYPES.COMBAT,
        target: 8,
        monster: "nappa",
        reward: {
            exp: 4000,
            zeni: 6000,
            description: "4000 EXP, 6000 Zeni"
        },
            },
    SAIYAN_BOSS: {
        id: "SAIYAN_BOSS",
        name: "Th√°ch ƒë·∫•u Vegeta",
        description: "ƒê√°nh b·∫°i Ho√†ng t·ª≠ Vegeta",
        type: QUEST_TYPES.COMBAT,
        target: 1,
        monster: "vegeta",
        reward: {
            exp: 15000,
            zeni: 30000,
            item: "crystal",
            quantity: 3,
            description: "15000 EXP, 30000 Zeni, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    },

    BASIC_TRAINING: {
        id: "BASIC_TRAINING",
        name: "Kh·ªüi ƒë·∫ßu h√†nh tr√¨nh",
        description: "Luy·ªán t·∫≠p 5 l·∫ßn ƒë·ªÉ l√†m quen v·ªõi s·ª©c m·∫°nh",
        type: QUEST_TYPES.TRAINING,
        target: 5,
        reward: {
            exp: 1000,
            zeni: 1000,
            description: "1,000 EXP, 1,000 Zeni"
        },
            },

    DRAGON_BALL_1: {
        id: "DRAGON_BALL_1",
        name: "Ng·ªçc R·ªìng huy·ªÅn tho·∫°i",
        description: "Thu th·∫≠p 3 vi√™n Ng·ªçc R·ªìng b·∫•t k·ª≥",
        type: QUEST_TYPES.COLLECT,
        itemType: "dragonBall",
        target: 3,
        reward: {
            exp: 5000,
            zeni: 10000,
            description: "5000 EXP, 10000 Zeni"
        },
            },

    POWER_LV1: {
        id: "POWER_LV1",
        name: "ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ th·∫≠t s·ª±",
        description: "ƒê·∫°t 10,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 10000,
        reward: {
            exp: 8000,
            zeni: 15000,
            description: "8000 EXP, 15000 Zeni"
        },
            },
    POWER_LV2: {
        id: "POWER_LV2",
        name: "Si√™u Chi·∫øn Binh",
        description: "ƒê·∫°t 50,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 50000,
        reward: {
            exp: 20000,
            zeni: 30000,
            description: "20000 EXP, 30000 Zeni"
        },
        
    },
    POWER_LV3: {
        id: "POWER_LV3",
        name: "S·ª©c m·∫°nh th·∫ßn th√°nh",
        description: "ƒê·∫°t 500,000 s·ª©c m·∫°nh",
        type: QUEST_TYPES.POWER,
        target: 500000,
        reward: {
            exp: 200000,
            zeni: 200000,
            description: "200,000 EXP, 200,000 Zeni",
            item: "crystal",
            quantity: 3
        }
    },
    DRAGON_BALL_ALL: {
        id: "DRAGON_BALL_ALL",
        name: "Tri·ªáu h·ªìi R·ªìng Th·∫ßn",
        description: "Thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ m·ªôt h√†nh tinh",
        type: QUEST_TYPES.COLLECT,
        itemType: "dragonBall7",
        target: 7,
        reward: {
            exp: 50000,
            item: "crystal",
            quantity: 3,
            description: "50000 EXP, 3 Tinh Th·ªÉ S·ª©c M·∫°nh"
        },
        
    }
};
const TRAINING_LOCATIONS = {
    DEFAULT: {
        name: "H√†nh tinh",
        description: "ƒê·ªãa ƒëi·ªÉm luy·ªán t·∫≠p c∆° b·∫£n",
        minPower: 0,
        maxPower: 100000,
        multiplier: 1.0,
        color: "#4080FF"
    },
    KORIN: {
        name: "Th√°p Karin",
        description: "N∆°i luy·ªán t·∫≠p v·ªõi tr·ªçng l·ª±c cao h∆°n",
        minPower: 100000,
        maxPower: 500000,
        multiplier: 3.0,
        color: "#40C040"
    },
    KAMI: {
        name: "Th√°p Th∆∞·ª£ng ƒê·∫ø",
        description: "Ph√≤ng t·∫≠p c·ªßa th∆∞·ª£ng ƒë·∫ø",
        minPower: 500000,
        maxPower: 5000000,
        multiplier: 7.0,
        color: "#FFC107"
    },
    UNIVERSE_GOD: {
        name: "Th·∫ßn V≈© Tr·ª•",
        description: "Luy·ªán t·∫≠p d∆∞·ªõi s·ª± ch·ªâ d·∫°y c·ªßa c√°c v·ªã th·∫ßn",
        minPower: 5000000,
        maxPower: 50000000,
        multiplier: 10.0,
        color: "#9C27B0"
    },
    KAIOSHIN: {
        name: "Gi·ªõi Kaioshin",
        description: "Th·∫ø gi·ªõi c·ªßa ƒê·∫°i Kaioshin",
        minPower: 50000000,
        maxPower: 50000000000,
        multiplier: 12.0,
        color: "#FF5252"
    },
    DESTROYER: {
        name: "Th·∫ßn H·ªßy Di·ªát",
        description: "Luy·ªán t·∫≠p c√πng Th·∫ßn H·ªßy Di·ªát",
        minPower: 50000000000,
        maxPower: Infinity,
        multiplier: 15.0,
        color: "#7C4DFF"
    }
};

const EVOLUTION_SYSTEM = {
    EARTH: {
        forms: [

            {
                name: "Con ng∆∞·ªùi",
                powerRequired: 0,
                description: "Con ng∆∞·ªùi b√¨nh th∆∞·ªùng v·ªõi ti·ªÅm nƒÉng ch∆∞a khai ph√°",
                powerBonus: 1.0,
                kiBonus: 1.0,
                healthBonus: 1.0,
                damageBonus: 1.0
            },
            {
                name: "Chi·∫øn Binh Z",
                powerRequired: 100000,
                description: "Chi·∫øn binh ƒë∆∞·ª£c r√®n luy·ªán theo phong c√°ch Tr√°i ƒê·∫•t",
                powerBonus: 1.3,
                kiBonus: 1.5,
                healthBonus: 1.2,
                damageBonus: 1.3
            },
            {
                name: "B·∫≠c Th·∫ßy Kh√≠",
                powerRequired: 1000000,
                description: "ƒê·∫°t ƒë·∫øn tr√¨nh ƒë·ªô ki·ªÉm so√°t kh√≠ ho√†n h·∫£o",
                powerBonus: 1.6,
                kiBonus: 2.2,
                healthBonus: 1.5,
                damageBonus: 1.8
            },

            {
                name: "Si√™u Chi·∫øn Binh",
                powerRequired: 10000000,
                description: "ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ v∆∞·ª£t gi·ªõi h·∫°n con ng∆∞·ªùi",
                powerBonus: 2.2,
                kiBonus: 2.5,
                healthBonus: 2.0,
                damageBonus: 2.5
            },
            {
                name: "Ti·ªÅm NƒÉng Khai Ph√°",
                powerRequired: 50000000,
                description: "Khai ph√° ho√†n to√†n ti·ªÅm nƒÉng con ng∆∞·ªùi",
                powerBonus: 3.0,
                kiBonus: 3.5,
                healthBonus: 2.8,
                damageBonus: 3.5
            },
            {
                name: "Ch√≠ T√¥n Tr√°i ƒê·∫•t",
                powerRequired: 100000000,
                description: "ƒê·∫°t ƒë·∫øn gi·ªõi h·∫°n t·ªëi th∆∞·ª£ng c·ªßa con ng∆∞·ªùi",
                powerBonus: 4.0,
                kiBonus: 4.5,
                healthBonus: 3.5,
                damageBonus: 5.0
            },

            {
                name: "Th·∫ßn Khi Tr√°i ƒê·∫•t",
                powerRequired: 500000000,
                description: "Bi·∫øn ƒë·ªïi kh√≠ th√†nh nƒÉng l∆∞·ª£ng th·∫ßn th√°nh",
                powerBonus: 6.0,
                kiBonus: 6.0,
                healthBonus: 5.0,
                damageBonus: 7.0
            },
            {
                name: "T·ª© Ph√¢n Th·∫ßn C√¥ng",
                powerRequired: 10000000000,
                description: "K·ªπ thu·∫≠t t·ªëi th∆∞·ª£ng c·ªßa c√°c b·∫≠c th·∫ßy Tr√°i ƒê·∫•t",
                powerBonus: 8.0,
                kiBonus: 7.5,
                healthBonus: 6.0,
                damageBonus: 9.0
            }
        ]
    },
    NAMEK: {
        forms: [

            {
                name: "Namek th∆∞·ªùng",
                powerRequired: 0,
                description: "Chi·∫øn binh Namek b√¨nh th∆∞·ªùng",
                powerBonus: 1.0,
                kiBonus: 1.0,
                healthBonus: 1.0,
                damageBonus: 1.0
            },

            {
                name: "Namek Warrior",
                powerRequired: 100000,
                description: "Chi·∫øn binh Namek ∆∞u t√∫",
                powerBonus: 1.2,
                kiBonus: 1.3,
                healthBonus: 1.2,
                damageBonus: 1.2
            },

            {
                name: "Super Namek",
                powerRequired: 1000000,
                description: "Namek si√™u c·∫•p v·ªõi s·ª©c m·∫°nh phi th∆∞·ªùng",
                powerBonus: 1.8,
                kiBonus: 2.2,
                healthBonus: 1.8,
                damageBonus: 2.0
            },

            {
                name: "Namek Fusion",
                powerRequired: 10000000,
                description: "Namek h·ª£p th·ªÉ v·ªõi s·ª©c m·∫°nh c·ªßa nhi·ªÅu Namek",
                powerBonus: 2.5,
                kiBonus: 2.8,
                healthBonus: 2.5,
                damageBonus: 2.8
            },

            {
                name: "Namek Dragon",
                powerRequired: 50000000,
                description: "Th·ª©c t·ªânh huy·∫øt th·ªëng R·ªìng Th·∫ßn trong c∆° th·ªÉ",
                powerBonus: 3.5,
                kiBonus: 4.0,
                healthBonus: 3.5,
                damageBonus: 4.0
            },
            {
                name: "Red-Eyed Namek",
                powerRequired: 500000000,
                description: "NƒÉng l∆∞·ª£ng c∆° th·ªÉ chuy·ªÉn ƒë·ªïi ho√†n to√†n, m·∫Øt ƒë·ªè ng·∫ßu",
                powerBonus: 5.0,
                kiBonus: 5.5,
                healthBonus: 4.5,
                damageBonus: 6.0
            },
            {
                name: "Dragon Clan Master",
                powerRequired: 5000000000,
                description: "Ch∆∞·ªüng m√¥n t·ªôc R·ªìng, ƒëi·ªÅu khi·ªÉn ph√©p thu·∫≠t c·ªï ƒë·∫°i",
                powerBonus: 7.0,
                kiBonus: 7.0,
                healthBonus: 6.0,
                damageBonus: 8.0
            },
            {
                name: "Porunga Vessel",
                powerRequired: 50000000000,
                description: "H·ª£p th·ªÉ v·ªõi Porunga, ƒë·∫°t s·ª©c m·∫°nh t·ªëi th∆∞·ª£ng",
                powerBonus: 8.5,
                kiBonus: 8.0,
                healthBonus: 7.0,
                damageBonus: 9.5
            }
        ]
    },
    SAIYAN: {
        forms: [

            {
                name: "Saiyan th∆∞·ªùng",
                powerRequired: 0,
                description: "Chi·∫øn binh Saiyan b√¨nh th∆∞·ªùng",
                powerBonus: 1.0,
                kiBonus: 1.0,
                healthBonus: 1.0,
                damageBonus: 1.0
            },
            {
                name: "Super Saiyan",
                powerRequired: 1000000,
                description: "Truy·ªÅn thuy·∫øt c·ªßa t·ªôc Saiyan",
                powerBonus: 1.5,
                kiBonus: 1.4,
                healthBonus: 1.3,
                damageBonus: 1.7
            },
            {
                name: "Super Saiyan 2",
                powerRequired: 10000000,
                description: "Si√™u Saiyan c·∫•p 2 v·ªõi s·ª©c m·∫°nh kinh ho√†ng",
                powerBonus: 2.0,
                kiBonus: 1.8,
                healthBonus: 1.6,
                damageBonus: 2.2
            },
            {
                name: "Super Saiyan 3",
                powerRequired: 50000000,
                description: "Si√™u Saiyan c·∫•p 3 v·ªõi s·ª©c m·∫°nh h·ªßy di·ªát",
                powerBonus: 3.0,
                kiBonus: 2.5,
                healthBonus: 2.0,
                damageBonus: 3.0
            },
            {
                name: "Super Saiyan God",
                powerRequired: 100000000,
                description: "ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ th·∫ßn th√°nh c·ªßa c√°c v·ªã th·∫ßn",
                powerBonus: 5.0,
                kiBonus: 4.0,
                healthBonus: 3.0,
                damageBonus: 5.0
            },
            {
                name: "Super Saiyan Blue",
                powerRequired: 1500000000,
                description: "K·∫øt h·ª£p s·ª©c m·∫°nh th·∫ßn th√°nh v·ªõi si√™u saiyan",
                powerBonus: 7.0,
                kiBonus: 5.0,
                healthBonus: 4.0,
                damageBonus: 7.0
            },
            {
                name: "Ultra Instinct",
                powerRequired: 100000000000,
                description: "B·∫£n nƒÉng v√¥ c·ª±c - s·ª©c m·∫°nh c·ªßa c√°c thi√™n s·ª©",
                powerBonus: 10.0,
                kiBonus: 8.0,
                healthBonus: 6.0,
                damageBonus: 10.0
            }
        ]
    }
};

const MONSTERS = {
    saibamen: {
        name: "Saibamen",
        hp: 500,
        power: 300,
        exp: 100,
        zeni: 50,
        dropChance: 0.05,
        dropItem: "senzu",
        planet: "EARTH"
    },
    freeza_soldier: {
        name: "Binh l√≠nh Freeza",
        hp: 1000,
        power: 800,
        exp: 250,
        zeni: 120,
        dropChance: 0.08,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    wolf: {
        name: "S√≥i hoang",
        hp: 300,
        power: 200,
        exp: 80,
        zeni: 40,
        dropChance: 0.03,
        dropItem: null,
        planet: "EARTH"
    },

    vegeta: {
        name: "Vegeta",
        hp: 20000,
        power: 15000,
        exp: 3000,
        zeni: 2000,
        dropChance: 0.25,
        dropItem: "crystal",
        planet: "SAIYAN"
    },
    android18: {
        name: "Android 18",
        hp: 80000,
        power: 75000,
        exp: 1800,
        zeni: 1500,
        dropChance: 0.20,
        dropItem: "crystal",
        planet: "EARTH"
    },
    perfect_cell: {
        name: "Perfect Cell",
        hp: 150000,
        power: 120000,
        exp: 5000,
        zeni: 3000,
        dropChance: 0.25,
        dropItem: "crystal",
        planet: "EARTH"
    },
    dabura: {
        name: "Dabura",
        hp: 180000,
        power: 160000,
        exp: 8000,
        zeni: 5000,
        dropChance: 0.22,
        dropItem: "armor",
        planet: "EARTH"
    },
    babidi: {
        name: "Babidi",
        hp: 50000,
        power: 200000,
        exp: 10000,
        zeni: 8000,
        dropChance: 0.30,
        dropItem: "crystal",
        planet: "EARTH"
    },
    super_buu: {
        name: "Super Buu",
        hp: 300000,
        power: 250000,
        exp: 15000,
        zeni: 12000,
        dropChance: 0.35,
        dropItem: "senzu",
        planet: "EARTH"
    },
    kid_buu: {
        name: "Kid Buu",
        hp: 500000,
        power: 400000,
        exp: 30000,
        zeni: 20000,
        dropChance: 0.40,
        dropItem: "crystal",
        planet: "EARTH"
    },
    red_ribbon_soldier: {
        name: "L√≠nh R·ªìng ƒê·ªè",
        hp: 600,
        power: 500,
        exp: 150,
        zeni: 70,
        dropChance: 0.06,
        dropItem: "senzu",
        planet: "EARTH"
    },
    tambourine: {
        name: "T√†u b·∫£y b·∫£y",
        hp: 10000,
        power: 10000,
        exp: 800,
        zeni: 350,
        dropChance: 0.12,
        dropItem: "crystal",
        planet: "EARTH"
    },
    android19: {
        name: "Android 19",
        hp: 100000,
        power: 100000,
        exp: 1500,
        zeni: 800,
        dropChance: 0.18,
        dropItem: "armor",
        planet: "EARTH"
    },
    cell_jr: {
        name: "Cell Jr.",
        hp: 12000,
        power: 10000,
        exp: 2000,
        zeni: 1000,
        dropChance: 0.20,
        dropItem: "crystal",
        planet: "EARTH"
    },


    namekian_warrior: {
        name: "Chi·∫øn Binh Namek",
        hp: 800,
        power: 600,
        exp: 180,
        zeni: 90,
        dropChance: 0.05,
        dropItem: null,
        planet: "NAMEK"
    },
    dodoria: {
        name: "Dodoria",
        hp: 4000,
        power: 3500,
        exp: 1000,
        zeni: 500,
        dropChance: 0.15,
        dropItem: "armor",
        planet: "NAMEK"
    },
    zarbon: {
        name: "Zarbon",
        hp: 5000,
        power: 4500,
        exp: 1200,
        zeni: 600,
        dropChance: 0.15,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    ginyu_force: {
        name: "Th√†nh vi√™n ƒê·ªôi Ginyu",
        hp: 10000,
        power: 8000,
        exp: 1800,
        zeni: 900,
        dropChance: 0.20,
        dropItem: "radar",
        planet: "NAMEK"
    },
    appule: {
        name: "Appule",
        hp: 1500,
        power: 1000,
        exp: 300,
        zeni: 200,
        dropChance: 0.07,
        dropItem: "senzu",
        planet: "NAMEK"
    },
    namek_villager: {
        name: "D√¢n l√†ng Namek",
        hp: 500,
        power: 400,
        exp: 100,
        zeni: 50,
        dropChance: 0.05,
        dropItem: "senzu",
        planet: "NAMEK" 
    },
    guldo: {
        name: "Guldo",
        hp: 8000,
        power: 7000, 
        exp: 1500,
        zeni: 800,
        dropChance: 0.15,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    recoome: {
        name: "Recoome",
        hp: 12000,
        power: 10000,
        exp: 2000,
        zeni: 1000,
        dropChance: 0.18,
        dropItem: "armor",
        planet: "NAMEK"
    },
    burter: {
        name: "Burter",
        hp: 13000,
        power: 11000,
        exp: 2200,
        zeni: 1100,
        dropChance: 0.18,
        dropItem: "scouter",
        planet: "NAMEK"
    },
    jeice: {
        name: "Jeice",
        hp: 13000,
        power: 11000,
        exp: 2200,
        zeni: 1100,
        dropChance: 0.18,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    captain_ginyu: {
        name: "Captain Ginyu",
        hp: 18000,
        power: 15000,
        exp: 3000,
        zeni: 1500,
        dropChance: 0.25,
        dropItem: "radar",
        planet: "NAMEK"
    },
    frieza_1: {
        name: "Frieza D·∫°ng 1",
        hp: 25000,
        power: 20000,
        exp: 4000,
        zeni: 2500,
        dropChance: 0.30,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    frieza_2: {
        name: "Frieza D·∫°ng 2",
        hp: 40000,
        power: 35000,
        exp: 6000,
        zeni: 4000,
        dropChance: 0.32,
        dropItem: "armor",
        planet: "NAMEK"
    },
    frieza_3: {
        name: "Frieza D·∫°ng 3",
        hp: 60000,
        power: 50000,
        exp: 8000,
        zeni: 6000,
        dropChance: 0.35,
        dropItem: "crystal",
        planet: "NAMEK"
    },
    frieza_final: {
        name: "Frieza D·∫°ng Cu·ªëi",
        hp: 100000,
        power: 85000,
        exp: 15000,
        zeni: 10000,
        dropChance: 0.40,
        dropItem: "radar",
        planet: "NAMEK"
    },
    saiyan_warrior: {
        name: "Chi·∫øn Binh Saiyan",
        hp: 1000,
        power: 900,
        exp: 250,
        zeni: 150,
        dropChance: 0.08,
        dropItem: "senzu",
        planet: "SAIYAN"
    },
    saiyan_elite: {
        name: "Saiyan Tinh Nhu·ªá",
        hp: 5000,
        power: 4800,
        exp: 1200,
        zeni: 650,
        dropChance: 0.18,
        dropItem: "armor",
        planet: "SAIYAN"
    },
    turles: {
        name: "Turles",
        hp: 15000,
        power: 13000,
        exp: 2500,
        zeni: 1200,
        dropChance: 0.22,
        dropItem: "crystal",
        planet: "SAIYAN"
    },
    broly: {
        name: "Broly",
        hp: 25000,
        power: 20000,
        exp: 3500,
        zeni: 2000,
        dropChance: 0.25,
        dropItem: "radar",
        planet: "SAIYAN"
    },
    nappa: {
        name: "Nappa",
        hp: 3000,
        power: 3000,
        exp: 1000,
        zeni: 500,
        dropChance: 0.15,
        dropItem: "crystal",
        planet: "SAIYAN"
    },
    raditz: {
        name: "Raditz",
        hp: 2000,
        power: 1800,
        exp: 800,
        zeni: 400,
        dropChance: 0.10,
        dropItem: "senzu",
        planet: "SAIYAN"
    },
    appule: {
        name: "Appule",
        hp: 1500,
        power: 1000,
        exp: 300,
        zeni: 200,
        dropChance: 0.07,
        dropItem: "senzu",
        planet: "NAMEK"
    }
};

const PLANETS = {
    EARTH: {
        name: "Tr√°i ƒê·∫•t",
        powerBonus: 1.0,
        description: "H√†nh tinh c·ªßa c√°c chi·∫øn binh Z",
        masters: ["KAME"]
    },
    NAMEK: {
        name: "Namek",
        powerBonus: 1.2,
        description: "H√†nh tinh c·ªßa t·ªôc Namek",
        masters: ["PICCOLO"]
    },
    SAIYAN: {
        name: "Saiyan",
        powerBonus: 1.5,
        description: "H√†nh tinh c·ªßa t·ªôc Saiyan",
        masters: ["GOKU"]
    }
};
const DRAGON_BALL_INFO = {
    FIND_CHANCE: 0.05,
    RADAR_BOOST: 3.0,
    DESCRIPTIONS: {
        1: "Ng·ªçc R·ªìng 1 sao",
        2: "Ng·ªçc R·ªìng 2 sao",
        3: "Ng·ªçc R·ªìng 3 sao",
        4: "Ng·ªçc R·ªìng 4 sao",
        5: "Ng·ªçc R·ªìng 5 sao",
        6: "Ng·ªçc R·ªìng 6 sao",
        7: "Ng·ªçc R·ªìng 7 sao"
    }
};
const DRAGON_BALLS = {
    EARTH: { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null },
    NAMEK: { 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null }
};

const MASTERS = {
    KAME: {
        name: "L√£o r√πa Kame",
        race: "Human",
        description: "B·∫≠c th·∫ßy v√µ thu·∫≠t Tr√°i ƒê·∫•t",
        skills: {
            DRAGON_PUNCH: {
                name: "ƒê·∫•m Dragon",
                powerScale: 1.2,
                kiCost: 0.2,
                powerRequired: 0,
                description: "ƒê·∫•m Dragon c∆° b·∫£n c·ªßa ng∆∞·ªùi Tr√°i ƒê·∫•t"
            },
            KAMEJOKO: {
                name: "Kamejoko",
                powerScale: 1.5,
                kiCost: 0.3,
                powerRequired: 50000,
                description: "Kamehameha phi√™n b·∫£n l·ªói c·ªßa Goku"
            },
            SOLAR_FLARE: {
                name: "Th√°i D∆∞∆°ng H·∫° San",
                powerScale: 0,
                kiCost: 0.4,
                powerRequired: 5000000,
                description: "Cho√°ng ƒë·ªëi th·ªß 10s"
            },
            KAIOKEN: {
                name: "Kaioken",
                powerScale: 0,
                kiCost: 0.5,
                powerRequired: 50000000,
                description: "TƒÉng x30 HP, KI, S·ª©c ƒë√°nh"
            },
            SPIRIT_BOMB: {
                name: "Qu·∫£ C·∫ßu Kinh Kh√≠",
                powerScale: 8.0,
                kiCost: 1.0,
                powerRequired: 500000000,
                description: "T·∫°o qu·∫£ c·∫ßu c·ª±c m·∫°nh t·ªën 100% ki"
            },
            ENERGY_SHIELD: {
                name: "Khi√™n NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: 0.7,
                powerRequired: 5000000000,
                description: "Ch·ªãu m·ªçi s√°t th∆∞∆°ng trong 40s"
            },
            HYPNOSIS: {
                name: "Th√¥i Mi√™n",
                powerScale: 0,
                kiCost: 0.6,
                powerRequired: 1000000000,
                description: "Cho√°ng ƒë·ªëi th·ªß 30s"
            },
        }
    },

    PICCOLO: {
        name: "Piccolo",
        race: "Namek",
        description: "Chi·∫øn binh t·ªôc Namek",
        skills: {
            SPECIAL_BEAM_CANNON: {
                name: "Makankosappo",
                powerScale: 2.5,
                kiCost: 0.4,
                powerRequired: 1000000,
                description: "Xo√°y ma khoan xuy√™n th·ªßng"
            },
            REGENERATION: {
                name: "T√°i T·∫°o",
                powerScale: 0,
                kiCost: -0.3,
                powerRequired: 5000000,
                description: "H·ªìi ph·ª•c 30% HP"
            },
            LIGHT_GRENADE: {
                name: "Light Grenade",
                powerScale: 3.0,
                kiCost: 0.5,
                powerRequired: 10000000,
                description: "Qu·∫£ c·∫ßu √°nh s√°ng h·ªßy di·ªát"
            },
            HELLZONE_GRENADE: {
                name: "Hellzone Grenade",
                powerScale: 4.0,
                kiCost: 0.6,
                powerRequired: 100000000,
                description: "B·∫´y ƒë·ªãa ng·ª•c kh√¥ng l·ªëi tho√°t"
            },
            DEMONICAL_FLAVOR: {
                name: "H∆∞∆°ng V·ªã Qu·ª∑ D·ªØ",
                powerScale: 3.5,
                kiCost: 0.55,
                powerRequired: 750000000,
                description: "T·∫•n c√¥ng b·∫±ng nƒÉng l∆∞·ª£ng qu·ª∑ d·ªØ"
            },
            MULTIFORM: {
                name: "Ph√¢n Th√¢n",
                powerScale: 5.0,
                kiCost: 0.7,
                powerRequired: 1000000000,
                description: "T·∫°o nhi·ªÅu b·∫£n sao chi·∫øn ƒë·∫•u"
            },
            EXPLODING_STORM: {
                name: "B√£o NƒÉng L∆∞·ª£ng",
                powerScale: 4.5,
                kiCost: 0.65,
                powerRequired: 2000000000,
                description: "T·∫°o ra c∆°n b√£o nƒÉng l∆∞·ª£ng"
            }
        }
    },

    GOKU: {
        name: "Kakarot",
        race: "Saiyan",
        description: "Chi·∫øn binh Saiyan huy·ªÅn tho·∫°i",
        skills: {
            ATOMIC: {
                name: "ƒê·∫•m Galick",
                powerScale: 1.2,
                kiCost: 0.2,
                powerRequired: 0,
                description: "ƒê·∫•m Galick c∆° b·∫£n c·ªßa ng∆∞·ªùi Saiyan"
            },
            REGENERATE_ENERGY: {
                name: "T√°i T·∫°o NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: -0.5,
                powerRequired: 1000000,
                description: "H·ªìi ph·ª•c Ki nhanh ch√≥ng"
            },
            WHISTLE: {
                name: "Hu√Ωt S√°o",
                powerScale: 0,
                kiCost: -0.3,
                powerRequired: 50000000,
                description: "H·ªìi HP v√† Ki cho b·∫£n th√¢n"
            },
            BIND: {
                name: "Tr√≥i",
                powerScale: 0,
                kiCost: 0.3,
                powerRequired: 100000000,
                description: "Tr√≥i ƒë·ªëi th·ªß trong 15 gi√¢y"
            },
            ENERGY_SHIELD: {
                name: "Khi√™n NƒÉng L∆∞·ª£ng",
                powerScale: 0,
                kiCost: 0.5,
                powerRequired: 5000000000,
                description: "T·∫°o khi√™n b·∫£o v·ªá trong 40 gi√¢y"
            },
            CADICH_LIEN_HOAN_TRUONG: {
                name: "Cadich Li√™n Ho√†n Tr∆∞·ªüng",
                powerScale: 6.0,
                kiCost: 0.8,
                powerRequired: 30000000000,
                description: "T·∫•n c√¥ng li√™n ho√†n b·∫±ng ch∆∞·ªüng"
            },
            GREAT_APE: {
                name: "Bi·∫øn Kh·ªâ Kh·ªïng L·ªì",
                powerScale: 5.0,
                kiCost: 0.8,
                powerRequired: 50000000000,
                description: "Bi·∫øn th√†nh kh·ªâ ƒë·ªôt kh·ªïng l·ªì, tƒÉng s·ª©c m·∫°nh g·∫•p 10 l·∫ßn"
            },
        }
    }
};

const STAT_LIMITS = {
    POWER: 100000000000,
    DAMAGE: 50000000,
    KI: 50000000,
    HP: 50000000
};
const EXP_SYSTEM = {
    BASE_EXP: { min: 500, max: 1500 },
    POWER_BONUS: {
        thresholds: [
            { percent: 1, bonus: 2.0 },
            { percent: 5, bonus: 3.0 },
            { percent: 10, bonus: 4.0 },
            { percent: 25, bonus: 5.0 },
            { percent: 50, bonus: 7.0 },
            { percent: 75, bonus: 10.0 },
            { percent: 90, bonus: 15.0 }
        ],
        MAX_POWER: 100000000000
    }
};
const MAX_EXP_STORAGE = 5000000000;
const UPGRADE_COSTS = {
    damage: (currentDamage) => {
        if (currentDamage < 100) return 100;
        if (currentDamage < 1000) return currentDamage * 5;
        if (currentDamage < 10000) return currentDamage * 8;
        if (currentDamage < 100000) return currentDamage * 12;
        if (currentDamage < 1000000) return currentDamage * 18;
        return currentDamage * 25;
    },
    ki: (currentKi) => {
        if (currentKi < 100) return 120;
        if (currentKi < 1000) return currentKi * 5;
        if (currentKi < 10000) return currentKi * 8;
        if (currentKi < 100000) return currentKi * 12;
        if (currentKi < 1000000) return currentKi * 18;
        return currentKi * 25;
    },
    health: (currentHealth) => {
        if (currentHealth < 500) return 80;
        if (currentHealth < 5000) return currentHealth * 0.8;
        if (currentHealth < 50000) return currentHealth * 1.2;
        if (currentHealth < 500000) return currentHealth * 1.8;
        if (currentHealth < 5000000) return currentHealth * 2.5;
        return currentHealth * 3.5;
    }
};
const ZENI_INFO = {
    TRAIN_MIN: 50,
    TRAIN_MAX: 200,
    FIND_CHANCE: 0.25,
    SPECIAL_MIN: 500,
    SPECIAL_MAX: 2000
};
const DEFAULT_STATS = {
    power: 1000,
    damage: 100,
    ki: 100,
    currentKi: 100,
    health: 1000,
    currentHealth: 1000,
    exp: 0,
    zeni: 1000,
    inventory: {
        items: [],
        equipped: []
    },
    quests: {
        active: [],
        completed: [],
        progress: {}
    }
};
const WORLD_LOCATIONS = {
    EARTH: [
        { id: "kame_house", name: "Kame House", description: "Nh√† c·ªßa Quy L√£o, n∆°i t·∫≠p luy·ªán c·ªßa Goku v√† Krillin" },
        { id: "capsule_corp", name: "Capsule Corporation", description: "Tr·ª• s·ªü c√¥ng ty Capsule do gia ƒë√¨nh Bulma s·ªü h·ªØu" },
        { id: "tournament_arena", name: "ƒê·∫•u Tr∆∞·ªùng Thi√™n H·∫°", description: "N∆°i t·ªï ch·ª©c ƒê·∫°i H·ªôi V√µ Thu·∫≠t Thi√™n H·∫°" },
        { id: "korin_tower", name: "Th√°p Korin", description: "Ng√¥i th√°p cao n∆°i m√®o th·∫ßn Korin ·ªü" },
        { id: "kami_lookout", name: "Khu V·ª±c Canh G√°c C·ªßa Th·∫ßn", description: "N∆°i ·ªü c·ªßa Th·∫ßn ƒê·ªãa C·∫ßu" }
    ],
    NAMEK: [
        { id: "guru_house", name: "Nh√† C·ªßa ƒê·∫°i Tr∆∞·ªüng L√£o", description: "N∆°i ·ªü c·ªßa ƒê·∫°i Tr∆∞·ªüng L√£o Namek" },
        { id: "porunga_summoning", name: "B√£i Tri·ªáu H·ªìi Porunga", description: "V√πng ƒë·∫•t thi√™ng ƒë·ªÉ tri·ªáu h·ªìi R·ªìng Th·∫ßn Porunga" },
        { id: "frieza_spaceship", name: "T√†u V≈© Tr·ª• Frieza", description: "CƒÉn c·ª© c·ªßa Frieza tr√™n Namek" },
        { id: "namek_village", name: "L√†ng Namek", description: "Ng√¥i l√†ng c·ªßa ng∆∞·ªùi Namek" },
        { id: "namek_battlefield", name: "Chi·∫øn Tr∆∞·ªùng Namek", description: "N∆°i di·ªÖn ra tr·∫≠n chi·∫øn gi·ªØa Goku v√† Frieza" }
    ],
    SAIYAN: [
        { id: "vegeta_palace", name: "Cung ƒêi·ªán Vegeta", description: "Cung ƒëi·ªán ho√†ng gia c·ªßa t·ªôc Saiyan" },
        { id: "saiyan_training", name: "Khu V·ª±c Hu·∫•n Luy·ªán", description: "N∆°i c√°c chi·∫øn binh Saiyan t·∫≠p luy·ªán" },
        { id: "planet_core", name: "L√µi H√†nh Tinh", description: "Trung t√¢m h√†nh tinh v·ªõi nƒÉng l∆∞·ª£ng d·ªìi d√†o" },
        { id: "royal_garden", name: "V∆∞·ªùn Ho√†ng Gia", description: "Khu v∆∞·ªùn c·ªßa Ho√†ng t·ªôc Saiyan" },
        { id: "space_pod_station", name: "Tr·∫°m V≈© Tr·ª•", description: "N∆°i xu·∫•t ph√°t c√°c phi thuy·ªÅn Saiyan" }
    ]
};

// Boss system
const BOSS_SYSTEM = {
    activeEvents: {},
    bossList: {
        EARTH: [
            {
                id: "king_piccolo",
                name: "ƒê·∫°i Ma V∆∞∆°ng Piccolo",
                description: "Ma v∆∞∆°ng c·ªßa ƒê·ªãa C·∫ßu, t·ª´ng su√Ωt h·ªßy di·ªát th·∫ø gi·ªõi",
                power: 1500000,
                health: 5000000,
                damage: 250000,
                ki: 500000,
                skills: ["SPECIAL_BEAM_CANNON", "HELLZONE_GRENADE", "NAMEK_FUSION"],
                drops: [
                    { item: "turtle_gi", chance: 0.5 },
                    { item: "crystal", chance: 0.7, quantity: 3 },
                    { item: "senzu", chance: 1.0, quantity: 5 }
                ],
                minPowerRequired: 500000,
                zeniReward: { min: 500000, max: 1000000 },
                expReward: 200000,
                image: "https://imgur.com/2AtrNjL.jpg", // Replace with actual image
                spawnChance: 0.3,
                duration: 3600000 // 1 hour in milliseconds
            },
            {
                id: "cell",
                name: "Cell Ho√†n H·∫£o",
                description: "Sinh v·∫≠t nh√¢n t·∫°o ho√†n h·∫£o do ti·∫øn sƒ© Gero t·∫°o ra",
                power: 5000000,
                health: 15000000,
                damage: 750000,
                ki: 1000000,
                skills: ["KAMEHAMEHA", "SOLAR_FLARE", "SPIRIT_BOMB", "REGENERATION"],
                drops: [
                    { item: "weighted_clothing", chance: 0.4 },
                    { item: "crystal", chance: 0.8, quantity: 5 },
                    { item: "senzu", chance: 1.0, quantity: 10 }
                ],
                minPowerRequired: 2000000,
                zeniReward: { min: 1000000, max: 3000000 },
                expReward: 500000,
                image: "https://imgur.com/0cbG1R1.jpg", // Replace with actual image
                spawnChance: 0.15,
                duration: 7200000 // 2 hours in milliseconds
            }
        ],
        NAMEK: [
            {
                id: "frieza",
                name: "Frieza D·∫°ng Cu·ªëi",
                description: "Ho√†ng ƒë·∫ø v≈© tr·ª• t√†n b·∫°o, ng∆∞·ªùi ƒë√£ h·ªßy di·ªát h√†nh tinh Vegeta",
                power: 3000000,
                health: 10000000,
                damage: 500000,
                ki: 800000,
                skills: ["DEATH_BEAM", "SUPERNOVA", "BIND"],
                drops: [
                    { item: "frieza_force_armor", chance: 0.3 },
                    { item: "crystal", chance: 0.8, quantity: 4 },
                    { item: "senzu", chance: 1.0, quantity: 8 }
                ],
                minPowerRequired: 1000000,
                zeniReward: { min: 800000, max: 2000000 },
                expReward: 300000,
                image: "https://imgur.com/mC4n7UV.jpg", // Replace with actual image
                spawnChance: 0.2,
                duration: 5400000 // 1.5 hours in milliseconds
            },
            {
                id: "cooler",
                name: "Cooler D·∫°ng Th·ª© 5",
                description: "Anh trai c·ªßa Frieza, m·∫°nh h∆°n em trai m√¨nh",
                power: 6000000,
                health: 18000000,
                damage: 900000,
                ki: 1200000,
                skills: ["SUPERNOVA", "DEATH_FLASH", "ENERGY_SHIELD"],
                drops: [
                    { item: "elder_robe", chance: 0.4 },
                    { item: "crystal", chance: 0.8, quantity: 6 },
                    { item: "senzu", chance: 1.0, quantity: 12 }
                ],
                minPowerRequired: 3000000,
                zeniReward: { min: 1500000, max: 4000000 },
                expReward: 600000,
                image: "https://imgur.com/Dogn2Gk.jpg", // Replace with actual image
                spawnChance: 0.1,
                duration: 7200000 // 2 hours in milliseconds
            }
        ],
        SAIYAN: [
            {
                id: "broly",
                name: "Broly Super Saiyan Huy·ªÅn Tho·∫°i",
                description: "Super Saiyan huy·ªÅn tho·∫°i, sinh ra v·ªõi s·ª©c m·∫°nh kinh kh·ªßng",
                power: 8000000,
                health: 25000000,
                damage: 1200000,
                ki: 1500000,
                skills: ["GIGANTIC_METEOR", "ERASER_CANNON", "ENERGY_SHIELD"],
                drops: [
                    { item: "royal_armor", chance: 0.3 },
                    { item: "royal_boots", chance: 0.3 },
                    { item: "crystal", chance: 0.9, quantity: 8 },
                    { item: "senzu", chance: 1.0, quantity: 15 }
                ],
                minPowerRequired: 4000000,
                zeniReward: { min: 3000000, max: 6000000 },
                expReward: 800000,
                image: "https://imgur.com/PYh6JPh.jpg", // Replace with actual image
                spawnChance: 0.1,
                duration: 10800000 // 3 hours in milliseconds
            },
            {
                id: "beerus",
                name: "Th·∫ßn H·ªßy Di·ªát Beerus",
                description: "V·ªã th·∫ßn h·ªßy di·ªát c·ªßa v≈© tr·ª• 7, lu√¥n t√¨m ki·∫øm th·ª©c ƒÉn ngon",
                power: 20000000,
                health: 50000000,
                damage: 3000000,
                ki: 5000000,
                skills: ["HAKAI", "GOD_BLAST", "ENERGY_SHIELD"],
                drops: [
                    { item: "radar_8", chance: 0.2 },
                    { item: "crystal", chance: 1.0, quantity: 15 },
                    { item: "senzu", chance: 1.0, quantity: 25 }
                ],
                minPowerRequired: 10000000,
                zeniReward: { min: 5000000, max: 15000000 },
                expReward: 2000000,
                image: "https://imgur.com/wahYEk1.jpg", // Replace with actual image
                spawnChance: 0.05,
                duration: 14400000 // 4 hours in milliseconds
            }
        ]
    },

    // Check for boss events
    checkForBossEvents() {
        const now = Date.now();

        // First cleanup expired events
        Object.keys(this.activeEvents).forEach(eventId => {
            const event = this.activeEvents[eventId];
            if (now > event.expireTime) {
                console.log(`Boss event expired: ${event.boss.name} at ${event.location.name}`);
                delete this.activeEvents[eventId];
            }
        });

        // Only spawn new bosses if we don't have too many active
        if (Object.keys(this.activeEvents).length >= 3) {
            return;
        }

        // Check chance to spawn a new boss for each planet
        Object.keys(PLANETS).forEach(planet => {
            const locationList = WORLD_LOCATIONS[planet];
            const bossList = this.bossList[planet];

            if (!locationList || !bossList) return;

            // Only spawn if random chance met (10% chance per check)
            if (Math.random() > 0.1) return;

            // Pick a random boss and location
            const randomBoss = bossList[Math.floor(Math.random() * bossList.length)];
            const randomLocation = locationList[Math.floor(Math.random() * locationList.length)];

            // Check if this boss should spawn based on its own spawn chance
            if (Math.random() > randomBoss.spawnChance) return;

            // Create unique event ID
            const eventId = `${planet}_${randomBoss.id}_${now}`;

            // Create the event
            this.activeEvents[eventId] = {
                id: eventId,
                planet: planet,
                location: randomLocation,
                boss: randomBoss,
                participants: {},
                damageDealt: {},
                spawnTime: now,
                expireTime: now + randomBoss.duration,
                defeated: false
            };

            console.log(`New boss spawned: ${randomBoss.name} at ${randomLocation.name} on ${planet}`);
        });
    },

    // Get all active boss events
    getActiveEvents() {
        return this.activeEvents;
    },

    // Get boss events for a specific planet
    getPlanetEvents(planet) {
        const events = {};
        Object.keys(this.activeEvents).forEach(eventId => {
            if (this.activeEvents[eventId].planet === planet) {
                events[eventId] = this.activeEvents[eventId];
            }
        });
        return events;
    },

    // Register damage dealt to a boss
    registerDamage(eventId, playerId, playerName, damageAmount) {
        if (!this.activeEvents[eventId]) return false;

        const event = this.activeEvents[eventId];

        // Register participant if not already
        if (!event.participants[playerId]) {
            event.participants[playerId] = {
                id: playerId,
                name: playerName,
                joinTime: Date.now()
            };
        }

        // Add damage
        if (!event.damageDealt[playerId]) {
            event.damageDealt[playerId] = 0;
        }
        event.damageDealt[playerId] += damageAmount;

        // Check if boss is defeated
        const totalDamage = Object.values(event.damageDealt).reduce((sum, damage) => sum + damage, 0);
        if (totalDamage >= event.boss.health && !event.defeated) {
            event.defeated = true;
            event.defeatTime = Date.now();
            console.log(`Boss defeated: ${event.boss.name} at ${event.location.name}`);
        }

        return event.defeated;
    },

    // Get rewards for a player based on their contribution
    getPlayerRewards(eventId, playerId) {
        if (!this.activeEvents[eventId] || !this.activeEvents[eventId].defeated) {
            return null;
        }

        const event = this.activeEvents[eventId];
        if (!event.damageDealt[playerId]) {
            return null;
        }

        const totalDamage = Object.values(event.damageDealt).reduce((sum, damage) => sum + damage, 0);
        const contributionRatio = event.damageDealt[playerId] / totalDamage;

        // Calculate rewards based on contribution
        const zeniBase = event.boss.zeniReward.min + Math.random() * (event.boss.zeniReward.max - event.boss.zeniReward.min);
        const zeniReward = Math.floor(zeniBase * contributionRatio);
        const expReward = Math.floor(event.boss.expReward * contributionRatio);

        // Calculate drops
        const drops = [];
        event.boss.drops.forEach(drop => {
            // Adjust drop chance based on contribution (higher contribution = better chance)
            const adjustedChance = drop.chance * (0.5 + 0.5 * contributionRatio);
            if (Math.random() < adjustedChance) {
                drops.push({
                    item: drop.item,
                    quantity: drop.quantity || 1
                });
            }
        });

        return {
            zeni: zeniReward,
            exp: expReward,
            drops: drops,
            contribution: contributionRatio
        };
    },

    // Load boss data from saved file
    loadBossData() {
        try {
            const bossDataPath = path.join(__dirname, "json", "dragonball", "boss_events.json");
            if (fs.existsSync(bossDataPath)) {
                const data = JSON.parse(fs.readFileSync(bossDataPath, "utf8"));
                // Only restore active events that haven't expired
                const now = Date.now();
                Object.keys(data).forEach(eventId => {
                    if (now < data[eventId].expireTime && !data[eventId].defeated) {
                        this.activeEvents[eventId] = data[eventId];
                    }
                });
            }
        } catch (error) {
            console.error("Error loading boss data:", error);
        }
    },

    // Save boss data
    saveBossData() {
        try {
            const bossDataPath = path.join(__dirname, "json", "dragonball", "boss_events.json");
            fs.writeFileSync(bossDataPath, JSON.stringify(this.activeEvents, null, 2));
        } catch (error) {
            console.error("Error saving boss data:", error);
        }
    }
};
function checkBossSchedule() {
    const now = Date.now();
    const activeBosses = BOSS_SYSTEM.getActiveEvents();

    // Check and remove expired bosses
    Object.entries(activeBosses).forEach(([eventId, event]) => {
        if (now > event.expireTime || event.defeated) {
            delete BOSS_SYSTEM.activeEvents[eventId];
        }
    });

    // Spawn new bosses if needed
    if (Object.keys(BOSS_SYSTEM.activeEvents).length < 3) {
        BOSS_SYSTEM.checkForBossEvents();
    }

    // Save updated boss data
    BOSS_SYSTEM.saveBossData();
}
function startTournament(type, organizer, playerData) {
    const tournamentData = loadTournamentData();

    if (tournamentData.active) {
        return {
            success: false,
            message: "ƒê√£ c√≥ gi·∫£i ƒë·∫•u ƒëang di·ªÖn ra!"
        };
    }

    const registeredPlayers = Object.keys(tournamentData.registrations).length;
    const tournamentConfig = TOURNAMENT_TYPES[type];

    if (registeredPlayers < tournamentConfig.minPlayers) {
        return {
            success: false,
            message: `C·∫ßn √≠t nh·∫•t ${tournamentConfig.minPlayers} ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu!`
        };
    }

    tournamentData.active = {
        type: type,
        startTime: Date.now(),
        organizer: organizer,
        currentRound: 1,
        matches: [],
        rounds: [],
        winners: {
            first: null,
            second: null,
            semifinalists: []
        }
    };

    // Create tournament bracket
    const players = Object.keys(tournamentData.registrations)
        .map(id => ({
            id: id,
            name: playerData[id].name,
            power: playerData[id].stats.power
        }));

    // Shuffle players
    for (let i = players.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [players[i], players[j]] = [players[j], players[i]];
    }

    // Create first round matches
    tournamentData.active.rounds[1] = [];
    for (let i = 0; i < players.length; i += 2) {
        if (i + 1 < players.length) {
            const match = {
                id: Math.floor(i / 2) + 1,
                round: 1,
                player1: players[i],
                player2: players[i + 1],
                winner: null,
                loser: null,
                completed: false,
                scheduledTime: Date.now() + (Math.floor(i / 2) + 1) * 300000
            };
            tournamentData.active.rounds[1].push(match);
            tournamentData.active.matches.push(match);
        }
    }

    saveTournamentData(tournamentData);

    return {
        success: true,
        message: "Gi·∫£i ƒë·∫•u ƒë√£ b·∫Øt ƒë·∫ßu!",
        matches: tournamentData.active.rounds[1]
    };
}
function applyEquipmentBoosts(player) {
    // Th√™m ƒë·ªãnh nghƒ©a boostMultipliers
    const boostMultipliers = {
        damage: 1.0,
        health: 1.0,
        ki: 1.0
    };

    // Reset stats to base values first
    if (!player.baseStats) {
        player.baseStats = {
            damage: player.stats.damage,
            health: player.stats.health,
            ki: player.stats.ki
        };
    } else {
        player.stats.damage = player.baseStats.damage;
        player.stats.health = player.baseStats.health;
        player.stats.ki = player.baseStats.ki;
    }

    // Apply equipment boosts
    if (player.inventory?.items) {
        player.inventory.items.forEach(item => {
            if (item.equipped) {
                switch (item.type) {
                    case "armor":
                        boostMultipliers.health *= item.boost;
                        break;

                    case "gloves":
                        boostMultipliers.damage *= item.boost;
                        break;

                    case "boots":
                        boostMultipliers.ki *= item.boost;
                        break;

                    case "radar":
                        // Rada effects are handled separately during training
                        break;
                }
            }
        });
    }

    if (!player.baseStats) {
        player.baseStats = {
            damage: player.stats.damage,
            health: player.stats.health,
            ki: player.stats.ki
        };
    }

    player.stats.damage = Math.floor(player.baseStats.damage * boostMultipliers.damage);
    player.stats.health = Math.floor(player.baseStats.health * boostMultipliers.health);
    player.stats.ki = Math.floor(player.baseStats.ki * boostMultipliers.ki);

    player.stats.currentHealth = Math.min(
        player.stats.currentHealth || player.stats.health,
        player.stats.health
    );
    player.stats.currentKi = Math.min(
        player.stats.currentKi || player.stats.ki,
        player.stats.ki
    );

    return player;
}
function simulateBattle(attacker, defender, options = {}) {
    const {
        battleType = "PVP",
        maxTurns = 30,
        isPlayerAttacker = true,
        isPlayerDefender = true,
    } = options;

    let enemyDamage;
    if (options.bossMode) {

        enemyDamage = defender.stats.damage;
    } else {

        enemyDamage = Math.floor(defender.stats.power / 20);
    }

    const battleContext = {
        turn: 0,
        momentum: 0,
        criticalMoment: false,
        environmentEffects: [],
        battleStartTime: Date.now()
    };


    let attackerHP = isPlayerAttacker ?
        (attacker.stats.currentHealth || attacker.stats.health || 1000) :
        (defender.hp || defender.stats?.health || 1000);

    let attackerMaxHP = isPlayerAttacker ?
        (attacker.stats.health || 1000) :
        (defender.hp || defender.stats?.health || 1000);

    let attackerKi = isPlayerAttacker ?
        (attacker.stats.currentKi || attacker.stats.ki || 100) :
        (defender.ki || defender.stats?.ki || 100);

    let attackerDamage = isPlayerAttacker ?
        (attacker.stats.damage || 100) :
        (defender.power ? Math.floor(defender.power / 10) : 100);

    let defenderHP = isPlayerDefender ?
        (defender.stats.currentHealth || defender.stats.health || 1000) :
        (defender.hp || defender.stats?.health || 1000);

    let defenderMaxHP = isPlayerDefender ?
        (defender.stats.health || 1000) :
        (defender.hp || defender.stats?.health || 1000);

    let defenderKi = isPlayerDefender ?
        (defender.stats.currentKi || defender.stats.ki || 100) :
        (defender.ki || defender.stats?.ki || 100);

    let defenderDamage = isPlayerDefender ?
        (defender.stats.damage || 100) :
        (defender.power ? Math.floor(defender.power / 10) : 100);


    attackerHP = Number(attackerHP) || 1000;
    attackerMaxHP = Number(attackerMaxHP) || 1000;
    attackerKi = Number(attackerKi) || 100;
    attackerDamage = Number(attackerDamage) || 100;
    defenderHP = Number(defenderHP) || 1000;
    defenderMaxHP = Number(defenderMaxHP) || 1000;
    defenderKi = Number(defenderKi) || 100;
    defenderDamage = Number(defenderDamage) || 100;


    const originalAttackerKi = attackerKi;
    const originalDefenderKi = defenderKi;
    const initialAttackerHP = attackerHP;
    const initialDefenderHP = defenderHP;


    if (isPlayerAttacker && attacker.inventory?.items) {
        attacker.inventory.items.filter(item => item.equipped).forEach(item => {
            if (item.id === "tournament_belt") attackerDamage *= 1.3;
            if (item.id === "cell_medal") {
                attackerHP *= 1.3;
                attackerKi *= 1.3;
            }
            if (item.id === "universe_medal") {
                attackerHP *= 1.5;
                attackerKi *= 1.5;
                attackerDamage *= 1.5;
            }
            if (item.id === "armor") {
                attackerHP *= 1.15;
            }
            if (item.id === "scouter") {
                attackerDamage *= 1.1;
            }
        });
    }

    if (isPlayerDefender && defender.inventory?.items) {
        defender.inventory.items.filter(item => item.equipped).forEach(item => {
            if (item.id === "tournament_belt") defenderDamage *= 1.3;
            if (item.id === "cell_medal") {
                defenderHP *= 1.3;
                defenderKi *= 1.3;
            }
            if (item.id === "universe_medal") {
                defenderHP *= 1.5;
                defenderKi *= 1.5;
                defenderDamage *= 1.5;
            }
            if (item.id === "armor") {
                defenderHP *= 1.15;
            }
            if (item.id === "scouter") {
                defenderDamage *= 1.1;
            }
        });
    }


    let attackerStates = {
        stunned: 0,
        shielded: 0,
        bound: 0,
        powerBoosted: 0,
        powerBoostMultiplier: 1.0,
        greatApe: 0,
        vulnerable: 0,
        spiritBombCharge: 0,
        combo: 0,
        lastSkill: null
    };

    let defenderStates = {
        stunned: 0,
        shielded: 0,
        bound: 0,
        powerBoosted: 0,
        powerBoostMultiplier: 1.0,
        greatApe: 0,
        vulnerable: 0,
        spiritBombCharge: 0,
        combo: 0,
        lastSkill: null
    };


    let battleLog = [];
    const attackerName = isPlayerAttacker ? attacker.name : (attacker.name || "Qu√°i v·∫≠t");
    const defenderName = isPlayerDefender ? defender.name : (defender.name || "Qu√°i v·∫≠t");

    battleLog.push(`‚öîÔ∏è ${attackerName} ƒë·∫•u v·ªõi ${defenderName}!`);


    const battleId = Date.now().toString().slice(0, 10);
    const regenSkillsUsed = {};
    let turn = 0;
    let totalDamageDealt = { attacker: 0, defender: 0 };


    const getBattlePhase = (currentTurn, maxTurns) => {
        if (currentTurn <= Math.floor(maxTurns * 0.3)) return "EARLY";
        if (currentTurn <= Math.floor(maxTurns * 0.7)) return "MID";
        return "LATE";
    };

    const getCriticalHitChance = (combo, powerBoostMultiplier) => {
        return Math.min(0.05 + (combo * 0.03) + ((powerBoostMultiplier - 1) * 0.1), 0.5);
    };

    const getComboBonus = (combo) => {
        return 1 + Math.min(combo * 0.1, 0.5);
    };

    let attackerSkillCooldowns = {};
    let defenderSkillCooldowns = {};

    const CONTROL_SKILL_COOLDOWN = 5;
    const BIND_SKILL_COOLDOWN = 3;
    const SHIELD_SKILL_COOLDOWN = 4;
    const POWER_UP_COOLDOWN = 10;
    while (attackerHP > 0 && defenderHP > 0 && turn < maxTurns) {
        turn++;

        Object.keys(attackerSkillCooldowns).forEach(skill => {
            if (attackerSkillCooldowns[skill] > 0) attackerSkillCooldowns[skill]--;
        });

        Object.keys(defenderSkillCooldowns).forEach(skill => {
            if (defenderSkillCooldowns[skill] > 0) defenderSkillCooldowns[skill]--;
        });
        battleContext.turn = turn;


        const battlePhase = getBattlePhase(turn, maxTurns);
        const isAttackerCritical = attackerHP < attackerMaxHP * 0.3;
        const isDefenderCritical = defenderHP < defenderMaxHP * 0.3;


        battleContext.criticalMoment = turn % 5 === 0 || (Math.random() < 0.15);

        if (battleContext.criticalMoment) {
            battleLog.push(`‚ö° Th·ªùi kh·∫Øc quy·∫øt ƒë·ªãnh! S·ª©c m·∫°nh t·∫•n c√¥ng tƒÉng l√™n!`);
        }


        if (!attackerStates.stunned && !attackerStates.bound) {

            if (isPlayerAttacker && attacker.skills?.length > 0 && Math.random() < 0.78) {

                const skillChoice = selectBestSkill(
                    attacker,
                    attackerHP,
                    attackerKi,
                    defenderHP,
                    attackerStates,
                    defenderStates,
                    battleLog,
                    turn
                ) || attacker.skills[Math.floor(Math.random() * attacker.skills.length)];

                const [master, skillName] = skillChoice.split(":");
                const skillData = MASTERS[master]?.skills[skillName];

                if (skillData) {

                    if (skillName === "SPIRIT_BOMB" && turn < 25) {
                        const normalDamage = Math.floor(attackerDamage * 0.8);
                        defenderHP -= normalDamage;
                        totalDamageDealt.attacker += normalDamage;
                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                        battleLog.push(`üí¨ Qu·∫£ C·∫ßu Kinh Kh√≠ c·∫ßn √≠t nh·∫•t 25 l∆∞·ª£t ƒë·ªÉ t√≠ch t·ª• ƒë·ªß nƒÉng l∆∞·ª£ng!`);
                        continue;
                    }

                    const kiRequired = Math.floor(attackerKi * Math.abs(skillData.kiCost || 0));
                    const skillDamage = Math.floor(attackerDamage * (skillData.powerScale || 0));


                    const skillCheck = canUseSkill(
                        skillName,
                        skillData,
                        turn,
                        attackerHP,
                        attackerMaxHP,
                        attackerKi,
                        originalAttackerKi
                    );

                    if (!skillCheck.canUse) {
                        if (skillName === "SPIRIT_BOMB" && skillCheck.reason === "EARLY_TURN") {
                            const normalDamage = Math.floor(attackerDamage * 0.8);
                            defenderHP -= normalDamage;
                            totalDamageDealt.attacker += normalDamage;
                            battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                            battleLog.push(`üí¨ ${skillCheck.message}`);
                            continue;
                        }
                    }


                    if (attackerKi >= kiRequired || (skillData.kiCost || 0) < 0) {

                        if (skillData.powerScale > 0) {
                            attackerStates.combo += 1;


                            const comboBonus = getComboBonus(attackerStates.combo);


                            const critChance = getCriticalHitChance(attackerStates.combo, attackerStates.powerBoostMultiplier);
                            const isCritical = Math.random() < critChance || (battleContext.criticalMoment && Math.random() < 0.5);


                            let actualDamage = attackerStates.powerBoosted > 0
                                ? Math.floor(skillDamage * attackerStates.powerBoostMultiplier * comboBonus)
                                : Math.floor(skillDamage * comboBonus);

                            const maxDamagePercent = skillName === "SPIRIT_BOMB" || skillName === "CADICH_LIEN_HOAN_TRUONG" ||
                                skillName === "GREAT_APE" ? 0.5 : 0.3;
                            const maxDamage = Math.floor(defenderMaxHP * maxDamagePercent);

                            if (actualDamage > maxDamage) {
                                actualDamage = maxDamage;
                            }

                            if (isCritical) {
                                actualDamage = Math.floor(actualDamage * 1.5);
                            }


                            if (defenderStates.shielded > 0) {
                                battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${defenderName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng!`);
                                defenderStates.shielded--;
                                attackerStates.combo = 0;
                            } else {
                                defenderHP -= actualDamage;
                                totalDamageDealt.attacker += actualDamage;


                                if (skillData.kiCost > 0) {
                                    attackerKi -= kiRequired;
                                }


                                let attackMessage = `üéØ ${attackerName} d√πng ${skillData.name} g√¢y ${actualDamage.toLocaleString()} s√°t th∆∞∆°ng!`;

                                if (attackerStates.combo > 1) {
                                    attackMessage += ` (Combo x${attackerStates.combo})`;
                                }

                                if (isCritical) {
                                    attackMessage += ` üí• CH√ç M·∫†NG!`;
                                }

                                if (skillData.kiCost > 0) {
                                    attackMessage += `\n‚ú® -${kiRequired} Ki`;
                                }

                                battleLog.push(attackMessage);


                                if (actualDamage > defenderMaxHP * 0.2) {
                                    defenderStates.vulnerable = 1;
                                    battleLog.push(`‚ö†Ô∏è ${defenderName} ƒëang trong tr·∫°ng th√°i d·ªÖ b·ªã t·ªïn th∆∞∆°ng!`);
                                }
                            }
                        }
                        else if (skillData.kiCost < 0) {
                            const kiRestore = kiRequired;
                            attackerKi = Math.min(
                                isPlayerAttacker ? attacker.stats.ki : attackerKi * 2,
                                attackerKi + kiRestore
                            );
                            battleLog.push(`‚ú® ${attackerName} d√πng ${skillData.name}, h·ªìi ph·ª•c ${kiRestore.toLocaleString()} Ki!`);


                            attackerStates.combo = 0;
                        }
                        else {

                            switch (skillName) {
                                case "SOLAR_FLARE":
                                case "HYPNOSIS":
                                    if (attackerSkillCooldowns[skillName] > 0) {
                                        battleLog.push(`‚ùå ${attackerName} kh√¥ng th·ªÉ d√πng ${skillName === "SOLAR_FLARE" ? "Th√°i D∆∞∆°ng H·∫° San" : "Th√¥i Mi√™n"} (c√≤n ${attackerSkillCooldowns[skillName]} l∆∞·ª£t h·ªìi)!`);
                                        const normalDamage = Math.floor(attackerDamage * 0.8);
                                        defenderHP -= normalDamage;
                                        totalDamageDealt.attacker += normalDamage;
                                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                    } else {
                                        defenderStates.stunned = 2;
                                        attackerKi -= kiRequired;
                                        attackerSkillCooldowns[skillName] = CONTROL_SKILL_COOLDOWN;
                                        battleLog.push(`üåÄ ${attackerName} d√πng ${skillName === "SOLAR_FLARE" ? "Th√°i D∆∞∆°ng H·∫° San" : "Th√¥i Mi√™n"}! ${defenderName} b·ªã cho√°ng trong 2 l∆∞·ª£t!`);
                                        defenderStates.combo = 0;
                                    }
                                    break;
                                case "KAIOKEN":
                                    attackerSkillCooldowns[skillName] = POWER_UP_COOLDOWN;
                                    attackerStates.powerBoosted = 3;
                                    attackerStates.powerBoostMultiplier = 3.0;
                                    attackerKi -= kiRequired;
                                    battleLog.push(`üî• ${attackerName} d√πng Kaioken! S·ª©c m·∫°nh tƒÉng x3 trong 3 l∆∞·ª£t!`);
                                    break;

                                case "BIND":

                                    if (attackerSkillCooldowns["BIND"] > 0) {
                                        battleLog.push(`‚ùå ${attackerName} kh√¥ng th·ªÉ d√πng Tr√≥i (c√≤n ${attackerSkillCooldowns["BIND"]} l∆∞·ª£t h·ªìi)!`);

                                        const normalDamage = Math.floor(attackerDamage * 0.8);
                                        defenderHP -= normalDamage;
                                        totalDamageDealt.attacker += normalDamage;
                                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                    } else {

                                        defenderStates.bound = 2;
                                        attackerKi -= kiRequired;
                                        attackerSkillCooldowns["BIND"] = BIND_SKILL_COOLDOWN;
                                        battleLog.push(`üîó ${attackerName} d√πng Tr√≥i! ${defenderName} b·ªã tr√≥i 2 l∆∞·ª£t!`);
                                        defenderStates.combo = 0;
                                    }
                                    break;


                                case "ENERGY_SHIELD":
                                    const shieldDuration = 2;
                                    attackerStates.shielded = shieldDuration;
                                    attackerKi -= kiRequired;
                                    battleLog.push(`üõ°Ô∏è ${attackerName} t·∫°o Khi√™n NƒÉng L∆∞·ª£ng!`);
                                    break;

                                case "REGENERATION":
                                case "WHISTLE":
                                case "REGENERATE_ENERGY":
                                    if (regenSkillsUsed[battleId]) {
                                        battleLog.push(`‚ùå ${attackerName} ƒë√£ s·ª≠ d·ª•ng k·ªπ nƒÉng h·ªìi ph·ª•c trong tr·∫≠n n√†y!`);


                                        const normalDamage = Math.floor(attackerDamage * 0.8);
                                        defenderHP -= normalDamage;
                                        totalDamageDealt.attacker += normalDamage;
                                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                    } else {
                                        const hpRecover = Math.floor(attackerMaxHP * 0.3);
                                        const kiRecover = Math.floor(originalAttackerKi * 0.3);

                                        attackerHP = Math.min(attackerMaxHP, attackerHP + hpRecover);
                                        attackerKi = Math.min(originalAttackerKi, attackerKi + kiRecover);

                                        battleLog.push(`üíö ${attackerName} d√πng k·ªπ nƒÉng h·ªìi ph·ª•c!`);
                                        battleLog.push(`‚ù§Ô∏è H·ªìi ph·ª•c ${hpRecover.toLocaleString()} HP`);
                                        battleLog.push(`‚ú® H·ªìi ph·ª•c ${kiRecover.toLocaleString()} Ki`);

                                        regenSkillsUsed[battleId] = true;
                                        attackerStates.combo = 0;
                                    }
                                    break;

                                default:
                                    attackerKi -= kiRequired;
                                    battleLog.push(`‚ö° ${attackerName} d√πng ${skillData.name}!`);
                                    break;
                            }


                            attackerStates.lastSkill = skillName;
                        }
                    }
                    else {

                        const normalDamage = Math.floor(attackerDamage * 0.8);

                        if (defenderStates.shielded > 0) {
                            battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${defenderName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng!`);
                            defenderStates.shielded--;
                        } else {
                            defenderHP -= normalDamage;
                            totalDamageDealt.attacker += normalDamage;
                            battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);


                            if (attackerStates.combo > 0) {
                                attackerStates.combo -= 1;
                            }
                        }
                    }
                }
                else {

                    const normalDamage = Math.floor(attackerDamage * 0.8);
                    defenderHP -= normalDamage;
                    totalDamageDealt.attacker += normalDamage;
                    battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);


                    if (attackerStates.combo > 0) {
                        attackerStates.combo -= 1;
                    }
                }
            }
            else {

                const normalDamage = attackerStates.powerBoosted > 0
                    ? Math.floor(attackerDamage * attackerStates.powerBoostMultiplier * 0.8)
                    : Math.floor(attackerDamage * 0.8);
                const maxNormalDamage = Math.floor(defenderMaxHP * 0.2);
                const limitedDamage = Math.min(normalDamage, maxNormalDamage);

                if (defenderStates.shielded > 0) {
                    battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${defenderName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng th∆∞·ªùng!`);
                    defenderStates.shielded--;
                } else {
                    defenderHP -= limitedDamage;
                    totalDamageDealt.attacker += limitedDamage;
                    battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${limitedDamage.toLocaleString()} s√°t th∆∞∆°ng!`);

                    if (attackerStates.combo > 0) {
                        attackerStates.combo -= 1;
                    }
                }
            }
        }
        else if (attackerStates.stunned > 0) {
            battleLog.push(`üòµ ${attackerName} ƒëang b·ªã cho√°ng! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
            attackerStates.stunned--;

            attackerStates.combo = 0;
        } else if (attackerStates.bound > 0) {
            battleLog.push(`üîó ${attackerName} ƒëang b·ªã tr√≥i! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
            attackerStates.bound--;

            attackerStates.combo = 0;
        }


        if (defenderHP <= 0) {
            battleLog.push(`üí• ${defenderName} ƒë√£ b·ªã ƒë√°nh b·∫°i!`);
            break;
        }


        if (!defenderStates.stunned && !defenderStates.bound) {

            if (isPlayerDefender && defender.skills?.length > 0 && Math.random() < 0.78) {

                const skillChoice = selectBestSkill(
                    defender,
                    defenderHP,
                    defenderKi,
                    attackerHP,
                    defenderStates,
                    attackerStates,
                    battleLog,
                    turn
                ) || defender.skills[Math.floor(Math.random() * defender.skills.length)];

                const [master, skillName] = skillChoice.split(":");
                const skillData = MASTERS[master]?.skills[skillName];

                if (skillData) {
                    const skillDamage = Math.floor(defenderDamage * (skillData.powerScale || 0));
                    const kiRequired = Math.floor(defenderKi * Math.abs(skillData.kiCost || 0));

                    if (defenderKi >= kiRequired || (skillData.kiCost || 0) < 0) {

                        if (skillData.powerScale > 0) {
                            const actualDamage = defenderStates.powerBoosted > 0
                                ? Math.floor(skillDamage * defenderStates.powerBoostMultiplier)
                                : skillDamage;

                            if (attackerStates.shielded > 0) {
                                battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${attackerName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng!`);
                                attackerStates.shielded--;
                            } else {
                                attackerHP -= actualDamage;
                                totalDamageDealt.defender += actualDamage;

                                if (skillData.kiCost > 0) defenderKi -= kiRequired;

                                battleLog.push(
                                    `üéØ ${defenderName} d√πng ${skillData.name} g√¢y ${actualDamage.toLocaleString()} s√°t th∆∞∆°ng!` +
                                    (skillData.kiCost > 0 ? `\n‚ú® -${kiRequired} Ki` : "")
                                );
                            }
                        }
                        else if (skillData.kiCost < 0) {
                            const kiRestore = kiRequired;
                            defenderKi = Math.min(
                                isPlayerDefender ? defender.stats.ki : defenderKi * 2,
                                defenderKi + kiRestore
                            );
                            battleLog.push(`‚ú® ${defenderName} d√πng ${skillData.name}, h·ªìi ph·ª•c ${kiRestore.toLocaleString()} Ki!`);
                        }
                        else {

                            switch (skillName) {
                                case "SOLAR_FLARE":
                                case "HYPNOSIS":
                                    if (attackerSkillCooldowns[skillName] > 0) {
                                        battleLog.push(`‚ùå ${attackerName} kh√¥ng th·ªÉ d√πng ${skillName === "SOLAR_FLARE" ? "Th√°i D∆∞∆°ng H·∫° San" : "Th√¥i Mi√™n"} (c√≤n ${attackerSkillCooldowns[skillName]} l∆∞·ª£t h·ªìi)!`);
                                        const normalDamage = Math.floor(attackerDamage * 0.8);
                                        defenderHP -= normalDamage;
                                        totalDamageDealt.attacker += normalDamage;
                                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                    } else {
                                        defenderStates.stunned = 2;
                                        attackerKi -= kiRequired;
                                        attackerSkillCooldowns[skillName] = CONTROL_SKILL_COOLDOWN;
                                        battleLog.push(`üåÄ ${attackerName} d√πng ${skillName === "SOLAR_FLARE" ? "Th√°i D∆∞∆°ng H·∫° San" : "Th√¥i Mi√™n"}! ${defenderName} b·ªã cho√°ng trong 2 l∆∞·ª£t!`);
                                        defenderStates.combo = 0;
                                    }
                                    break;

                                case "KAIOKEN":
                                    defenderStates.powerBoosted = 3;
                                    defenderStates.powerBoostMultiplier = 3.0;
                                    defenderKi -= kiRequired;
                                    battleLog.push(`üî• ${defenderName} d√πng Kaioken! S·ª©c m·∫°nh tƒÉng x3 trong 3 l∆∞·ª£t!`);
                                    break;

                                case "BIND":

                                    if (attackerSkillCooldowns["BIND"] > 0) {
                                        battleLog.push(`‚ùå ${attackerName} kh√¥ng th·ªÉ d√πng Tr√≥i (c√≤n ${attackerSkillCooldowns["BIND"]} l∆∞·ª£t h·ªìi)!`);

                                        const normalDamage = Math.floor(attackerDamage * 0.8);
                                        defenderHP -= normalDamage;
                                        totalDamageDealt.attacker += normalDamage;
                                        battleLog.push(`üëä ${attackerName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                                    } else {

                                        defenderStates.bound = 2;
                                        attackerKi -= kiRequired;
                                        attackerSkillCooldowns["BIND"] = CONTROL_SKILL_COOLDOWN;
                                        battleLog.push(`üîó ${attackerName} d√πng Tr√≥i! ${defenderName} b·ªã tr√≥i 2 l∆∞·ª£t!`);
                                        defenderStates.combo = 0;
                                    }
                                    break;

                                case "ENERGY_SHIELD":
                                    attackerSkillCooldowns[skillName] = SHIELD_SKILL_COOLDOWN;
                                    const shieldDuration = 2;
                                    defenderStates.shielded = shieldDuration;
                                    defenderKi -= kiRequired;
                                    battleLog.push(`üõ°Ô∏è ${defenderName} t·∫°o Khi√™n NƒÉng L∆∞·ª£ng!`);
                                    break;

                                default:
                                    defenderKi -= kiRequired;
                                    battleLog.push(`‚ö° ${defenderName} d√πng ${skillData.name}!`);
                                    break;
                            }
                        }
                    } else {

                        const normalDamage = Math.floor(defenderDamage * 0.8);

                        if (attackerStates.shielded > 0) {
                            battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${attackerName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng!`);
                            attackerStates.shielded--;
                        } else {
                            attackerHP -= normalDamage;
                            totalDamageDealt.defender += normalDamage;
                            battleLog.push(`üëä ${defenderName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                        }
                    }
                } else {

                    const normalDamage = Math.floor(defenderDamage * 0.8);
                    attackerHP -= normalDamage;
                    totalDamageDealt.defender += normalDamage;
                    battleLog.push(`üëä ${defenderName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                }
            }
            else if (options.battleType === "MONSTER" || options.battleType === "CAMP") {

                const monsterAttack = Math.floor(defenderDamage * (0.8 + Math.random() * 0.4));


                if (turn % 3 === 0 && Math.random() < 0.4) {
                    const specialAttack = Math.floor(defenderDamage * 1.5);

                    if (attackerStates.shielded > 0) {
                        battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${attackerName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng ƒë·∫∑c bi·ªát!`);
                        attackerStates.shielded--;
                    } else {
                        attackerHP -= specialAttack;
                        totalDamageDealt.defender += specialAttack;
                        battleLog.push(`üí• ${defenderName} tung ra ƒë√≤n t·∫•n c√¥ng ƒë·∫∑c bi·ªát! G√¢y ${specialAttack.toLocaleString()} s√°t th∆∞∆°ng!`);
                    }
                } else {
                    if (attackerStates.shielded > 0) {
                        battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${attackerName} ƒë√£ ch·∫∑n ${monsterAttack.toLocaleString()} s√°t th∆∞∆°ng!`);
                        attackerStates.shielded--;
                    } else {
                        attackerHP -= monsterAttack;
                        totalDamageDealt.defender += monsterAttack;
                        battleLog.push(`üí• ${defenderName} t·∫•n c√¥ng g√¢y ${monsterAttack.toLocaleString()} s√°t th∆∞∆°ng!`);
                    }
                }
            } else {

                const normalDamage = defenderStates.powerBoosted > 0
                    ? Math.floor(defenderDamage * defenderStates.powerBoostMultiplier * 0.8)
                    : Math.floor(defenderDamage * 0.8);

                if (attackerStates.shielded > 0) {
                    battleLog.push(`üõ°Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${attackerName} ƒë√£ ch·∫∑n ƒë√≤n t·∫•n c√¥ng th∆∞·ªùng!`);
                    attackerStates.shielded--;
                } else {
                    attackerHP -= normalDamage;
                    totalDamageDealt.defender += normalDamage;
                    battleLog.push(`üëä ${defenderName} ƒë·∫•m th∆∞·ªùng g√¢y ${normalDamage.toLocaleString()} s√°t th∆∞∆°ng!`);
                }
            }
        }
        else if (defenderStates.stunned > 0) {
            battleLog.push(`üòµ ${defenderName} ƒëang b·ªã cho√°ng! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
            defenderStates.stunned--;
            defenderStates.combo = 0;
        } else if (defenderStates.bound > 0) {
            battleLog.push(`üîó ${defenderName} ƒëang b·ªã tr√≥i! Kh√¥ng th·ªÉ h√†nh ƒë·ªông!`);
            defenderStates.bound--;
            defenderStates.combo = 0;
        }


        updateStates(attackerName, attackerStates, battleLog);
        updateStates(defenderName, defenderStates, battleLog);


        if (turn % 3 === 0) {
            const attackerHPPercent = (attackerHP / attackerMaxHP) * 100;
            const defenderHPPercent = (defenderHP / defenderMaxHP) * 100;

            if (attackerHPPercent > defenderHPPercent + 20) {
                battleContext.momentum = Math.min(battleContext.momentum + 1, 5);
                if (battleContext.momentum >= 3) {
                    battleLog.push(`‚ö° ${attackerName} ƒëang chi·∫øm ∆∞u th·∫ø trong tr·∫≠n ƒë·∫•u!`);
                }
            } else if (defenderHPPercent > attackerHPPercent + 20) {
                battleContext.momentum = Math.max(battleContext.momentum - 1, -5);
                if (battleContext.momentum <= -3) {
                    battleLog.push(`‚ö° ${defenderName} ƒëang chi·∫øm ∆∞u th·∫ø trong tr·∫≠n ƒë·∫•u!`);
                }
            }
        }


        if (turn === Math.floor(maxTurns / 2)) {
            battleLog.push(`üî• Tr·∫≠n ƒë·∫•u ƒë√£ ƒëi qua n·ª≠a th·ªùi gian! S·ª©c m·∫°nh c·ªßa c·∫£ hai ƒëang tr·ªü n√™n kinh kh·ªßng!`);
        }

        if (turn === maxTurns - 5) {
            battleLog.push(`‚è±Ô∏è Ch·ªâ c√≤n 5 l∆∞·ª£t n·ªØa tr·∫≠n ƒë·∫•u s·∫Ω k·∫øt th√∫c! H√£y t·∫≠p trung s·ª©c l·ª±c!`);
        }
    }


    let winner, loser;

    if (attackerHP <= 0 && defenderHP <= 0) {
        if (options.battleType === "MONSTER" || options.battleType === "CAMP") {
            winner = isPlayerAttacker ? attacker : defender;
            loser = isPlayerAttacker ? defender : attacker;
            battleLog.push(`‚öîÔ∏è Tr·∫≠n ƒë·∫•u k·∫øt th√∫c v·ªõi c·∫£ hai ƒë·ªÅu ng√£ xu·ªëng, ${winner.name} th·∫Øng do ra ƒë√≤n cu·ªëi c√πng!`);
        } else {
            winner = isPlayerAttacker ? attacker : defender;
            loser = isPlayerAttacker ? defender : attacker;
        }
    }
    else if (attackerHP <= 0) {
        winner = defender;
        loser = attacker;
    }
    else if (defenderHP <= 0) {
        winner = attacker;
        loser = defender;
    }
    else if (turn >= maxTurns) {
        const attackerHPPercent = attackerHP / attackerMaxHP;
        const defenderHPPercent = defenderHP / defenderMaxHP;

        if (attackerHPPercent > defenderHPPercent) {
            winner = attacker;
            loser = defender;
        } else {
            winner = defender;
            loser = attacker;
        }

        battleLog.push(`‚è±Ô∏è H·∫øt ${maxTurns} l∆∞·ª£t! ${winner.name} gi√†nh chi·∫øn th·∫Øng v·ªõi l∆∞·ª£ng HP c√≤n l·∫°i nhi·ªÅu h∆°n!`);
    }


    if (turn >= maxTurns) {
        battleLog.push(`üèÅ H·∫øt ${maxTurns} l∆∞·ª£t! ${winner.name} gi√†nh chi·∫øn th·∫Øng!`);
    }


    let attackerKiRestored = attackerKi;
    let defenderKiRestored = defenderKi;

    if (isPlayerAttacker) {
        const kiLost = originalAttackerKi - attackerKi;
        attackerKiRestored = Math.min(originalAttackerKi, attackerKi + Math.floor(kiLost * 0.6));
    }

    if (isPlayerDefender) {
        const kiLost = originalDefenderKi - defenderKi;
        defenderKiRestored = Math.min(originalDefenderKi, defenderKi + Math.floor(kiLost * 0.6));
    }


    return {
        winner,
        loser,
        player1HP: Math.max(0, attackerHP),
        player2HP: Math.max(0, defenderHP),
        player1Ki: attackerKiRestored,
        player2Ki: defenderKiRestored,
        battleLog,
        isDraw: turn >= maxTurns && attackerHP > 0 && defenderHP > 0,
        turns: turn,
        totalDamage: totalDamageDealt,
        initialHP: {
            attacker: initialAttackerHP,
            defender: initialDefenderHP
        },
        battleStats: {
            duration: Date.now() - battleContext.battleStartTime,
            momentum: battleContext.momentum,
            maxCombo: Math.max(
                Math.max(...battleLog.filter(log => log.includes("Combo")).map(log => {
                    const match = log.match(/Combo x(\d+)/);
                    return match ? parseInt(match[1]) : 0;
                }), 0),
                0
            )
        }
    };
}

function findPlayerMatch(tournamentData, playerId) {
    if (!tournamentData?.active?.matches) return null;

    return tournamentData.active.matches.find(match => {
        const isPlayer =
            (match.player1?.id === playerId || match.player2?.id === playerId) &&
            !match.completed;

        const isScheduledTime = match.scheduledTime <= Date.now();

        return isPlayer && isScheduledTime;
    });
}

function isPlayerInTournament(tournamentData, playerId) {
    return !!tournamentData.registrations[playerId];
}

function getPlayerNextMatch(tournamentData, playerId) {
    if (!tournamentData?.active?.matches) return null;

    return tournamentData.active.matches.find(match => {
        const isPlayer = match.player1?.id === playerId || match.player2?.id === playerId;
        const isPending = !match.completed;
        return isPlayer && isPending;
    });
}

function getTournamentRoundInfo(match) {
    if (!match) return null;

    const roundNames = {
        1: "V√≤ng lo·∫°i",
        2: "V√≤ng 1/16",
        3: "V√≤ng 1/8",
        4: "T·ª© k·∫øt",
        5: "B√°n k·∫øt",
        6: "Chung k·∫øt"
    };

    return {
        number: match.round,
        name: roundNames[match.round] || `V√≤ng ${match.round}`
    };
}
function updateStates(entityName, states, battleLog) {
    if (states.powerBoosted > 0) {
        states.powerBoosted--;
        if (states.powerBoosted === 0) {
            battleLog.push(`‚ö†Ô∏è Hi·ªáu ·ª©ng Kaioken c·ªßa ${entityName} ƒë√£ h·∫øt!`);
            states.powerBoostMultiplier = 1.0;
        }
    }

    if (states.greatApe > 0) {
        states.greatApe--;
        if (states.greatApe === 0) {
            battleLog.push(`‚ö†Ô∏è ${entityName} ƒë√£ tr·ªü l·∫°i h√¨nh d·∫°ng b√¨nh th∆∞·ªùng!`);
            states.powerBoostMultiplier = 1.0;
            states.powerBoosted = 0;
        }
    }

    if (states.shielded > 0) {
        states.shielded--;
        if (states.shielded === 0) {
            battleLog.push(`‚ö†Ô∏è Khi√™n nƒÉng l∆∞·ª£ng c·ªßa ${entityName} ƒë√£ bi·∫øn m·∫•t!`);
        }
    }
}
function validatePlayerSkills(player) {
    if (!player || !player.skills || player.skills.length === 0) return;

    const validSkills = player.skills.filter(skillChoice => {
        const [master, skillName] = skillChoice.split(":");
        if (!MASTERS[master] || !MASTERS[master].skills[skillName]) {
            console.log(`K·ªπ nƒÉng kh√¥ng t·ªìn t·∫°i: ${skillChoice}`);
            return false;
        }

        const skillData = MASTERS[master].skills[skillName];
        return player.stats.power >= skillData.powerRequired;
    });

    if (validSkills.length < player.skills.length) {
        const removedSkills = player.skills.filter(skill => !validSkills.includes(skill));
        const removedNames = removedSkills.map(skill => {
            const [master, skillName] = skill.split(":");
            if (MASTERS[master] && MASTERS[master].skills[skillName]) {
                return MASTERS[master].skills[skillName].name;
            } else {
                return skill;
            }
        });

        console.log(`Ng∆∞·ªùi ch∆°i ${player.name} b·ªã lo·∫°i b·ªè ${removedSkills.length} k·ªπ nƒÉng: ${removedNames.join(", ")}`);
        player.skills = validSkills;
        return removedNames;
    }

    return null;
}
function canUseSkill(skillName, skillData, currentTurn, playerHP, playerMaxHP, playerKi, playerMaxKi) {

    if (skillName === "SPIRIT_BOMB") {
        if (currentTurn < 25) {
            return {
                canUse: false,
                reason: "EARLY_TURN",
                message: "Qu·∫£ C·∫ßu Kinh Kh√≠ c·∫ßn √≠t nh·∫•t 25 l∆∞·ª£t ƒë·ªÉ t√≠ch t·ª• ƒë·ªß nƒÉng l∆∞·ª£ng!"
            };
        }

        if (playerKi < Math.floor(playerMaxKi * skillData.kiCost)) {
            return {
                canUse: false,
                reason: "KI_TOO_LOW",
                message: "Kh√¥ng ƒë·ªß Ki ƒë·ªÉ s·ª≠ d·ª•ng Qu·∫£ C·∫ßu Kinh Kh√≠!"
            };
        }

        return {
            canUse: true,
            reason: null
        };
    }

    return {
        canUse: playerKi >= Math.floor(playerMaxKi * (skillData.kiCost || 0)),
        reason: playerKi < Math.floor(playerMaxKi * (skillData.kiCost || 0)) ? "KI_TOO_LOW" : null
    };
}
function checkTournamentQuest(player, tournamentData, matchResult) {
    if (!player.quests?.active) {
        validatePlayerQuests(player);
    }

    const activeQuestId = player.quests.active[0];
    if (!activeQuestId || !QUESTS[activeQuestId]) {
        console.log("No active quest found for player:", player.name);
        return;
    }

    const quest = QUESTS[activeQuestId];
    if (quest.type !== "TOURNAMENT") {
        console.log("Active quest is not a tournament quest");
        return;
    }

    const playerRank = getTournamentRank(tournamentData, player.id);
    console.log(`Player ${player.name} achieved rank ${playerRank} in tournament`);

    let shouldComplete = false;

    switch (activeQuestId) {
        case "TOURNAMENT_BEGINNER":
            if (playerRank <= 8) {
                shouldComplete = true;
                console.log("Player completed TOURNAMENT_BEGINNER quest");
            }
            break;

        case "TOURNAMENT_TENKAICHI":
            if (playerRank <= 4) {
                shouldComplete = true;
                console.log("Player completed TOURNAMENT_TENKAICHI quest");
            }
            break;

        case "TOURNAMENT_CELL":
            if (playerRank <= 2) {
                shouldComplete = true;
                console.log("Player completed TOURNAMENT_CELL quest");
            }
            break;

        case "TOURNAMENT_UNIVERSE":
            if (playerRank === 1) {
                shouldComplete = true;
                console.log("Player completed TOURNAMENT_UNIVERSE quest");
            }
            break;

        default:
            console.log("Unknown tournament quest type:", activeQuestId);
            return;
    }

    if (shouldComplete) {
        player.quests.progress[activeQuestId] = quest.target;

        if (quest.reward) {
            if (quest.reward.exp) {
                player.stats.exp = Math.min(
                    player.stats.exp + quest.reward.exp,
                    MAX_EXP_STORAGE
                );
            }

            if (quest.reward.zeni) {
                player.stats.zeni += quest.reward.zeni;
            }

            if (quest.reward.item) {
                if (!player.inventory) player.inventory = { items: [] };
                if (!player.inventory.items) player.inventory.items = [];

                const existingItem = player.inventory.items.find(i => i.id === quest.reward.item);
                if (existingItem) {
                    existingItem.quantity += (quest.reward.quantity || 1);
                } else {
                    player.inventory.items.push({
                        id: quest.reward.item,
                        name: SHOP_ITEMS[quest.reward.item.toUpperCase()]?.name || quest.reward.item,
                        quantity: quest.reward.quantity || 1,
                        type: SHOP_ITEMS[quest.reward.item.toUpperCase()]?.type || "quest_item"
                    });
                }
            }
        }

        const tournamentProgression = ["TOURNAMENT_BEGINNER", "TOURNAMENT_TENKAICHI", "TOURNAMENT_CELL", "TOURNAMENT_UNIVERSE"];
        const currentIndex = tournamentProgression.indexOf(activeQuestId);

        player.quests.completed.push(activeQuestId);
        player.quests.active = [];

        if (currentIndex >= 0 && currentIndex < tournamentProgression.length - 1) {
            const nextQuestId = tournamentProgression[currentIndex + 1];
            if (QUESTS[nextQuestId]) {
                player.quests.active.push(nextQuestId);
                player.quests.progress[nextQuestId] = 0;
                console.log(`Assigned next tournament quest: ${nextQuestId} to player: ${player.name}`);
            }
        }

        return true;
    }

    return false;
}
function getTournamentRank(tournamentData, playerId) {
    const matches = tournamentData.matches || [];
    let rank = 1;

    const lastMatch = matches
        .filter(m => m.completed && m.loser?.id === playerId)
        .sort((a, b) => b.round - a.round)[0];

    if (!lastMatch) return 1;

    switch (lastMatch.round) {
        case 1: rank = 16; break;
        case 2: rank = 8; break;
        case 3: rank = 4; break;
        case 4: rank = 2; break;
        default: rank = 16;
    }

    return rank;
}
function getPlayerTournamentRank(playerId, tournamentData) {
    if (!tournamentData.active?.rounds) return null;

    if (tournamentData.active.winners?.first?.id === playerId) return 1;

    if (tournamentData.active.winners?.second?.id === playerId) return 2;

    if (tournamentData.active.winners?.semifinalists?.some(p => p.id === playerId)) return 4;

    const totalRounds = tournamentData.active.rounds.length;
    const quarterFinalRound = totalRounds - 2;
    if (tournamentData.active.rounds[quarterFinalRound]?.some(
        match => match.player1?.id === playerId || match.player2?.id === playerId
    )) return 8;

    return null;
}

function selectRandomMonster(planet, playerLevel) {
    const planetMonsters = Object.entries(MONSTERS)
        .filter(([_, monster]) => monster.planet === planet)
        .map(([id, monster]) => ({ id, ...monster }));

    if (planetMonsters.length === 0) {
        return null;
    }

    const easyMonsters = planetMonsters.filter(m => m.power < 1000);
    const mediumMonsters = planetMonsters.filter(m => m.power >= 1000 && m.power < 5000);
    const hardMonsters = planetMonsters.filter(m => m.power >= 5000);

    let availableMonsters;
    if (playerLevel < 5) {
        availableMonsters = easyMonsters;
    } else if (playerLevel < 10) {
        availableMonsters = [...easyMonsters, ...mediumMonsters];
    } else {
        availableMonsters = [...mediumMonsters, ...hardMonsters];
    }

    if (availableMonsters.length === 0) {
        availableMonsters = planetMonsters;
    }

    const randomIndex = Math.floor(Math.random() * availableMonsters.length);
    return availableMonsters[randomIndex];
}

function getVisualEffectForItem(itemId) {
    const effectMap = {
        "scouter": {
            type: "overlay",
            position: "face",
            color: "#FF0000"
        },
        "armor": {
            type: "overlay",
            position: "body",
            color: "#FFFFFF"
        },
        "radar": {
            type: "accessory",
            position: "hand",
            color: "#00FF00"
        },
        "crystal": {
            type: "aura",
            position: "body",
            color: "#80C0FF"
        },
        "tournament_belt": {
            type: "accessory",
            position: "waist",
            color: "#FFD700"
        },
        "cell_medal": {
            type: "accessory",
            position: "chest",
            color: "#C0C0C0"
        },
        "universe_medal": {
            type: "aura",
            position: "body",
            color: "#FFFF00"
        }
    };

    return effectMap[itemId] || null;
}
function applyAmuletEffects(player, stats) {
    if (!player.amulets || player.amulets.length === 0) {
        return {
            applied: false,
            effects: []
        };
    }


    const activeAmulets = player.amulets.filter(amulet => amulet.expireAt > Date.now());

    if (activeAmulets.length === 0) {
        return {
            applied: false,
            effects: []
        };
    }

    const appliedEffects = [];


    for (const amulet of activeAmulets) {
        switch (amulet.effect) {
            case 'immortal':
                stats.immortal = true;
                appliedEffects.push({
                    name: amulet.name,
                    effect: 'B·∫•t t·ª≠ t·∫°m th·ªùi',
                    emoji: amulet.emoji || 'üîÆ'
                });
                break;

            case 'damage_boost':
                const damageBoost = amulet.boost || 1.5;
                stats.playerDamage = (stats.playerDamage || 0) * damageBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng s√°t th∆∞∆°ng x${damageBoost}`,
                    emoji: amulet.emoji || '‚öîÔ∏è'
                });
                break;

            case 'health_boost':
                const healthBoost = amulet.boost || 1.5;
                stats.playerHP = (stats.playerHP || 0) * healthBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng HP x${healthBoost}`,
                    emoji: amulet.emoji || '‚ù§Ô∏è'
                });
                break;

            case 'ki_boost':
                const kiBoost = amulet.boost || 1.5;
                stats.playerKi = (stats.playerKi || 0) * kiBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng Ki x${kiBoost}`,
                    emoji: amulet.emoji || '‚ú®'
                });
                break;

            case 'exp_boost':
                const expBoost = amulet.boost || 2.0;
                stats.expMultiplier *= expBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng EXP x${expBoost}`,
                    emoji: amulet.emoji || 'üìä'
                });
                break;

            case 'power_boost':
                const powerBoost = amulet.boost || 1.5;
                stats.powerMultiplier *= powerBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng s·ª©c m·∫°nh x${powerBoost}`,
                    emoji: amulet.emoji || 'üí™'
                });
                break;

            case 'zeni_boost':
                const zeniBoost = amulet.boost || 1.5;
                stats.zeniMultiplier *= zeniBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng Zeni x${zeniBoost}`,
                    emoji: amulet.emoji || 'üí∞'
                });
                break;

            case 'all_stats':
                const allStatsBoost = amulet.boost || 1.3;
                stats.playerHP = (stats.playerHP || 0) * allStatsBoost;
                stats.playerKi = (stats.playerKi || 0) * allStatsBoost;
                stats.playerDamage = (stats.playerDamage || 0) * allStatsBoost;
                stats.expMultiplier *= allStatsBoost;
                stats.powerMultiplier *= allStatsBoost;
                stats.zeniMultiplier *= allStatsBoost;
                appliedEffects.push({
                    name: amulet.name,
                    effect: `TƒÉng t·∫•t c·∫£ ch·ªâ s·ªë x${allStatsBoost}`,
                    emoji: amulet.emoji || 'üåü'
                });
                break;

            default:

                console.log(`Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c hi·ªáu ·ª©ng b√πa: ${amulet.effect}`);
                break;
        }
    }

    console.log(`√Åp d·ª•ng ${appliedEffects.length} hi·ªáu ·ª©ng b√πa cho ng∆∞·ªùi ch∆°i ${player.name}`);
    console.log(`Sau khi √°p d·ª•ng: expMultiplier = ${stats.expMultiplier}, powerMultiplier = ${stats.powerMultiplier}`);

    return {
        applied: appliedEffects.length > 0,
        effects: appliedEffects
    };
}

function updateQuestProgress(player, questType, playerData = null, additionalData = {}) {
    if (!player.quests?.active || player.quests.active.length === 0) {
        validatePlayerQuests(player);
    }

    const activeQuestId = player.quests.active[0];
    if (!activeQuestId || !QUESTS[activeQuestId]) return;

    const quest = QUESTS[activeQuestId];
    if (quest.type !== questType) return;

    let updated = false;

    switch (questType) {
        case QUEST_TYPES.TRAINING:
            if (!player.quests.progress[activeQuestId]) {
                player.quests.progress[activeQuestId] = 0;
            }
            player.quests.progress[activeQuestId]++;
            updated = true;
            break;

        case QUEST_TYPES.TOURNAMENT:
            if (additionalData?.tournamentRank && additionalData?.tournamentType) {
                if (activeQuestId === "TOURNAMENT_BEGINNER" && additionalData.tournamentRank <= 8) {
                    player.quests.progress[activeQuestId] = 1;
                    updated = true;
                } else if (activeQuestId === "TOURNAMENT_TENKAICHI" && additionalData.tournamentRank <= 4) {
                    player.quests.progress[activeQuestId] = 1;
                    updated = true;
                } else if (activeQuestId === "TOURNAMENT_CELL" && additionalData.tournamentRank <= 2) {
                    player.quests.progress[activeQuestId] = 1;
                    updated = true;
                }
            }
            break;

        case QUEST_TYPES.COMBAT:
            if (additionalData?.monster && quest.monster === additionalData.monster) {
                if (!player.quests.progress[activeQuestId]) {
                    player.quests.progress[activeQuestId] = 0;
                }
                player.quests.progress[activeQuestId]++;
                updated = true;
            }
            break;

        case QUEST_TYPES.POWER:
            if (player.stats.power >= quest.target) {
                player.quests.progress[activeQuestId] = quest.target;
                updated = true;
            }
            break;

        case QUEST_TYPES.COLLECT:
            if (quest.itemType === "dragonBall") {
                const ballCount = player.inventory?.dragonBalls?.length || 0;
                if (ballCount >= quest.target) {
                    player.quests.progress[activeQuestId] = quest.target;
                    updated = true;
                }
            }
            break;
    }

    if (updated && playerData) {
        savePlayerData(playerData);
    }

    if (player.quests.progress[activeQuestId] >= quest.target) {
        console.log(`T·ª± ƒë·ªông ho√†n th√†nh nhi·ªám v·ª•: ${quest.name} cho player: ${player.name}`);

        if (quest.reward.exp) {
            player.stats.exp += quest.reward.exp;
            if (player.stats.exp > MAX_EXP_STORAGE) {
                player.stats.exp = MAX_EXP_STORAGE;
            }
        }

        if (quest.reward.zeni) {
            player.stats.zeni += quest.reward.zeni;
        }

        if (quest.reward.item) {
            if (!player.inventory) player.inventory = { items: [] };
            if (!player.inventory.items) player.inventory.items = [];

            const existingItem = player.inventory.items.find(i => i.id === quest.reward.item);
            if (existingItem) {
                existingItem.quantity += (quest.reward.quantity || 1);
            } else {
                const itemType = SHOP_ITEMS[quest.reward.item.toUpperCase()]?.type || "quest_item";
                player.inventory.items.push({
                    id: quest.reward.item,
                    quantity: quest.reward.quantity || 1,
                    type: itemType
                });
            }
        }

        player.quests.completed.push(activeQuestId);
        player.quests.active = [];


        if (activeQuestId.startsWith("TOURNAMENT_")) {

            const tournamentProgression = ["TOURNAMENT_BEGINNER", "TOURNAMENT_TENKAICHI", "TOURNAMENT_CELL", "TOURNAMENT_UNIVERSE"];
            const currentIndex = tournamentProgression.indexOf(activeQuestId);

            if (currentIndex >= 0 && currentIndex < tournamentProgression.length - 1) {
                const nextTournamentQuest = tournamentProgression[currentIndex + 1];
                if (QUESTS[nextTournamentQuest]) {
                    player.quests.active.push(nextTournamentQuest);
                    player.quests.progress[nextTournamentQuest] = 0;
                    console.log(`ƒê√£ g√°n nhi·ªám v·ª• gi·∫£i ƒë·∫•u m·ªõi: ${QUESTS[nextTournamentQuest].name} cho player: ${player.name}`);
                }
            }
        } else {

            const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
            if (planetQuests && player.quests.completed.length < planetQuests.length) {
                const nextQuestId = planetQuests[player.quests.completed.length];
                if (QUESTS[nextQuestId]) {
                    console.log(`ƒê√£ g√°n nhi·ªám v·ª• m·ªõi: ${QUESTS[nextQuestId].name} cho player: ${player.name}`);
                    player.quests.active.push(nextQuestId);
                    player.quests.progress[nextQuestId] = 0;
                }
            }
        }

        if (player.quests.completed.length % 3 === 0) {
            if (!player.stats.level) player.stats.level = 1;
            player.stats.level += 1;
        }

        if (playerData) {
            savePlayerData(playerData);
        }
    } else if (updated && playerData) {
        savePlayerData(playerData);
    }
}

function completeQuest(player, playerData, questId) {
    const quest = QUESTS[questId];
    if (!quest) {
        console.error(`Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• v·ªõi ID: ${questId}`);
        return;
    }

    if (quest.reward.exp) {
        player.stats.exp += quest.reward.exp;
        if (player.stats.exp > MAX_EXP_STORAGE) {
            player.stats.exp = MAX_EXP_STORAGE;
        }
    }

    if (quest.reward.zeni) {
        player.stats.zeni += quest.reward.zeni;
    }

    if (quest.reward.item) {
        if (!player.inventory) player.inventory = { items: [] };
        if (!player.inventory.items) player.inventory.items = [];

        if (quest.reward.item) {
            const existingItem = player.inventory.items.find(i => i.id === quest.reward.item);
            if (existingItem) {
                existingItem.quantity += (quest.reward.quantity || 1);
            } else {
                const itemType = SHOP_ITEMS[quest.reward.item.toUpperCase()]?.type || "quest_item";
                player.inventory.items.push({
                    id: quest.reward.item,
                    quantity: quest.reward.quantity || 1,
                    type: itemType
                });
            }
        }
    }

    player.quests.completed.push(questId);
    player.quests.active.shift();

    if (questId.startsWith("TOURNAMENT_")) {

        const tournamentProgression = ["TOURNAMENT_BEGINNER", "TOURNAMENT_TENKAICHI", "TOURNAMENT_CELL", "TOURNAMENT_UNIVERSE"];
        const currentIndex = tournamentProgression.indexOf(questId);

        if (currentIndex >= 0 && currentIndex < tournamentProgression.length - 1) {
            const nextTournamentQuest = tournamentProgression[currentIndex + 1];
            if (QUESTS[nextTournamentQuest]) {

                player.quests.active.push(nextTournamentQuest);
                player.quests.progress[nextTournamentQuest] = 0;
            }
        }
    } else {

        const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
        if (planetQuests && player.quests.completed.length < planetQuests.length) {
            const nextQuestId = planetQuests[player.quests.completed.length];
            if (QUESTS[nextQuestId]) {
                player.quests.active.push(nextQuestId);
                player.quests.progress[nextQuestId] = 0;
            } else {
                console.error(`Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• ti·∫øp theo: ${nextQuestId}`);
            }
        }
    }

    if (player.quests.completed.length % 3 === 0) {
        if (!player.stats.level) player.stats.level = 1;
        player.stats.level += 1;
    }

    savePlayerData(playerData);
}

function checkStatLimit(value, type) {
    const limit = STAT_LIMITS[type];
    return value > limit ? limit : value;
}


function getTrainingLocation(power) {
    if (power >= 50000000000) return TRAINING_LOCATIONS.DESTROYER;
    if (power >= 50000000) return TRAINING_LOCATIONS.KAIOSHIN;
    if (power >= 5000000) return TRAINING_LOCATIONS.UNIVERSE_GOD;
    if (power >= 500000) return TRAINING_LOCATIONS.KAMI;
    if (power >= 100000) return TRAINING_LOCATIONS.KORIN;
    return TRAINING_LOCATIONS.DEFAULT;
}

function loadTournamentData() {
    try {
        return JSON.parse(fs.readFileSync(TOURNAMENT_DB));
    } catch (err) {
        return {
            active: null,
            history: [],
            registrations: {}
        };
    }
}

function fixPlayerQuestProgression(player) {
    if (player.quests && player.quests.progress && player.quests.progress["BASIC_TRAINING"]) {

        delete player.quests.progress["BASIC_TRAINING"];

        if (player.quests.completed) {
            const basicTrainingIndex = player.quests.completed.indexOf("BASIC_TRAINING");
            if (basicTrainingIndex !== -1) {
                player.quests.completed.splice(basicTrainingIndex, 1);
            }
        }

        if (player.quests.active) {
            player.quests.active = player.quests.active.filter(questId => questId !== "BASIC_TRAINING");

            if (player.quests.active.length === 0) {
                const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
                if (planetQuests && player.quests.completed.length < planetQuests.length) {
                    const nextQuestId = planetQuests[player.quests.completed.length];
                    if (QUESTS[nextQuestId]) {
                        player.quests.active.push(nextQuestId);
                        player.quests.progress[nextQuestId] = 0;
                    }
                }
            }
        }

        console.log("ƒê√£ s·ª≠a ti·∫øn tr√¨nh nhi·ªám v·ª• cho ng∆∞·ªùi ch∆°i");
    }
}

function addMissingQuests() {
    if (typeof QUESTS !== 'undefined') {
        if (!QUESTS["BASIC_TRAINING"]) {
            QUESTS["BASIC_TRAINING"] = {
                id: "BASIC_TRAINING",
                name: "Luy·ªán T·∫≠p C∆° B·∫£n",
                description: "Luy·ªán t·∫≠p ƒë·ªÉ tƒÉng c∆∞·ªùng s·ª©c m·∫°nh",
                type: "TRAINING",
                target: 10,
                reward: {
                    exp: 1000,
                    zeni: 500,
                    description: "1,000 EXP, 500 Zeni"
                }
            };

            console.log("ƒê√£ th√™m nhi·ªám v·ª• BASIC_TRAINING v√†o danh s√°ch QUESTS");
        }
    }
}
function saveTournamentData(data) {
    fs.writeFileSync(TOURNAMENT_DB, JSON.stringify(data, null, 2));
}

function updateTournamentBracket(tournamentData) {
    if (!tournamentData.active) return;

    const currentRound = tournamentData.active.currentRound;
    let allMatchesCompleted = true;

    if (tournamentData.active.rounds[currentRound]) {
        for (const match of tournamentData.active.rounds[currentRound]) {
            if (!match.completed) {
                allMatchesCompleted = false;
                break;
            }
        }
    }


    if (allMatchesCompleted && tournamentData.active.rounds[currentRound]?.length > 1) {
        const nextRound = currentRound + 1;
        const currentMatches = tournamentData.active.rounds[currentRound];
        tournamentData.active.rounds[nextRound] = [];


        for (let i = 0; i < currentMatches.length; i += 2) {
            if (i + 1 < currentMatches.length) {
                const match = {
                    id: Math.floor(i / 2) + 1,
                    round: nextRound,
                    player1: currentMatches[i].winner,
                    player2: currentMatches[i + 1].winner,
                    winner: null,
                    loser: null,
                    completed: false,
                    scheduledTime: Date.now() + (Math.floor(i / 2) + 1) * 300000
                };

                tournamentData.active.rounds[nextRound].push(match);
                tournamentData.active.matches.push(match);
            }
        }


        if (nextRound === Math.log2(Object.keys(tournamentData.registrations).length)) {
            tournamentData.active.winners.semifinalists = [
                currentMatches[0].loser,
                currentMatches[1].loser
            ];
        }


        if (tournamentData.active.rounds[nextRound].length === 1) {
            const finalMatch = tournamentData.active.rounds[nextRound][0];
            finalMatch.isFinal = true;
        }

        tournamentData.active.currentRound = nextRound;
    }


    if (allMatchesCompleted &&
        tournamentData.active.rounds[currentRound].length === 1 &&
        tournamentData.active.rounds[currentRound][0].completed) {

        const finalMatch = tournamentData.active.rounds[currentRound][0];

        tournamentData.active.winners.first = finalMatch.winner;
        tournamentData.active.winners.second = finalMatch.loser;
        tournamentData.active.status = "completed";
        tournamentData.active.endTime = Date.now();


        const playerData = loadPlayerData();
        const rewards = TOURNAMENT_TYPES[tournamentData.active.type].rewards;


        if (playerData[finalMatch.winner.id]) {
            const winner = playerData[finalMatch.winner.id];
            winner.stats.exp += rewards.first.exp;
            winner.stats.zeni += rewards.first.zeni;

            if (rewards.first.item) {
                if (!winner.inventory) winner.inventory = { items: [] };
                if (!winner.inventory.items) winner.inventory.items = [];

                const existingItem = winner.inventory.items.find(item => item.id === rewards.first.item);
                if (existingItem) {
                    existingItem.quantity += 1;
                } else {
                    winner.inventory.items.push({
                        id: rewards.first.item,
                        quantity: 1,
                        type: "trophy"
                    });
                }
            }
        }


        if (playerData[finalMatch.loser.id]) {
            const second = playerData[finalMatch.loser.id];
            second.stats.exp += rewards.second.exp;
            second.stats.zeni += rewards.second.zeni;
        }


        tournamentData.active.winners.semifinalists.forEach(player => {
            if (player && playerData[player.id]) {
                const semifinalist = playerData[player.id];
                semifinalist.stats.exp += rewards.semifinal.exp;
                semifinalist.stats.zeni += rewards.semifinal.zeni;
            }
        });


        tournamentData.history.push({
            type: tournamentData.active.type,
            startTime: tournamentData.active.startTime,
            endTime: tournamentData.active.endTime,
            organizer: tournamentData.active.organizer,
            participants: Object.keys(tournamentData.registrations).length,
            winners: {
                first: tournamentData.active.winners.first,
                second: tournamentData.active.winners.second,
                semifinalists: tournamentData.active.winners.semifinalists
            }
        });

        savePlayerData(playerData);
    }
}
function getAuraColorForEvolution(evolutionName, planet) {

    const auraColors = {
        EARTH: {
            "Con ng∆∞·ªùi th∆∞·ªùng": "#FFFFFF",
            "Chi·∫øn Binh Z": "#4080FF",
            "B·∫≠c Th·∫ßy Kh√≠": "#0040FF",
            "Si√™u Chi·∫øn Binh": "#00FFFF",
            "Ti·ªÅm NƒÉng Khai Ph√°": "#FFFFFF",
            "Ch√≠ T√¥n Tr√°i ƒê·∫•t": "#80C0FF"
        },
        NAMEK: {
            "Namek th∆∞·ªùng": "#80FF80",
            "Namek Warrior": "#40C040",
            "Super Namek": "#00FF00",
            "Namek Fusion": "#00C000"
        },
        SAIYAN: {
            "Saiyan th∆∞·ªùng": "#FFFFFF",
            "Super Saiyan": "#FFD700",
            "Super Saiyan 2": "#FFA500",
            "Super Saiyan 3": "#FF8000",
            "Super Saiyan God": "#FF0000",
            "Ultra Instinct": "#C0C0FF"
        }
    };

    return auraColors[planet]?.[evolutionName] || "#FFFFFF";
}
function checkAndUpdateEvolution(player) {
    if (!EVOLUTION_SYSTEM[player.planet]) {
        return false;
    }

    const evolutionForms = EVOLUTION_SYSTEM[player.planet].forms;
    if (!evolutionForms || evolutionForms.length === 0) {
        return false;
    }

    let highestForm = evolutionForms[0];
    for (let i = 1; i < evolutionForms.length; i++) {
        if (player.stats.power >= evolutionForms[i].powerRequired) {
            highestForm = evolutionForms[i];
        } else {
            break;
        }
    }


    const oldPower = player.stats.power;
    const oldDamage = player.stats.damage;
    const oldKi = player.stats.ki;
    const oldHealth = player.stats.health;


    if (!player.evolution || player.evolution.name !== highestForm.name) {

        const oldLevel = player.evolution ? player.evolution.level : -1;
        const newLevel = highestForm.level;


        if (player.evolution && oldLevel >= 0 && evolutionForms[oldLevel]) {
            const oldForm = evolutionForms[oldLevel];

            player.stats.power = Math.floor(player.stats.power / oldForm.powerBonus);
            player.stats.damage = Math.floor(player.stats.damage / oldForm.damageBonus);
            player.stats.ki = Math.floor(player.stats.ki / oldForm.kiBonus);
            player.stats.health = Math.floor(player.stats.health / oldForm.healthBonus);
        }


        player.stats.power = Math.floor(player.stats.power * highestForm.powerBonus);
        player.stats.damage = Math.floor(player.stats.damage * highestForm.damageBonus);
        player.stats.ki = Math.floor(player.stats.ki * highestForm.kiBonus);
        player.stats.health = Math.floor(player.stats.health * highestForm.healthBonus);


        player.stats.currentHealth = player.stats.health;
        player.stats.currentKi = player.stats.ki;


        player.evolution = {
            name: highestForm.name,
            level: highestForm.level,
            description: highestForm.description,
            achievedAt: new Date().toISOString(),
            auraColor: getAuraColorForEvolution(highestForm.name, player.planet)
        };


        return {
            name: highestForm.name,
            oldPower: oldPower,
            newPower: player.stats.power,
            oldDamage: oldDamage,
            newDamage: player.stats.damage,
            oldKi: oldKi,
            newKi: player.stats.ki,
            oldHealth: oldHealth,
            newHealth: player.stats.health
        };
    }

    return false;
}

function loadDragonBallData() {
    try {
        if (fs.existsSync(DB_BALL_FILE)) {
            return JSON.parse(fs.readFileSync(DB_BALL_FILE));
        }
    } catch (err) {
        console.error("Error loading dragon ball data:", err);
    }
    return JSON.parse(JSON.stringify(DRAGON_BALLS));
}

function saveDragonBallData(data) {
    fs.writeFileSync(DB_BALL_FILE, JSON.stringify(data, null, 2));
}
function loadPlayerData() {
    try {
        if (fs.existsSync(DB_FILE)) {
            return JSON.parse(fs.readFileSync(DB_FILE, 'utf8'));
        }
        return {};
    } catch (error) {
        console.error("L·ªói khi ƒë·ªçc d·ªØ li·ªáu ng∆∞·ªùi ch∆°i:", error);
        return {};
    }
}

function savePlayerData(data) {
    try {
        if (!fs.existsSync(DB_FOLDER)) {
            fs.mkdirSync(DB_FOLDER, { recursive: true });
        }
        fs.writeFileSync(DB_FILE, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error("L·ªói khi l∆∞u d·ªØ li·ªáu ng∆∞·ªùi ch∆°i:", error);
    }
}


function canUseSelfDestruct(playerHP, playerMaxHP, playerKi, playerMaxKi, currentTurn) {
    const hpPercent = (playerHP / playerMaxHP) * 100;
    const kiPercent = (playerKi / playerMaxKi) * 100;

    const turnCondition = currentTurn >= 25;
    const hpCondition = hpPercent <= 20;
    const kiCondition = kiPercent >= 80;

    return {
        canUse: turnCondition && hpCondition && kiCondition,
        reason: !turnCondition ? "EARLY_TURN" :
            !hpCondition ? "HP_TOO_HIGH" :
                !kiCondition ? "KI_TOO_LOW" : null,
        hpPercent,
        kiPercent,
        currentTurn
    };
}
function selectBestSkill(player, playerHP, playerKi, opponentHP, playerStates, opponentStates, battleLog, currentTurn) {
    if (!player || !player.skills || player.skills.length === 0) return null;

    const maxHP = player.stats.health;
    const maxKi = player.stats.ki;
    const hpPercent = (playerHP / maxHP) * 100;
    const kiPercent = (playerKi / maxKi) * 100;
    const opponentHPPercent = opponentHP ? (opponentHP / (opponentHP * 2)) * 100 : 50;


    const isHealingSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return skillName === "WHISTLE" || skillName === "REGENERATION" || skillName === "REGENERATE_ENERGY";
    };

    const isControlSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return ["SOLAR_FLARE", "HYPNOSIS", "BIND"].includes(skillName);
    };

    const isDefensiveSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return skillName === "ENERGY_SHIELD";
    };

    const isPowerUpSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return skillName === "KAIOKEN" || skillName === "GREAT_APE";
    };

    const isAttackSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        const skillData = MASTERS[master]?.skills?.[skillName];
        return skillData && skillData.powerScale > 0;
    };

    const isUltimateSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return ["SPIRIT_BOMB", "FINAL_FLASH", "SPECIAL_BEAM_CANNON", "HELLZONE_GRENADE",
            "CADICH_LIEN_HOAN_TRUONG", "MULTIFORM", "EXPLODING_STORM"].includes(skillName);
    };

    const isBasicAttackSkill = (skillChoice) => {
        const [master, skillName] = skillChoice.split(":");
        return skillName === "DRAGON_PUNCH" || skillName === "ATOMIC" || skillName === "GALICK_GUN";
    };


    const battlePhase = currentTurn <= 10 ? 1 : (currentTurn <= 20 ? 2 : 3);


    const allowedSkills = player.skills.filter(skillChoice => {
        const [master, skillName] = skillChoice.split(":");

        if (player.planet === "EARTH" && master !== "KAME") return false;
        if (player.planet === "NAMEK" && master !== "PICCOLO") return false;


        return MASTERS[master]?.skills?.[skillName] != null;
    });


    const attackSkillsAvailable = allowedSkills.filter(skill => isAttackSkill(skill)).length;


    const usableSkills = allowedSkills.filter(skillChoice => {
        const [master, skillName] = skillChoice.split(":");
        const skillData = MASTERS[master]?.skills?.[skillName];

        if (!skillData) return false;

        const kiRequired = Math.floor(playerKi * Math.abs(skillData.kiCost || 0));


        if (skillName === "SPIRIT_BOMB") {

            if (currentTurn < 25 || battlePhase < 3) return false;


            const spiritBombCount = battleLog.filter(log =>
                log.includes("Qu·∫£ C·∫ßu Kinh Kh√≠") &&
                log.includes(player.name)
            ).length;

            if (spiritBombCount > 0) return false;
        }


        if (skillName === "GREAT_APE" && battlePhase < 3) return false;


        if (skillName === "CADICH_LIEN_HOAN_TRUONG" && battlePhase === 1) return false;


        if (isHealingSkill(skillChoice)) {

            if (hpPercent > 50) return false;


            if (playerStates.lastSkill && isHealingSkill(`${master}:${playerStates.lastSkill}`)) {
                return false;
            }


            if (skillName === "REGENERATE_ENERGY" || skillName === "WHISTLE") {
                if (kiPercent > 25) return false;
            }


            const healingUsedCount = battleLog
                .filter(log => log.includes("T√°i T·∫°o") || log.includes("Hu√Ωt S√°o") || log.includes("h·ªìi ph·ª•c"))
                .length;

            if (healingUsedCount >= 2) return false;
        }


        if (skillName === "KAIOKEN") {

            const kaiokenUsedCount = battleLog
                .filter(log => log.includes("Kaioken"))
                .length;

            if (kaiokenUsedCount >= 1) return false;


            if (battlePhase === 1) return false;
        }


        if (isControlSkill(skillChoice)) {

            const recentControlUsed = battleLog
                .slice(-10)
                .some(log => (
                    log.includes(player.name) &&
                    (log.includes("Th√°i D∆∞∆°ng H·∫° San") ||
                        log.includes("Th√¥i Mi√™n") ||
                        log.includes("Tr√≥i"))
                ));

            if (recentControlUsed) return false;


            if (opponentStates.stunned > 0 || opponentStates.bound > 0) {
                return false;
            }
        }

        return (skillData.kiCost <= 0) || (playerKi >= kiRequired);
    });

    if (usableSkills.length === 0) return null;


    const skillScores = usableSkills.map(skillChoice => {
        const [master, skillName] = skillChoice.split(":");
        const skillData = MASTERS[master]?.skills?.[skillName];
        let score = 0;


        if (battlePhase === 1 && isBasicAttackSkill(skillChoice)) {
            score += 200;
        }


        if (skillData.powerScale > 0) {

            score += skillData.powerScale * 40;


            if (playerStates.combo > 0) {
                score += playerStates.combo * 15;
            }


            if (opponentStates.vulnerable > 0) {
                score += 40;
            }


            if (opponentStates.stunned > 0 || opponentStates.bound > 0) {
                score += 300;
            }
        }


        switch (battlePhase) {
            case 1:
                if (skillName === "DRAGON_PUNCH" || skillName === "ATOMIC") {
                    score += 250;
                }

                if (skillName === "GALICK_GUN") {
                    score += 200;
                }

                if (isControlSkill(skillChoice) && !opponentStates.stunned && !opponentStates.bound) {
                    score += 120;
                }


                if (isDefensiveSkill(skillChoice)) {
                    score -= 50;
                }


                if (isUltimateSkill(skillChoice)) {
                    score -= 500;
                }


                if (skillName === "CADICH_LIEN_HOAN_TRUONG") {
                    score -= 400;
                }


                if (isPowerUpSkill(skillChoice)) {
                    score -= 200;
                }
                break;

            case 2:

                if (skillName === "KAIOKEN" && !playerStates.powerBoosted) {
                    score += 200;
                }


                if (skillName === "CADICH_LIEN_HOAN_TRUONG") {
                    score += 120;
                }


                if (skillName === "GALICK_GUN") {
                    score += 150;
                }


                if (skillName === "DRAGON_PUNCH" || skillName === "ATOMIC") {
                    score -= 50;
                }


                if (isControlSkill(skillChoice) && !opponentStates.stunned && !opponentStates.bound) {
                    score += 180;
                }


                if (opponentHPPercent < 50 && skillData.powerScale > 0) {
                    score += 80;
                }
                break;

            case 3:

                if (skillName === "GREAT_APE" && !playerStates.powerBoosted) {
                    score += 350;
                }


                if (skillName === "SPIRIT_BOMB") {

                    if (currentTurn >= 25) {
                        score += 1000;
                    } else {
                        score += 350;
                    }
                }


                if (skillName === "CADICH_LIEN_HOAN_TRUONG") {
                    score += 300;
                }


                if (skillName === "GALICK_GUN") {
                    score += 150;
                }


                if (skillName === "KAIOKEN" && !playerStates.powerBoosted) {
                    score += 250;
                }


                if (skillName === "DRAGON_PUNCH" || skillName === "ATOMIC") {
                    score -= 200;
                }


                if (skillName === "SOLAR_FLARE" || skillName === "HYPNOSIS") {

                    score += 220;
                }
                break;
        }


        if (hpPercent <= 30) {

            if (isHealingSkill(skillChoice)) {
                score += 200;
            } else if (isDefensiveSkill(skillChoice)) {
                score += 180;
            } else if (isControlSkill(skillChoice) && !opponentStates.stunned && !opponentStates.bound) {
                score += 160;
            } else if (isPowerUpSkill(skillChoice) && !playerStates.powerBoosted) {
                score += 140;
            }
        } else if (hpPercent <= 70) {

            if (opponentHPPercent < 30 && skillData.powerScale > 2.5) {
                score += 160;
            } else if (!playerStates.powerBoosted && isPowerUpSkill(skillChoice)) {
                score += 130;
            } else if (!opponentStates.stunned && !opponentStates.bound && isControlSkill(skillChoice)) {
                score += 110;
            }
        } else {

            if (!playerStates.powerBoosted && isPowerUpSkill(skillChoice)) {
                score += 100;
            } else if (isUltimateSkill(skillChoice) && kiPercent > 90 && battlePhase === 3) {
                score += 150;
            } else if (!opponentStates.stunned && !opponentStates.bound && isControlSkill(skillChoice)) {
                score += 120;
            }


            if (isHealingSkill(skillChoice)) {
                score -= 300;
            }
        }


        switch (skillName) {
            case "KAIOKEN":
                if (playerStates.powerBoosted) {
                    score -= 500;
                } else if (battlePhase <= 1) {
                    score -= 200;
                }
                break;

            case "GREAT_APE":
                if (playerStates.powerBoosted) {
                    score -= 500;
                } else if (battlePhase < 3) {
                    score -= 400;
                } else {
                    score += 350;
                }
                break;

            case "DRAGON_PUNCH":

                if (battlePhase === 1) {
                    score += 200;
                } else if (battlePhase === 2) {
                    score -= 50;
                } else {
                    score -= 200;
                }
                break;

            case "ATOMIC":

                if (battlePhase === 1) {
                    score += 220;
                } else if (battlePhase === 2) {
                    score -= 50;
                } else {
                    score -= 200;
                }
                break;

            case "GALICK_GUN":
                if (battlePhase === 1) {
                    score += 180;
                }

                if (opponentStates.stunned > 0 || opponentStates.bound > 0) {
                    score += 120;
                }
                break;

            case "CADICH_LIEN_HOAN_TRUONG":
                if (battlePhase === 1) {
                    score -= 300;
                } else if (battlePhase === 2) {
                    score += 50;
                } else {
                    score += 200;
                }


                if (opponentStates.stunned > 0 || opponentStates.bound > 0) {
                    score += 180;
                }
                break;

            case "SOLAR_FLARE":
            case "HYPNOSIS":

                const controlCooldown = 5;

                if (opponentStates.stunned || opponentStates.bound) {
                    score -= 500;
                }


                const recentControlUse = battleLog
                    .slice(-10)
                    .some(log => (
                        log.includes(player.name) &&
                        (log.includes("Th√°i D∆∞∆°ng H·∫° San") || log.includes("Th√¥i Mi√™n"))
                    ));

                if (recentControlUse) {
                    score -= 300;
                }


                if (battlePhase >= 2) {
                    score += 80;
                }
                break;

            case "BIND":
                if (opponentStates.stunned || opponentStates.bound) {
                    score -= 500;
                }


                const bindCooldown = 3;
                break;

            case "ENERGY_SHIELD":
                if (playerStates.shielded) {
                    score -= 400;
                } else if (hpPercent < 50) {
                    score += 150;
                }
                break;

            case "WHISTLE":
            case "REGENERATE_ENERGY":

                if (kiPercent > 25) {
                    score -= 300;
                }

                if (playerStates.lastSkill === skillName) {
                    score -= 500;
                }
                break;

            case "REGENERATION":

                if (playerStates.lastSkill === skillName) {
                    score -= 500;
                }
                break;

            case "SPIRIT_BOMB":

                if (battlePhase < 3) {
                    score -= 800;
                } else if (currentTurn < 25) {
                    score -= 300;
                } else {

                    const spiritBombUsed = battleLog.some(log =>
                        log.includes("Qu·∫£ C·∫ßu Kinh Kh√≠") &&
                        log.includes(player.name)
                    );

                    if (!spiritBombUsed) {

                        if (currentTurn >= 25) {
                            score += 1000;
                        }
                    } else {

                        score -= 1000;
                    }
                }
                break;
        }


        if (skillData.powerScale > 0) {
            if (playerStates.combo >= 3) {
                score += 100;
            }
        }


        if (playerStates.lastSkill === skillName) {
            score -= 150;
        }


        const skillUsageCount = battleLog
            .filter(log => log.includes(skillData.name))
            .length;

        if (skillUsageCount > 2) {
            score -= skillUsageCount * 30;
        }


        if ((opponentStates.stunned > 0 || opponentStates.bound > 0) && skillData.powerScale > 0) {
            score += 300;
        }


        score += Math.random() * 10;

        return { skillChoice, score };
    });


    skillScores.sort((a, b) => b.score - a.score);


    const top3 = skillScores.slice(0, Math.min(3, skillScores.length));
    console.log(`Turn ${currentTurn} | Phase ${battlePhase} | HP: ${hpPercent.toFixed(1)}% | Ki: ${kiPercent.toFixed(1)}%`);
    top3.forEach((choice, i) => {
        const [master, skillName] = choice.skillChoice.split(":");
        const skillData = MASTERS[master]?.skills[skillName];
        if (skillData) {
            console.log(`${i + 1}. ${skillData.name} (Score: ${choice.score.toFixed(1)})`);
        }
    });

    return skillScores[0]?.skillChoice || null;
}
function calculatePowerGain(currentPower, locationMultiplier) {
    // Base power gain is initially high and decreases as power increases
    let basePowerGain;

    if (currentPower < 1000) {
        // Very low power - give a significant boost
        basePowerGain = currentPower * 0.25 + 100;
    } else if (currentPower < 10000) {
        // Low power - good growth
        basePowerGain = currentPower * 0.15 + 200;
    } else if (currentPower < 100000) {
        // Medium power - moderate growth
        basePowerGain = currentPower * 0.08 + 500;
    } else if (currentPower < 1000000) {
        // High power - slower growth
        basePowerGain = currentPower * 0.04 + 2000;
    } else if (currentPower < 10000000) {
        // Very high power - even slower growth
        basePowerGain = currentPower * 0.015 + 5000;
    } else {
        // Extreme power - minimal growth
        basePowerGain = currentPower * 0.005 + 10000;
    }

    // Apply location multiplier
    const powerGain = Math.floor(basePowerGain * locationMultiplier);

    return powerGain;
}
function calculateExpGain(currentPower, playerDamage) {
    let baseExpGain;

    if (currentPower < 1000) {
        // Very low power - give a significant exp boost
        baseExpGain = currentPower * 0.6 + 200;
    } else if (currentPower < 10000) {
        // Low power - good exp growth
        baseExpGain = currentPower * 0.3 + 400;
    } else if (currentPower < 100000) {
        // Medium power - moderate exp growth
        baseExpGain = currentPower * 0.15 + 1000;
    } else if (currentPower < 1000000) {
        // High power - slower exp growth
        baseExpGain = currentPower * 0.08 + 5000;
    } else if (currentPower < 10000000) {
        // Very high power - even slower exp growth
        baseExpGain = currentPower * 0.04 + 10000;
    } else {
        // Extreme power - minimal exp growth
        baseExpGain = currentPower * 0.02 + 20000;
    }

    // Factor in damage for additional exp (small bonus based on damage)
    const damageBonus = Math.sqrt(playerDamage) * 0.5;

    // Final exp gain
    const expGain = Math.floor(baseExpGain + damageBonus);

    return expGain;
}
module.exports = {
    name: "dball",
    version: "1.7.2",
    usedby: 0,
    onPrefix: true,
    dev: "HNT",
    info: "Game Dragon Ball Z",
    category: "Games",
    usages: ".dball",
    cooldowns: 5,

    setInterval: function () {
        // Check for boss events periodically (every 5 minutes)
        if (!this.bossCheckInterval) {
            this.bossCheckInterval = setInterval(() => {
                BOSS_SYSTEM.checkForBossEvents();
                BOSS_SYSTEM.saveBossData();
                console.log("Checked for new boss events");
            }, 5 * 60 * 1000); // Every 5 minutes
        }

        return {
            name: this.name,
            version: this.version
        };
    },
    onLoad: function () {
        if (!fs.existsSync(DB_FOLDER)) {
            fs.mkdirSync(DB_FOLDER, { recursive: true });
        }

        if (!fs.existsSync(DB_FILE)) {
            fs.writeFileSync(DB_FILE, JSON.stringify({}, null, 2));
        }

        if (!fs.existsSync(DB_BALL_FILE)) {
            fs.writeFileSync(DB_BALL_FILE, JSON.stringify(DRAGON_BALLS, null, 2));
        }

        if (!fs.existsSync(TOURNAMENT_DB)) {
            fs.writeFileSync(TOURNAMENT_DB, JSON.stringify({
                active: null,
                history: [],
                registrations: {}
            }, null, 2));
        }
        BOSS_SYSTEM.loadBossData();
        try {
            const playerData = loadPlayerData();
            for (const [id, player] of Object.entries(playerData)) {
                validatePlayerSkills(player);
            }
            savePlayerData(playerData);
            console.log("ƒê√£ ki·ªÉm tra v√† c·∫≠p nh·∫≠t k·ªπ nƒÉng c·ªßa t·∫•t c·∫£ ng∆∞·ªùi ch∆°i");
        } catch (error) {
            console.error("L·ªói khi ki·ªÉm tra k·ªπ nƒÉng ng∆∞·ªùi ch∆°i:", error);
        }
        const canvasCacheDir = path.join(__dirname, "../game/canvas/cache");
        if (!fs.existsSync(canvasCacheDir)) {
            fs.mkdirSync(canvasCacheDir, { recursive: true });
        }
    },

    onLaunch: async function ({ api, event, target }) {
        const { threadID, messageID, senderID } = event;

        try {
            console.log("DB_FILE path:", DB_FILE);


            const userData = JSON.parse(fs.readFileSync(path.join(__dirname, "../events/cache/userData.json")));


            let command = (target[0] || "").toLowerCase();


            let playerData;
            try {
                playerData = loadPlayerData();
                
                if (!playerData) {
                    console.log("playerData is null or undefined, initializing empty object");
                    playerData = {};
                }
            } catch (error) {
                console.error("L·ªói khi t·∫£i d·ªØ li·ªáu ng∆∞·ªùi ch∆°i:", error);
                playerData = {};
            }

            if (!target[0]) {
                if (playerData[senderID]) {
                    const menuImageData = {
                        playerName: playerData[senderID].name,
                        playerPlanet: playerData[senderID].planet,
                        playerStats: playerData[senderID].stats,
                        playerEvolution: playerData[senderID].evolution?.name || null,
                        playerRace: PLANETS[playerData[senderID].planet].name,
                        planetTheme: PLANET_THEME_COLORS[playerData[senderID].planet] || PLANET_THEME_COLORS.EARTH
                    };

                    const menuImagePath = await createMenuImage(menuImageData);

                    if (menuImagePath) {
                        return api.sendMessage(
                            {
                                body: "üêâ ùóóùó•ùóîùóöùó¢ùó° ùóïùóîùóüùóü ùó≠ üêâ\nS·ª≠ d·ª•ng c√°c l·ªánh sau ƒë·ªÉ ch∆°i game:",
                                attachment: fs.createReadStream(menuImagePath)
                            },
                            threadID,
                            () => fs.unlinkSync(menuImagePath),
                            messageID
                        );
                    } else {
                        return api.sendMessage(
                            "üêâ ùóóùó•ùóîùóöùó¢ùó° ùóïùóîùóüùóü ùó≠ üêâ\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            "C√°c l·ªánh c√≥ s·∫µn:\n\n" +
                            "‚Ä¢ info - Xem th√¥ng tin nh√¢n v·∫≠t\n" +
                            "‚Ä¢ train - Luy·ªán t·∫≠p tƒÉng EXP\n" +
                            "‚Ä¢ Shop - Shop V·∫≠t Ph·∫©m\n" +
                            "‚Ä¢ give - T·∫∑ng Ng·ªçc R·ªìng cho ng∆∞·ªùi kh√°c\n" +
                            "‚Ä¢ fight - Th√°ch ƒë·∫•u ng∆∞·ªùi ch∆°i kh√°c\n" +
                            "‚Ä¢ quest - Xem nhi·ªám v·ª•\n" +
                            "‚Ä¢ rank - Xem b·∫£ng x·∫øp h·∫°ng\n\n" +
                            "C√°ch d√πng: .dball <l·ªánh>",
                            threadID, messageID
                        );
                        return;
                    }
                } else {
                    const menuImagePath = await createMenuImage({
                        isNewPlayer: true
                    });

                    if (menuImagePath) {
                        return api.sendMessage(
                            {
                                body: "üêâ ùóóùó•ùóîùóöùó¢ùó° ùóïùóîùóüùóü ùó≠ üêâ\nCh·ªçn h√†nh tinh ƒë·ªÉ b·∫Øt ƒë·∫ßu:",
                                attachment: fs.createReadStream(menuImagePath)
                            },
                            threadID,
                            () => fs.unlinkSync(menuImagePath),
                            messageID
                        );
                    } else {
                        return api.sendMessage(
                            "üêâ ùóóùó•ùóîùóöùó¢ùó° ùóïùóîùóüùóü ùó≠ üêâ\n" +
                            "Ch·ªçn h√†nh tinh ƒë·ªÉ b·∫Øt ƒë·∫ßu:\n\n" +
                            Object.entries(PLANETS).map(([key, data]) =>
                                `${key}: ${data.name}\n` +
                                `‚Ä¢ ${data.description}`
                            ).join("\n\n") + "\n\n" +
                            "C√°ch d√πng: .dball <t√™n_h√†nh_tinh>\n" +
                            "VD: .dball earth",
                            threadID, messageID
                        );
                    }
                }
            }

            if (!playerData[senderID] && Object.keys(PLANETS).some(p => p.toLowerCase() === command)) {
                const planet = Object.keys(PLANETS).find(p => p.toLowerCase() === command);
                const userName = userData[senderID]?.name || "Ng∆∞·ªùi ch∆°i";
            
                const savePlayerDataLocal = () => {
                    savePlayerData(playerData);
                };
            
                playerData[senderID] = {
                    name: userName,
                    planet: planet,
                    stats: { ...DEFAULT_STATS },
                    skills: [],
                    masters: [],
                    lastTrain: 0,
                    created: Date.now(),
                    inventory: {
                        dragonBalls: []
                    },
                    hasFused: false
                };
            
                if (!playerData[senderID].inventory.items) {
                    playerData[senderID].inventory.items = [];
                }
                
                playerData[senderID].inventory.items.push({
                    id: "senzu",
                    quantity: 3,
                    type: "consumable"
                });
                
                if (planet === "EARTH") {
                    playerData[senderID].inventory.items.push({
                        id: "armor",
                        quantity: 1,
                        type: "armor",
                        boost: 1.1
                    });
                    playerData[senderID].stats.zeni += 1000;
                } 
                else if (planet === "NAMEK") {
                    playerData[senderID].inventory.items.push({
                        id: "boots",
                        quantity: 1,
                        type: "boots",
                        boost: 1.1
                    });
                    playerData[senderID].stats.ki += 50; 
                } 
                else if (planet === "SAIYAN") {
                    playerData[senderID].inventory.items.push({
                        id: "gloves",
                        quantity: 1,
                        type: "gloves",
                        boost: 1.1
                    });
                    playerData[senderID].stats.damage += 10;
                }
            
                updateQuestProgress(playerData[senderID], QUEST_TYPES.MASTER, playerData);
                savePlayerData(playerData);
            
                const starterGuide = 
                    "üéÆ H∆Ø·ªöNG D·∫™N C∆† B·∫¢N üéÆ\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    "1Ô∏è‚É£ Luy·ªán t·∫≠p: .dball train\n" +
                    "2Ô∏è‚É£ Xem th√¥ng tin: .dball info\n" +
                    "3Ô∏è‚É£ Mua v·∫≠t ph·∫©m: .dball shop\n" +
                    "4Ô∏è‚É£ Ki·ªÉm tra nhi·ªám v·ª•: .dball quest\n" +
                    "5Ô∏è‚É£ ƒê√°nh qu√°i v·∫≠t: .dball fight monster\n" +
                    "6Ô∏è‚É£ D√πng v·∫≠t ph·∫©m: .dball use <id>\n" +
                    "7Ô∏è‚É£ T√¨m ki·∫øm Ng·ªçc R·ªìng khi luy·ªán t·∫≠p\n\n" +
                    `üíé ƒê·∫∂C TR∆ØNG C·ª¶A T·ªòC ${planet}: ${PLANETS[planet].description}\n\n` +
                    "üéÅ PH·∫¶N QU√Ä CHO NG∆Ø·ªúI M·ªöI:\n" +
                    "‚Ä¢ 3 ƒê·∫≠u Th·∫ßn (H·ªìi ph·ª•c HP v√† Ki)\n" +
                    (planet === "EARTH" ? "‚Ä¢ Gi√°p c∆° b·∫£n (+10% HP)\n‚Ä¢ 1000 Zeni b·ªï sung\n" : 
                     planet === "NAMEK" ? "‚Ä¢ Gi√†y c∆° b·∫£n (+10% Ki)\n‚Ä¢ 50 Ki b·ªï sung\n" :
                     "‚Ä¢ GƒÉng tay c∆° b·∫£n (+10% S·ª©c ƒë√°nh)\n‚Ä¢ 10 S·ª©c ƒë√°nh b·ªï sung\n") +
                    "\nüîç D√πng .dball inventory ƒë·ªÉ xem v·∫≠t ph·∫©m!";
            
                return api.sendMessage(
                    "üéâ NH√ÇN V·∫¨T ƒê√É ƒê∆Ø·ª¢C T·∫†O!\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                    `üë§ T√™n: ${userName}\n` +
                    `üåç T·ªôc ng∆∞·ªùi: ${PLANETS[planet].name}\n` +
                    `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ c∆° b·∫£n: ${DEFAULT_STATS.power}\n` +
                    `‚ú® Ki: ${DEFAULT_STATS.ki}\n` +
                    `‚ù§Ô∏è HP: ${DEFAULT_STATS.health}\n` +
                    `üí∞ Zeni: ${DEFAULT_STATS.zeni.toLocaleString()}\n\n` +
                    "üí° D√πng .dball train ƒë·ªÉ b·∫Øt ƒë·∫ßu luy·ªán t·∫≠p!\n\n" +
                    starterGuide,
                    threadID, messageID
                );
            }

            switch (command) {
                case "info": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }
                    applyEquipmentBoosts(player);
                    const removedSkills = validatePlayerSkills(player);
                    if (removedSkills && removedSkills.length > 0) {
                        savePlayerData(playerData);
                        api.sendMessage(
                            `‚ö†Ô∏è C·∫£nh b√°o: B·∫°n ƒë√£ b·ªã lo·∫°i b·ªè ${removedSkills.length} k·ªπ nƒÉng v√¨ kh√¥ng ƒë·ªß s·ª©c m·∫°nh:\n` +
                            `${removedSkills.join(", ")}\n\n` +
                            `üí° H√£y ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng l·∫°i c√°c k·ªπ nƒÉng n√†y.`,
                            threadID
                        );
                    }
                    let skillList = "";
                    if (player.skills.length > 0) {
                        skillList = "\n\n‚öîÔ∏è K·ª∏ NƒÇNG ƒê√É H·ªåC:\n" + player.skills.map(skill => {
                            const [master, skillName] = skill.split(":");
                            const skillData = MASTERS[master].skills[skillName];

                            const damage = skillData.powerScale > 0 ?
                                Math.floor(player.stats.damage * skillData.powerScale) : 0;

                            const kiCost = skillData.kiCost != 0 ?
                                Math.abs(Math.floor(player.stats.ki * skillData.kiCost)) : 0;

                            if (skillData.powerScale > 0) {
                                return `- ${skillData.name} (‚öîÔ∏è ${damage.toLocaleString()} DMG, ${skillData.kiCost > 0 ? "‚ú® -" + kiCost + " Ki" : ""})`;
                            } else if (skillData.kiCost < 0) {
                                return `- ${skillData.name} (${skillData.description}, ‚ú® +${kiCost} Ki)`;
                            } else {
                                return `- ${skillData.name} (${skillData.description}, ‚ú® -${kiCost} Ki)`;
                            }
                        }).join("\n");
                    }

                    let masterList = "";
                    if (player.masters.length > 0) {
                        masterList = "\n\nüë®‚Äçüè´ S∆∞ ph·ª• ƒë√£ g·∫∑p:\n" + player.masters.map(master =>
                            `- ${MASTERS[master].name}`
                        ).join("\n");
                    }

                    let inventoryList = "";
                    if (player.inventory?.items?.length > 0) {
                        inventoryList = "\n\nüì¶ KHO ƒê·ªí:\n";

                        const equipped = player.inventory.items.filter(item => item.equipped);
                        if (equipped.length > 0) {
                            inventoryList += "üéΩ ƒêang s·ª≠ d·ª•ng:\n";
                            equipped.forEach(item => {
                                const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                                if (itemData) {
                                    inventoryList += `${itemData.emoji} ${itemData.name}\n`;
                                }
                            });
                        }

                        const nonEquipped = player.inventory.items.filter(item => !item.equipped);
                        if (nonEquipped.length > 0) {
                            inventoryList += "\nüíº T√∫i ƒë·ªì:\n";
                            nonEquipped.forEach(item => {
                                const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                                if (itemData) {
                                    inventoryList += `${itemData.emoji} ${itemData.name} x${item.quantity}\n`;
                                }
                            });
                        }
                    }

                    if (player.inventory?.dragonBalls?.length > 0) {
                        inventoryList += "\nüîÆ NG·ªåC R·ªíNG:\n";
                        const dragonBallsByPlanet = {};

                        player.inventory.dragonBalls.forEach(ball => {
                            if (!dragonBallsByPlanet[ball.planet]) {
                                dragonBallsByPlanet[ball.planet] = [];
                            }
                            dragonBallsByPlanet[ball.planet].push(ball.star);
                        });

                        Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                            stars.sort((a, b) => a - b);
                            inventoryList += `${PLANETS[planet].name}: ${stars.map(s => `${s}‚≠ê`).join(", ")}\n`;
                        });

                        Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                            if (stars.length === 7) {
                                inventoryList += `\nüêâ B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng ${PLANETS[planet].name}!\n`;
                                inventoryList += "üí° D√πng .dball wish ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc\n";
                            }
                        });
                    }
                    let evolutionInfo = "";
                    if (player.evolution) {
                        evolutionInfo = "\n\nüåü TI·∫æN H√ìA:\n" +
                            `${player.evolution.name}\n` +
                            `üìù ${player.evolution.description}\n`;

                        if (player.evolution.level > 0) {
                            const evolutionForm = EVOLUTION_SYSTEM[player.planet].forms[player.evolution.level];
                            evolutionInfo += `üí™ x${evolutionForm.powerBonus} ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ\n`;
                            evolutionInfo += `‚öîÔ∏è x${evolutionForm.damageBonus} S·ª©c ƒë√°nh\n`;
                            evolutionInfo += `‚ú® x${evolutionForm.kiBonus} Ki\n`;
                            evolutionInfo += `‚ù§Ô∏è x${evolutionForm.healthBonus} HP\n`;
                        }
                    }
                    if (!player.stats.currentHealth) player.stats.currentHealth = player.stats.health;
                    if (!player.stats.currentKi) player.stats.currentKi = player.stats.ki;

                    let amuletList = "";
                    if (player.amulets && player.amulets.length > 0) {

                        player.amulets = player.amulets.filter(amulet => amulet.expireAt > Date.now());

                        if (player.amulets.length > 0) {
                            amuletList = "\n\nüîÆ B√ôA ƒêANG C√ì HI·ªÜU L·ª∞C:\n";
                            player.amulets.forEach(amulet => {
                                const timeLeft = Math.floor((amulet.expireAt - Date.now()) / 3600000);
                                amuletList += `${amulet.emoji} ${amulet.name} - C√≤n ${timeLeft} gi·ªù\n`;
                            });
                        }

                        savePlayerData(playerData);
                    }


                    return api.sendMessage(
                        "üìä ùóßùóõùó¢ÃÇùó°ùóö ùóßùóúùó° ùó°ùóõùóîÃÇùó° ùó©ùóîÃ£ÃÇùóß üìä\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `üë§ T√™n: ${player.name}\n` +
                        `üåç T·ªôc Ng∆∞·ªùi: ${PLANETS[player.planet].name}\n` +
                        `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${player.stats.power.toLocaleString()}\n` +
                        `‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage.toLocaleString()}\n` +
                        `‚ú® Ki: ${player.stats.currentKi.toLocaleString()}/${player.stats.ki.toLocaleString()}\n` +
                        `‚ù§Ô∏è HP: ${player.stats.currentHealth.toLocaleString()}/${player.stats.health.toLocaleString()}\n` +
                        `üí∞ Zeni: ${(player.stats.zeni || 0).toLocaleString()}\n` +
                        `üìä EXP: ${player.stats.exp.toLocaleString()}` +
                        evolutionInfo +
                        skillList + masterList + inventoryList + amuletList,
                        threadID, messageID
                    );
                    break;
                }

                case "use": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    if (!target[1]) {
                        return api.sendMessage(
                            "‚ùå Vui l√≤ng nh·∫≠p ID v·∫≠t ph·∫©m!\n" +
                            "C√°ch d√πng: .dball use <id_v·∫≠t_ph·∫©m>\n" +
                            "üí° Xem ID v·∫≠t ph·∫©m trong shop ho·∫∑c inventory",
                            threadID, messageID
                        );
                    }

                    const itemId = target[1].toLowerCase();
                    const shopItem = Object.values(SHOP_ITEMS).find(item => item.id === itemId);

                    if (!shopItem) {
                        return api.sendMessage("‚ùå V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }

                    if (!player.inventory?.items?.some(item => item.id === itemId)) {
                        return api.sendMessage(
                            `‚ùå B·∫°n kh√¥ng c√≥ ${shopItem.name} trong kho ƒë·ªì!`,
                            threadID, messageID
                        );
                    }

                    const inventoryItem = player.inventory.items.find(item => item.id === itemId);


                    if (inventoryItem.usedTime && shopItem.duration) {
                        const remainingTime = inventoryItem.usedTime + shopItem.duration - Date.now();
                        if (remainingTime > 0) {
                            const hours = Math.floor(remainingTime / (60 * 60 * 1000));
                            const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
                            return api.sendMessage(
                                `‚ùå ${shopItem.name} v·∫´n c√≤n hi·ªáu l·ª±c ho·∫∑c ƒëang trong th·ªùi gian h·ªìi!\n` +
                                `‚è≥ Th·ªùi gian c√≤n l·∫°i: ${hours} gi·ªù ${minutes} ph√∫t`,
                                threadID, messageID
                            );
                        }
                    }

                    switch (shopItem.type) {
                        case "consumable": {

                            if (shopItem.duration && itemId !== "senzu") {
                                inventoryItem.usedTime = Date.now();
                            }

                            switch (itemId) {
                                case "senzu": {
                                    const oldKi = player.stats.currentKi || player.stats.ki;
                                    const oldHP = player.stats.currentHealth || player.stats.health;

                                    if (!player.originalKi && player.stats.ki !== player.baseStats?.ki) {
                                        player.originalKi = player.baseStats?.ki || player.stats.ki;
                                    }

                                    player.stats.currentHealth = player.stats.health;
                                    player.stats.currentKi = player.stats.ki;

                                    if (player.originalHealth && player.originalHealth > player.stats.health) {
                                        player.stats.health = player.originalHealth;
                                        player.stats.currentHealth = player.originalHealth;
                                        delete player.originalHealth;
                                    }

                                    if (player.originalKi && player.originalKi > player.stats.ki) {
                                        player.stats.ki = player.originalKi;
                                        player.stats.currentKi = player.originalKi;
                                        delete player.originalKi;
                                    }

                                    if (!player.baseStats) {
                                        player.baseStats = {
                                            damage: player.stats.damage,
                                            health: player.stats.health,
                                            ki: player.stats.ki
                                        };
                                    }

                                    inventoryItem.quantity--;
                                    if (inventoryItem.quantity <= 0) {
                                        player.inventory.items = player.inventory.items.filter(item => item.id !== itemId);
                                    }

                                    savePlayerData(playerData);

                                    return api.sendMessage(
                                        "‚ú® ùó¶ùó®ÃõÃâ ùóóùó®Ã£ùó°ùóö ƒêùóîÃ£ÃÇùó® ùóßùóõùóîÃÇÃÄùó° ùóßùóõùóîÃÄùó°ùóõ ùóñùó¢ÃÇùó°ùóö!\n" +
                                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                        `‚ù§Ô∏è HP: ${oldHP.toLocaleString()} ‚Üí ${player.stats.currentHealth.toLocaleString()} (ph·ª•c h·ªìi ho√†n to√†n!)\n` +
                                        `‚ú® Ki: ${oldKi.toLocaleString()} ‚Üí ${player.stats.currentKi.toLocaleString()} (ph·ª•c h·ªìi ho√†n to√†n!)\n` +
                                        `üì¶ C√≤n l·∫°i: ${inventoryItem.quantity} ƒê·∫≠u Th·∫ßn\n\n` +
                                        `üí° B·∫°n ƒë√£ h·ªìi ph·ª•c ho√†n to√†n v√† c√≥ th·ªÉ ti·∫øp t·ª•c chi·∫øn ƒë·∫•u!`,
                                        threadID, messageID
                                    );
                                }

                                case "crystal": {

                                    inventoryItem.usedTime = Date.now();

                                    const oldPower = player.stats.power;
                                    player.stats.power += 10000;


                                    inventoryItem.quantity--;
                                    if (inventoryItem.quantity <= 0) {
                                        player.inventory.items = player.inventory.items.filter(item => item.id !== itemId);
                                    }

                                    savePlayerData(playerData);

                                    return api.sendMessage(
                                        "üíé S·ª¨ D·ª§NG TINH TH·ªÇ TH√ÄNH C√îNG!\n" +
                                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                        `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${oldPower} ‚Üí ${player.stats.power}\n` +
                                        `üì¶ C√≤n l·∫°i: ${inventoryItem.quantity} Tinh Th·ªÉ\n` +
                                        `‚è≥ Th·ªùi gian h·ªìi: 1 gi·ªù`,
                                        threadID, messageID
                                    );
                                }


                            }
                            break;
                        }

                        case "radar": {

                            inventoryItem.usedTime = Date.now();

                            return api.sendMessage(
                                "üì° TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                `üîç T·ª∑ l·ªá t√¨m th·∫•y Ng·ªçc R·ªìng tƒÉng x3\n` +
                                `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: 1 gi·ªù`,
                                threadID, messageID
                            );
                        }
                        case "equipment":
                        case "armor":
                        case "gloves":
                        case "boots":
                        case "radar": {
                            if (inventoryItem.equipped) {
                                inventoryItem.equipped = false;
                                savePlayerData(playerData);

                                return api.sendMessage(
                                    "‚ùé ƒê√É TH√ÅO TRANG B·ªä!\n" +
                                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                    `ƒê√£ th√°o: ${shopItem.name}`,
                                    threadID, messageID
                                );
                            }


                            if (inventoryItem.type === "armor" || inventoryItem.type === "gloves" ||
                                inventoryItem.type === "boots" || inventoryItem.type === "radar") {
                                const sameTypeItems = player.inventory.items.filter(
                                    item => item.type === inventoryItem.type && item.equipped
                                );

                                sameTypeItems.forEach(item => {
                                    item.equipped = false;
                                });
                            }

                            inventoryItem.usedTime = Date.now();
                            inventoryItem.visualEffect = getVisualEffectForItem(itemId);
                            inventoryItem.equipped = true;

                            let effectMessage = "";
                            switch (inventoryItem.type) {
                                case "armor":
                                    effectMessage = `TƒÉng HP +${Math.round((inventoryItem.boost - 1) * 100)}%`;
                                    break;
                                case "gloves":
                                    effectMessage = `TƒÉng s·ª©c ƒë√°nh +${Math.round((inventoryItem.boost - 1) * 100)}%`;
                                    break;
                                case "boots":
                                    effectMessage = `TƒÉng Ki +${Math.round((inventoryItem.boost - 1) * 100)}%`;
                                    break;
                                case "radar":
                                    effectMessage = `TƒÉng EXP v√† s·ª©c m·∫°nh +${Math.round((inventoryItem.boost - 1) * 100)}%`;
                                    break;
                                default:
                                    effectMessage = shopItem.description;
                            }
                            applyEquipmentBoosts(player);
                            savePlayerData(playerData);

                            return api.sendMessage(
                                "üéΩ TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `${inventoryItem.emoji || "üéΩ"} ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                `üìä Hi·ªáu qu·∫£: ${effectMessage}\n` +
                                `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: Vƒ©nh vi·ªÖn`,
                                threadID, messageID
                            );
                        }

                        case "equipment": {
                            if (inventoryItem.equipped) {
                                return api.sendMessage(
                                    `‚ùå B·∫°n ƒë√£ trang b·ªã ${shopItem.name} r·ªìi!`,
                                    threadID, messageID
                                );
                            }


                            inventoryItem.usedTime = Date.now();
                            inventoryItem.visualEffect = getVisualEffectForItem(itemId);
                            inventoryItem.equipped = true;

                            switch (itemId) {
                                case "scouter": {
                                    const oldKi = player.stats.ki;
                                    player.stats.ki = Math.floor(player.stats.ki * 1.1);
                                    player.stats.currentKi = player.stats.ki;

                                    savePlayerData(playerData);

                                    return api.sendMessage(
                                        "üîã TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                        `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                        `‚ú® Ki: ${oldKi} ‚Üí ${player.stats.ki}\n` +
                                        `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: 1 gi·ªù`,
                                        threadID, messageIDF
                                    );
                                }

                                case "armor": {
                                    const oldHealth = player.stats.health;
                                    player.stats.health = Math.floor(player.stats.health * 1.15);
                                    player.stats.currentHealth = player.stats.health;

                                    savePlayerData(playerData);

                                    return api.sendMessage(
                                        "üõ°Ô∏è TRANG B·ªä TH√ÄNH C√îNG!\n" +
                                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                        `ƒê√£ trang b·ªã: ${shopItem.name}\n` +
                                        `‚ù§Ô∏è HP: ${oldHealth} ‚Üí ${player.stats.health}\n` +
                                        `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: 1 gi·ªù`,
                                        threadID, messageID
                                    );
                                }


                            }
                            break;
                        }
                    }
                    updateQuestProgress(player, QUEST_TYPES.COLLECT, playerData);
                    savePlayerData(playerData);


                    return api.sendMessage(
                        `‚úÖ ƒê√£ s·ª≠ d·ª•ng ${shopItem.name} th√†nh c√¥ng!\n` +
                        `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: 1 gi·ªù`,
                        threadID, messageID
                    );
                    break;
                }

                case "shop": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }
                    else if (target[1]?.toLowerCase() === "rada" || target[1]?.toLowerCase() === "radar") {

                        const purchasedRadar = player.inventory.items.find(i => i.id === selectedRadar.id);
                        if (purchasedRadar) {
                            player.inventory.items.forEach(item => {
                                if (item.type === "radar" && item.equipped) {
                                    item.equipped = false;
                                }
                            });

                            purchasedRadar.equipped = true;
                            purchasedRadar.usedTime = Date.now();

                            const radarBoost = selectedRadar.boost || 1.2;
                            player.stats.expMultiplier = (player.stats.expMultiplier || 1) * radarBoost;
                            player.stats.powerMultiplier = (player.stats.powerMultiplier || 1) * radarBoost;
                        }
                        const radarItems = Object.values(EQUIPMENT_ITEMS)
                            .filter(item => item.type === "radar")
                            .filter(item => player.stats.power >= item.requiredPower);

                        if (!target[2]) {
                            const radarShopData = {
                                radarItems: radarItems,
                                player: player
                            };

                            const imagePath = await createRadarShopImage(radarShopData);

                            if (imagePath) {
                                return api.sendMessage(
                                    {
                                        body: `üì° C·ª¨A H√ÄNG RADAR NG·ªåC R·ªíNG üì°\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nüë§ ${player.name}\nüí∞ Zeni: ${player.stats.zeni.toLocaleString()}\n\nüí° ƒê·ªÉ mua radar: .dball shop rada <s·ªë th·ª© t·ª±>`,
                                        attachment: fs.createReadStream(imagePath)
                                    },
                                    threadID,
                                    () => fs.unlinkSync(imagePath),
                                    messageID
                                );
                            } else {
                                let msg = `üì° SHOP RADA - TƒÇNG S·ª®C M·∫†NH & EXP üì°\n`;
                                msg += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";

                                radarItems.forEach((item, index) => {
                                    msg += `${index + 1}. ${item.emoji} ${item.name} - ${item.price.toLocaleString()} Zeni\n`;
                                    msg += `   ‚Ä¢ ${item.description}\n`;
                                    msg += `   ‚Ä¢ TƒÉng EXP v√† S·ª©c M·∫°nh: +${Math.round((item.boost - 1) * 100)}%\n`;
                                    msg += `   ‚Ä¢ Y√™u c·∫ßu: ${item.requiredPower.toLocaleString()} s·ª©c m·∫°nh\n\n`;
                                });

                                msg += "C√°ch d√πng:\n";
                                msg += "‚Ä¢ .dball shop rada <s·ªë th·ª© t·ª±>\n";
                                msg += "‚Ä¢ VD: .dball shop rada 1 (Mua Rada c·∫•p 1)\n\n";
                                msg += `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}`;

                                return api.sendMessage(msg, threadID, messageID);
                            }
                        }

                        const itemIndex = parseInt(target[2]) - 1;

                        if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= radarItems.length) {
                            return api.sendMessage("‚ùå S·ªë th·ª© t·ª± rada kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                        }

                        const selectedRadar = radarItems[itemIndex];

                        if (player.stats.zeni < selectedRadar.price) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng ƒë·ªß ùó≠ùó≤ùóªùó∂ ƒë·ªÉ mua!\n` +
                                `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                                `üí∞ C·∫ßn: ${selectedRadar.price.toLocaleString()}`,
                                threadID, messageID
                            );
                        }

                        if (!player.inventory) player.inventory = { items: [] };
                        if (!player.inventory.items) player.inventory.items = [];

                        const existingItem = player.inventory.items.find(i => i.id === selectedRadar.id);

                        if (existingItem) {
                            existingItem.quantity = (existingItem.quantity || 1) + 1;
                        } else {
                            player.inventory.items.push({
                                id: selectedRadar.id,
                                name: selectedRadar.name,
                                quantity: 1,
                                type: selectedRadar.type,
                                boost: selectedRadar.boost,
                                emoji: selectedRadar.emoji,
                                description: selectedRadar.description
                            });
                        }

                        if (player.inventory.items) {
                            player.inventory.items.forEach(item => {
                                if (item.type === "radar" && item.equipped) {
                                    item.equipped = false;
                                }
                            });
                        }

                        const purchasedItem = player.inventory.items.find(i => i.id === selectedRadar.id);
                        purchasedItem.equipped = true;
                        purchasedItem.usedTime = Date.now();

                        player.stats.zeni -= selectedRadar.price;
                        applyEquipmentBoosts(player);
                        savePlayerData(playerData);

                        return api.sendMessage(
                            "üì° MUA RADA TH√ÄNH C√îNG! üì°\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `${selectedRadar.emoji} ƒê√£ mua: ${selectedRadar.name}\n` +
                            `üí∞ Gi√°: ${selectedRadar.price.toLocaleString()} Zeni\n` +
                            `üìä Hi·ªáu qu·∫£: TƒÉng EXP v√† S·ª©c M·∫°nh +${Math.round((selectedRadar.boost - 1) * 100)}%\n` +
                            `‚è≥ Th·ªùi gian hi·ªáu l·ª±c: Vƒ©nh vi·ªÖn\n\n` +
                            `üí∞ S·ªë ùó≠ùó≤ùóªùó∂ c√≤n l·∫°i: ${player.stats.zeni.toLocaleString()}\n\n` +
                            `üí° Rada ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông trang b·ªã!`,
                            threadID, messageID
                        );
                    }
                    else if (target[1]?.toLowerCase() === "do" || target[1]?.toLowerCase() === "equipment") {
                        function applyEquipmentEffect(player, item) {
                            switch (item.type) {
                                case "armor":
                                    player.stats.health = Math.floor(player.stats.health * item.boost);
                                    player.stats.currentHealth = player.stats.health;
                                    break;

                                case "gloves":
                                    player.stats.damage = Math.floor(player.stats.damage * item.boost);
                                    break;

                                case "boots":
                                    player.stats.ki = Math.floor(player.stats.ki * item.boost);
                                    player.stats.currentKi = player.stats.ki;
                                    break;
                            }
                        }

                        const equipmentList = Object.values(EQUIPMENT_ITEMS).filter(item =>
                            item.planet === player.planet || item.type === "radar"
                        ).filter(item =>
                            player.stats.power >= item.requiredPower
                        );

                        if (!target[2]) {

                            const equipmentByType = {
                                armor: equipmentList.filter(item => item.type === "armor"),
                                gloves: equipmentList.filter(item => item.type === "gloves"),
                                boots: equipmentList.filter(item => item.type === "boots"),
                                radar: equipmentList.filter(item => item.type === "radar")
                            };

                            let msg = `üõ°Ô∏è SHOP TRANG B·ªä - ${PLANETS[player.planet].name} üõ°Ô∏è\n`;
                            msg += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";


                            msg += "üß• GI√ÅP (TƒÉng HP):\n";
                            equipmentByType.armor.forEach((item, index) => {
                                msg += `${index + 1}. ${item.emoji} ${item.name} - ${item.price.toLocaleString()} Zeni\n`;
                                msg += `   ‚Ä¢ ${item.description}\n`;
                                msg += `   ‚Ä¢ TƒÉng HP: +${Math.round((item.boost - 1) * 100)}%\n`;
                            });


                            msg += "\nü•ä GƒÇNG TAY (TƒÉng S·ª©c ƒê√°nh):\n";
                            equipmentByType.gloves.forEach((item, index) => {
                                msg += `${equipmentByType.armor.length + index + 1}. ${item.emoji} ${item.name} - ${item.price.toLocaleString()} Zeni\n`;
                                msg += `   ‚Ä¢ ${item.description}\n`;
                                msg += `   ‚Ä¢ TƒÉng S·ª©c ƒê√°nh: +${Math.round((item.boost - 1) * 100)}%\n`;
                            });


                            msg += "\nüëü GI√ÄY (TƒÉng Ki):\n";
                            equipmentByType.boots.forEach((item, index) => {
                                msg += `${equipmentByType.armor.length + equipmentByType.gloves.length + index + 1}. ${item.emoji} ${item.name} - ${item.price.toLocaleString()} Zeni\n`;
                                msg += `   ‚Ä¢ ${item.description}\n`;
                                msg += `   ‚Ä¢ TƒÉng Ki: +${Math.round((item.boost - 1) * 100)}%\n`;
                            });

                            msg += "\nC√°ch d√πng:\n";
                            msg += "‚Ä¢ .dball shop do <s·ªë th·ª© t·ª±>\n";
                            msg += "‚Ä¢ VD: .dball shop do 1 (Mua trang b·ªã s·ªë 1)\n\n";
                            msg += `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}`;

                            return api.sendMessage(msg, threadID, messageID);
                        }

                        const itemIndex = parseInt(target[2]) - 1;

                        if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= equipmentList.length) {
                            return api.sendMessage("‚ùå S·ªë th·ª© t·ª± trang b·ªã kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                        }

                        const selectedEquipment = equipmentList[itemIndex];


                        if (player.stats.zeni < selectedEquipment.price) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng ƒë·ªß ùó≠ùó≤ùóªùó∂ ƒë·ªÉ mua!\n` +
                                `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                                `üí∞ C·∫ßn: ${selectedEquipment.price.toLocaleString()}`,
                                threadID, messageID
                            );
                        }


                        if (!player.inventory) player.inventory = { items: [] };
                        if (!player.inventory.items) player.inventory.items = [];

                        const existingItem = player.inventory.items.find(i => i.id === selectedEquipment.id);

                        if (existingItem) {
                            existingItem.quantity = (existingItem.quantity || 1) + 1;
                        } else {
                            player.inventory.items.push({
                                id: selectedEquipment.id,
                                name: selectedEquipment.name,
                                quantity: 1,
                                type: selectedEquipment.type,
                                boost: selectedEquipment.boost,
                                emoji: selectedEquipment.emoji,
                                description: selectedEquipment.description,

                            });
                        }
                        if (player.inventory.items) {
                            player.inventory.items.forEach(item => {
                                if (item.type === selectedEquipment.type && item.equipped) {
                                    item.equipped = false;
                                }
                            });
                        }

                        const purchasedItem = player.inventory.items.find(i => i.id === selectedEquipment.id);
                        if (purchasedItem) {
                            player.inventory.items.forEach(item => {
                                if (item.type === purchasedItem.type && item.equipped) {
                                    item.equipped = false;
                                }
                            });

                            purchasedItem.equipped = true;
                            purchasedItem.usedTime = Date.now();

                            applyEquipmentEffect(player, purchasedItem);
                        }
                        savePlayerData(playerData);

                        let effectDescription;
                        switch (selectedEquipment.type) {
                            case "armor":
                                effectDescription = `TƒÉng HP +${Math.round((selectedEquipment.boost - 1) * 100)}%`;
                                break;
                            case "gloves":
                                effectDescription = `TƒÉng S·ª©c ƒê√°nh +${Math.round((selectedEquipment.boost - 1) * 100)}%`;
                                break;
                            case "boots":
                                effectDescription = `TƒÉng Ki +${Math.round((selectedEquipment.boost - 1) * 100)}%`;
                                break;
                            case "radar":
                                effectDescription = `TƒÉng EXP v√† S·ª©c M·∫°nh +${Math.round((selectedEquipment.boost - 1) * 100)}%`;
                                break;
                        }

                        return api.sendMessage(
                            "üõçÔ∏è MUA TRANG B·ªä TH√ÄNH C√îNG!\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `${selectedEquipment.emoji} ƒê√£ mua: ${selectedEquipment.name}\n` +
                            `üí∞ Gi√°: ${selectedEquipment.price.toLocaleString()} Zeni\n` +
                            `üìä Hi·ªáu qu·∫£: ${effectDescription}\n` +
                            `üí∞ S·ªë ùó≠ùó≤ùóªùó∂ c√≤n l·∫°i: ${player.stats.zeni.toLocaleString()}\n\n` +
                            `üí°Trang b·ªã t·ª± ƒë·ªông s·ª≠ d·ª•ng.`,
                            threadID, messageID
                        );
                    }

                    if (target[1]?.toLowerCase() === "bua" || target[1]?.toLowerCase() === "amulet") {
                        const amuletsArray = Object.values(AMULETS);

                        if (!target[2]) {

                            const amuletShopData = {
                                amulets: amuletsArray,
                                player: {
                                    name: player.name,
                                    race: PLANETS[player.planet].name,
                                    zeni: player.stats.zeni
                                }
                            };

                            const amuletShopPath = await createAmuletShopImage(amuletShopData);

                            if (amuletShopPath) {
                                return api.sendMessage(
                                    {
                                        body: "üëµ TI·ªÜM B√ôA B√Ä H·∫†T M√çT üëµ\nCh·ªçn s·ªë th·ª© t·ª± ƒë·ªÉ mua b√πa\nmua : .dball shop bua S·ªë b√πa",
                                        attachment: fs.createReadStream(amuletShopPath)
                                    },
                                    threadID,
                                    () => fs.unlinkSync(amuletShopPath),
                                    messageID
                                );
                            } else {
                                let msg = "üëµ B√Ä H·∫†T M√çT - TI·ªÜM B√ôA üëµ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";

                                amuletsArray.forEach((amulet, index) => {
                                    msg += `${index + 1}. ${amulet.emoji} ${amulet.name}\n`;
                                    msg += `üí∞ Gi√°: ${amulet.price.toLocaleString()} Zeni\n`;
                                    msg += `üìù ${amulet.description}\n\n`;
                                });

                                msg += "C√°ch mua:\n";
                                msg += "‚Ä¢ .dball shop bua <s·ªë th·ª© t·ª±>\n";
                                msg += "‚Ä¢ VD: .dball shop bua 1 (Mua b√πa s·ªë 1)\n\n";
                                msg += `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}`;

                                return api.sendMessage(msg, threadID, messageID);
                            }
                        }

                        const amuletIndex = parseInt(target[2]) - 1;

                        if (isNaN(amuletIndex) || amuletIndex < 0 || amuletIndex >= amuletsArray.length) {
                            return api.sendMessage("‚ùå S·ªë th·ª© t·ª± b√πa kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                        }

                        const amulet = amuletsArray[amuletIndex];

                        if (player.stats.zeni < amulet.price) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng ƒë·ªß ùó≠ùó≤ùóªùó∂ ƒë·ªÉ mua!\n` +
                                `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                                `üí∞ C·∫ßn: ${amulet.price.toLocaleString()}`,
                                threadID, messageID
                            );
                        }

                        if (!player.amulets) player.amulets = [];

                        const existingAmuletIndex = player.amulets.findIndex(a => a.id === amulet.id);
                        if (existingAmuletIndex !== -1) {
                            player.amulets[existingAmuletIndex].expireAt = Date.now() + amulet.duration;

                            player.stats.zeni -= amulet.price;
                            savePlayerData(playerData);

                            const expireTime = new Date(Date.now() + amulet.duration).toLocaleString();
                            return api.sendMessage(
                                "‚ú® ùóöùóúùóî ùóõùóîÃ£ùó° ùóïùó®ÃÄùóî ùóßùóõùóîÃÄùó°ùóõ ùóñùó¢ÃÇùó°ùóö! ‚ú®\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `${amulet.emoji} ƒê√£ gia h·∫°n: ${amulet.name}\n` +
                                `üí∞ Gi√°: ${amulet.price.toLocaleString()} Zeni\n` +
                                `‚è≥ Hi·ªáu l·ª±c ƒë·∫øn: ${expireTime}\n` +
                                `üìù Hi·ªáu qu·∫£: ${amulet.description}`,
                                threadID, messageID
                            );
                        }

                        player.amulets.push({
                            id: amulet.id,
                            name: amulet.name,
                            effect: amulet.effect,
                            boost: amulet.boost || 1,
                            emoji: amulet.emoji,
                            expireAt: Date.now() + amulet.duration
                        });

                        player.stats.zeni -= amulet.price;
                        savePlayerData(playerData);

                        const expireTime = new Date(Date.now() + amulet.duration).toLocaleString();
                        return api.sendMessage(
                            "‚ú® MUA B√ôA TH√ÄNH C√îNG! ‚ú®\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `${amulet.emoji} ƒê√£ mua: ${amulet.name}\n` +
                            `üí∞ Gi√°: ${amulet.price.toLocaleString()} Zeni\n` +
                            `‚è≥ Hi·ªáu l·ª±c ƒë·∫øn: ${expireTime}\n` +
                            `üìù Hi·ªáu qu·∫£: ${amulet.description}`,
                            threadID, messageID
                        );
                    }

                    const shopItemsArray = Object.values(SHOP_ITEMS);

                    if (!target[1]) {
                        let msg = "üè™ ùó¶ùóõùó¢ùó£ ùó©ùóîÃ£ÃÇùóß ùó£ùóõùóîÃÇÃâùó† üè™\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";

                        shopItemsArray.forEach((item, index) => {
                            msg += `${index + 1}. ${item.emoji} ${item.name}\n`;
                            msg += `üí∞ Gi√°: ${item.price.toLocaleString()} Zeni\n`;
                            msg += `üìù ${item.description}\n`;
                            msg += `üì¶ Lo·∫°i: ${item.type === "consumable" ? "Ti√™u hao" : item.type === "equipment" ? "Trang b·ªã" : "ƒê·∫∑c bi·ªát"}\n\n`;
                        });

                        msg += "C√°ch d√πng:\n";
                        msg += "‚Ä¢ .dball shop <s·ªë th·ª© t·ª±> <s·ªë l∆∞·ª£ng>\n";
                        msg += "‚Ä¢ VD: .dball shop 1 1 (Mua v·∫≠t ph·∫©m s·ªë 1, s·ªë l∆∞·ª£ng 1)\n\n";
                        msg += "‚Ä¢ .ùó±ùóØùóÆùóπùóπ ùòÄùóµùóºùóΩ ùóØùòÇùóÆ - ùó†ùóºÃõÃâ ùòÅùó∂ùó≤Ã£ÃÇùó∫ ùóØùòÇÃÄùóÆ ùó∞ùòÇÃâùóÆ ùóïùóÆÃÄ ùóõùóÆÃ£ùòÅ ùó†ùó∂ÃÅùòÅ\n";
                        msg += "‚Ä¢ .ùó±ùóØùóÆùóπùóπ ùòÄùóµùóºùóΩ ùóøùóÆùó±ùóÆ - ùó†ùóºÃõÃâ ùòÅùó∂ùó≤Ã£ÃÇùó∫ ùóøùóÆùó±ùóÆ\n";
                        msg += "‚Ä¢ .ùó±ùóØùóÆùóπùóπ ùòÄùóµùóºùóΩ ùó±ùóº - ùó†ùóºÃõÃâ ùòÅùó∂ùó≤Ã£ÃÇùó∫ ùòÅùóøùóÆùóªùó¥ ùóØùó∂Ã£\n\n";
                        msg += `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}`;

                        return api.sendMessage(msg, threadID, messageID);
                    }

                    const itemIndex = parseInt(target[1]) - 1;
                    const quantity = parseInt(target[2]) || 1;

                    if (isNaN(itemIndex) || itemIndex < 0 || itemIndex >= shopItemsArray.length) {
                        return api.sendMessage("‚ùå S·ªë th·ª© t·ª± v·∫≠t ph·∫©m kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    const item = shopItemsArray[itemIndex];
                    const totalCost = item.price * quantity;

                    if (player.stats.zeni < totalCost) {
                        return api.sendMessage(
                            `‚ùå Kh√¥ng ƒë·ªß ùó≠ùó≤ùóªùó∂ ƒë·ªÉ mua!\n` +
                            `üí∞ ùó≠ùó≤ùóªùó∂ hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                            `üí∞ C·∫ßn: ${totalCost.toLocaleString()}`,
                            threadID, messageID
                        );
                    }

                    if (!player.inventory) player.inventory = { items: [] };
                    if (!player.inventory.items) player.inventory.items = [];

                    const existingItem = player.inventory.items.find(i => i.id === item.id);

                    if (existingItem) {
                        existingItem.quantity += quantity;
                    } else {
                        player.inventory.items.push({
                            id: item.id,
                            quantity: quantity,
                            type: item.type
                        });
                    }

                    player.stats.zeni -= totalCost;
                    savePlayerData(playerData);

                    return api.sendMessage(
                        "üõçÔ∏è ùó†ùó®ùóî ùóßùóõùóîÃÄùó°ùóõ ùóñùó¢ÃÇùó°ùóö!\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `${item.emoji} ƒê√£ mua: ${item.name} x${quantity}\n` +
                        `üí∞ T·ªïng gi√°: ${totalCost.toLocaleString()} Zeni\n` +
                        `üí∞ S·ªë ùó≠ùó≤ùóªùó∂ c√≤n l·∫°i: ${player.stats.zeni.toLocaleString()}\n\n` +
                        `üí° D√πng .dball use ${item.id} ƒë·ªÉ s·ª≠ d·ª•ng/trang b·ªã`,
                        threadID, messageID
                    );
                }
                case "train": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    const oldStats = { ...player.stats };
                    const now = Date.now();
                    const cooldown = 30000;

                    if (now - player.lastTrain < cooldown) {
                        const remainingTime = Math.ceil((cooldown - (now - player.lastTrain)) / 1000);
                        return api.sendMessage(`‚è≥ Vui l√≤ng ƒë·ª£i ${remainingTime}s ƒë·ªÉ h·ªìi s·ª©c!`, threadID, messageID);
                    }
                    if (player.quests?.active && player.quests.active.length > 0) {
                        const activeQuestId = player.quests.active[0];
                        if (activeQuestId && QUESTS[activeQuestId]) {
                            const quest = QUESTS[activeQuestId];
                            if (quest.type === 'TRAINING') {
                                if (!player.quests.progress[activeQuestId]) {
                                    player.quests.progress[activeQuestId] = 0;
                                }
                                player.quests.progress[activeQuestId]++;

                                if (player.quests.progress[activeQuestId] >= quest.target) {
                                    api.sendMessage(
                                        "‚ú® NHI·ªÜM V·ª§ HO√ÄN TH√ÄNH! ‚ú®\n" +
                                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                        `üìù ${quest.name}\n` +
                                        `‚≠ê Ti·∫øn ƒë·ªô: ${player.quests.progress[activeQuestId]}/${quest.target}\n\n` +
                                        "üí° D√πng l·ªánh .dball quest ho√†n ƒë·ªÉ nh·∫≠n th∆∞·ªüng!",
                                        threadID
                                    );
                                }
                            }
                        }
                    }
                    const currentLocation = getTrainingLocation(player.stats.power);
                    const locationMultiplier = currentLocation.multiplier;

                    const powerGain = calculatePowerGain(player.stats.power, locationMultiplier);

                    let locationChangeMessage = '';
                    const newLocation = getTrainingLocation(player.stats.power + powerGain);
                    if (newLocation.name !== currentLocation.name) {
                        locationChangeMessage = `\nüåü B·∫°n ƒë√£ m·ªü kh√≥a ƒë·ªãa ƒëi·ªÉm luy·ªán t·∫≠p m·ªõi: ${newLocation.name}!`;
                    }

                    let expBonus = 1.0;
                    let hasRadar = false;
                    if (player.inventory?.items) {
                        for (const item of player.inventory.items) {
                            if (item.equipped && item.type === "radar") {
                                expBonus *= item.boost || 1.2;
                                hasRadar = true;
                            }
                        }
                    }
                    const trainStats = {
                        expMultiplier: 1.0,
                        powerMultiplier: 1.0,
                        zeniMultiplier: 1.0
                    };
                    const amuletEffects = applyAmuletEffects(player, trainStats);

                    const finalPowerGain = Math.floor(powerGain * trainStats.powerMultiplier);

                    player.stats.power = checkStatLimit(
                        player.stats.power + finalPowerGain,
                        'POWER'
                    );

                    const expGain = Math.floor(calculateExpGain(player.stats.power, player.stats.damage) * expBonus * trainStats.expMultiplier);

                    if (player.stats.exp + expGain > MAX_EXP_STORAGE) {
                        player.stats.exp = MAX_EXP_STORAGE;
                    } else {
                        player.stats.exp += expGain;
                    }

                    const normalZeni = Math.floor(Math.random() * (ZENI_INFO.TRAIN_MAX - ZENI_INFO.TRAIN_MIN + 1) + ZENI_INFO.TRAIN_MIN);
                    if (!player.stats.zeni) player.stats.zeni = 0;

                    player.stats.zeni += Math.floor(normalZeni * trainStats.zeniMultiplier);

                    let zeniMessage = "";
                    let zeniGain = Math.floor(normalZeni * trainStats.zeniMultiplier);


                    if (Math.random() < ZENI_INFO.FIND_CHANCE) {
                        const specialZeni = Math.floor(Math.random() * (ZENI_INFO.SPECIAL_MAX - ZENI_INFO.SPECIAL_MIN + 1) + ZENI_INFO.SPECIAL_MIN);
                        const bonusZeni = Math.floor(specialZeni * trainStats.zeniMultiplier);
                        player.stats.zeni += bonusZeni;
                        zeniMessage += `\nüåü B·∫†N T√åM TH·∫§Y T√öI ZENI ƒê·∫∂C BI·ªÜT! +${bonusZeni} ZENI`;
                        zeniGain += bonusZeni;
                    }

                    player.lastTrain = now;

                    const meetMaster = Math.random() < 0.3;
                    let masterMessage = "";
                    let dragonBallMessage = "";

                    let dragonBallChance = DRAGON_BALL_INFO.FIND_CHANCE;
                    if (hasRadar) {
                        dragonBallChance *= DRAGON_BALL_INFO.RADAR_BOOST;
                    }


                    if (Math.random() < dragonBallChance) {
                        const dragonBallData = loadDragonBallData();

                        const availableBalls = Object.entries(dragonBallData[player.planet])
                            .filter(([star, owner]) => owner === null)
                            .map(([star]) => parseInt(star));

                        if (availableBalls.length > 0) {
                            const randomStar = availableBalls[Math.floor(Math.random() * availableBalls.length)];

                            dragonBallData[player.planet][randomStar] = senderID;
                            saveDragonBallData(dragonBallData);

                            if (!player.inventory) player.inventory = { dragonBalls: [] };
                            if (!player.inventory.dragonBalls) player.inventory.dragonBalls = [];

                            player.inventory.dragonBalls.push({
                                planet: player.planet,
                                star: randomStar
                            });
                            updateQuestProgress(player, QUEST_TYPES.COLLECT);
                            dragonBallMessage += `\n\nüåü B·∫†N ƒê√É T√åM TH·∫§Y NG·ªåC R·ªíNG ${randomStar} SAO!`;

                            if (hasAllDragonBalls(player, player.planet)) {
                                dragonBallMessage += "\n\nüêâ B·∫†N ƒê√É THU TH·∫¨P ƒê·ª¶ 7 VI√äN NG·ªåC R·ªíNG!\n";
                                dragonBallMessage += "üí° D√πng .dball wish ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc!";
                            }
                        }
                    }
                    const evolution = checkAndUpdateEvolution(player);
                    let evolutionMessage = "";
                    if (evolution) {
                        evolutionMessage = "\n\nüåü ùóßùóúùóòÃÇÃÅùó° ùóõùó¢ÃÅùóî ùó†ùó¢ÃõÃÅùóú! üåü\n" +
                            `B·∫°n ƒë√£ ti·∫øn h√≥a th√†nh: ${evolution.name}\n` +
                            `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${evolution.oldPower.toLocaleString()} ‚Üí ${evolution.newPower.toLocaleString()}\n` +
                            `‚öîÔ∏è S·ª©c ƒë√°nh: ${evolution.oldDamage.toLocaleString()} ‚Üí ${evolution.newDamage.toLocaleString()}\n` +
                            `‚ú® Ki: ${evolution.oldKi.toLocaleString()} ‚Üí ${evolution.newKi.toLocaleString()}\n` +
                            `‚ù§Ô∏è HP: ${evolution.oldHealth.toLocaleString()} ‚Üí ${evolution.newHealth.toLocaleString()}`;
                    }
                    updateQuestProgress(player, QUEST_TYPES.TRAINING, playerData);
                    updateQuestProgress(player, QUEST_TYPES.POWER, playerData);
                    savePlayerData(playerData);
                    const trainImageData = {
                        name: player.name,
                        planetTheme: PLANET_THEME_COLORS[player.planet] || PLANET_THEME_COLORS.EARTH,
                        expGain: expGain,
                        oldPower: player.stats.power - finalPowerGain,
                        newPower: player.stats.power,
                        zeniGain: zeniGain,
                        powerLevel: player.stats.power,
                        oldHP: oldStats.health,
                        newHP: player.stats.health,
                        oldKi: oldStats.ki,
                        newKi: player.stats.ki,
                        oldDamage: oldStats.damage,
                        newDamage: player.stats.damage,
                        planet: player.planet,
                        evolution: player.evolution?.name || null,
                        race: PLANETS[player.planet].name,
                        equipment: player.inventory?.items?.filter(item => item.equipped) || [],
                        amulets: player.amulets?.filter(amulet => amulet.expireAt > Date.now()) || [],
                        dragonBalls: player.inventory?.dragonBalls?.filter(ball => ball.planet === player.planet)?.length || 0,
                        fonts: {
                            saiyan: getFontPath("Saiyan-Sans.ttf"),
                            arial: getFontPath("Arial.ttf")
                        },
                        location: newLocation,
                        locationMultiplier: locationMultiplier
                    };

                    const imagePath = await createTrainImage(trainImageData);
                    let amuletMessage = "";
                    if (amuletEffects && amuletEffects.applied) {
                        amuletMessage = "\n\nüîÆ HI·ªÜU ·ª®NG B√ôA ƒêANG K√çCH HO·∫†T:";
                        amuletEffects.effects.forEach(effect => {
                            amuletMessage += `\n${effect.emoji} ${effect.name}: ${effect.effect}`;
                        });
                    }
                    validatePlayerSkills(player);

                    let messageContent = "‚öîÔ∏è K·∫æT QU·∫¢ LUY·ªÜN T·∫¨P ‚öîÔ∏è\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `üèãÔ∏è ƒê·ªãa ƒëi·ªÉm: ${newLocation.name} (x${newLocation.multiplier})\n` +
                        `üí° D√πng .dball upgrade ƒë·ªÉ n√¢ng c·∫•p ch·ªâ s·ªë\n` +
                        `üí° D√πng .dball quest ƒë·ªÉ xem nhi·ªám v·ª•\n` +
                        `üí° D√πng .dball learn ƒë·ªÉ h·ªçc kƒ© nƒÉng` +
                        locationChangeMessage +
                        masterMessage +
                        dragonBallMessage +
                        amuletMessage +
                        evolutionMessage;

                    if (imagePath) {
                        return api.sendMessage(
                            {
                                body: messageContent,
                                attachment: fs.createReadStream(imagePath)
                            },
                            threadID,
                            () => fs.unlinkSync(imagePath),
                            messageID
                        );
                    } else {
                        return api.sendMessage(messageContent, threadID, messageID);
                    }
                }
                case "wish": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    const planets = ["EARTH", "NAMEK", "SAIYAN"];
                    let wishPlanet = null;

                    for (const planet of planets) {
                        if (hasAllDragonBalls(player, planet)) {
                            wishPlanet = planet;
                            break;
                        }
                    }

                    if (!wishPlanet) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ch∆∞a thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ b·∫•t k·ª≥ h√†nh tinh n√†o!\n" +
                            "Ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ t√¨m th·∫•y c√°c Ng·ªçc R·ªìng c√≤n thi·∫øu.",
                            threadID, messageID
                        );
                    }

                    if (!target[1]) {
                        return api.sendMessage(
                            "üêâ ùóßùóõùó®ÃõÃ£ùóñ ùóõùóúùóòÃ£ÃÇùó° ƒêùóúùóòÃÇÃÄùó® ùó®Ãõùó¢ÃõÃÅùóñ üêâ\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            "B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng t·ª´ " + PLANETS[wishPlanet].name + "!\n\n" +
                            "Ch·ªçn ƒëi·ªÅu ∆∞·ªõc c·ªßa b·∫°n:\n\n" +
                            "1. üí∞ " + DRAGON_WISHES.ZENI.name + " - " + DRAGON_WISHES.ZENI.reward + "\n" +
                            "2. üí™ " + DRAGON_WISHES.POWER.name + " - " + DRAGON_WISHES.POWER.reward + "\n" +
                            "3. üìä " + DRAGON_WISHES.EXP.name + " - " + DRAGON_WISHES.EXP.reward + "\n\n" +
                            "C√°ch d√πng: .dball wish <1-3>",
                            threadID, messageID
                        );
                    }

                    const choice = parseInt(target[1]);
                    if (isNaN(choice) || choice < 1 || choice > 3) {
                        return api.sendMessage(
                            "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn t·ª´ 1 ƒë·∫øn 3.",
                            threadID, messageID
                        );
                    }

                    let wish, wishName, wishMessage;
                    switch (choice) {
                        case 1:
                            wish = DRAGON_WISHES.ZENI;
                            wishName = "ZENI";
                            break;
                        case 2:
                            wish = DRAGON_WISHES.POWER;
                            wishName = "POWER";
                            break;
                        case 3:
                            wish = DRAGON_WISHES.EXP;
                            wishName = "EXP";
                            break;
                    }

                    wish.effect(player);

                    const dragonBallData = loadDragonBallData();
                    for (let i = 1; i <= 7; i++) {
                        dragonBallData[wishPlanet][i] = null;
                    }
                    saveDragonBallData(dragonBallData);

                    removeDragonBalls(player, wishPlanet);

                    savePlayerData(playerData);

                    return api.sendMessage(
                        "üåü ƒêùóúùóòÃÇÃÄùó® ùó®Ãõùó¢ÃõÃÅùóñ ƒêùóîÃÉ ƒêùó®Ãõùó¢ÃõÃ£ùóñ ùóßùóõùó®ÃõÃ£ùóñ ùóõùóúùóòÃ£ÃÇùó°! üåü\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `R·ªìng th·∫ßn ${wishPlanet === "EARTH" ? "Shenron" : wishPlanet === "NAMEK" ? "Porunga" : "Super Shenron"} ƒë√£ ban cho b·∫°n:\n` +
                        `${wish.name} - ${wish.reward}\n\n` +
                        "üí° C√°c Ng·ªçc R·ªìng ƒë√£ bay ƒëi kh·∫Øp h√†nh tinh sau khi th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc!\n\n" +
                        "Ch·ªâ s·ªë hi·ªán t·∫°i:\n" +
                        `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${player.stats.power.toLocaleString()}\n` +
                        `‚ú® Ki: ${player.stats.ki}\n` +
                        `‚ù§Ô∏è HP: ${player.stats.health}\n` +
                        `üí∞ Zeni: ${player.stats.zeni.toLocaleString()}\n` +
                        `üìä EXP: ${player.stats.exp.toLocaleString()}/${MAX_EXP_STORAGE.toLocaleString()}`,
                        threadID, messageID
                    );
                }
                case "give": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    const mention = Object.keys(event.mentions)[0];
                    if (!mention) {
                        return api.sendMessage(
                            "‚ùå Vui l√≤ng tag ng∆∞·ªùi nh·∫≠n!\n" +
                            "C√°ch d√πng:\n" +
                            "‚Ä¢ T·∫∑ng Ng·ªçc R·ªìng: .dball give @tag <s·ªë_sao>\n" +
                            "‚Ä¢ Chuy·ªÉn Zeni: .dball give @tag zeni <s·ªë_l∆∞·ª£ng>",
                            threadID, messageID
                        );
                    }

                    const targetPlayer = playerData[mention];
                    if (!targetPlayer) {
                        return api.sendMessage("‚ùå Ng∆∞·ªùi n√†y ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }


                    const messageContent = event.body.toLowerCase();
                    if (messageContent.includes("zeni")) {

                        const amount = parseInt(messageContent.split(" ").pop());

                        if (isNaN(amount) || amount <= 0) {
                            return api.sendMessage(
                                "‚ùå S·ªë Zeni kh√¥ng h·ª£p l·ªá!\n" +
                                "C√°ch d√πng: .dball give @tag zeni <s·ªë_l∆∞·ª£ng>\n" +
                                "V√≠ d·ª•: .dball give @name zeni 10000",
                                threadID, messageID
                            );
                        }

                        if (amount > player.stats.zeni) {
                            return api.sendMessage(
                                "‚ùå B·∫°n kh√¥ng ƒë·ªß Zeni ƒë·ªÉ chuy·ªÉn!\n" +
                                `üí∞ S·ªë d∆∞: ${player.stats.zeni.toLocaleString()} Zeni\n` +
                                `üí∞ C·∫ßn chuy·ªÉn: ${amount.toLocaleString()} Zeni`,
                                threadID, messageID
                            );
                        }

                        player.stats.zeni -= amount;
                        targetPlayer.stats.zeni = (targetPlayer.stats.zeni || 0) + amount;

                        savePlayerData(playerData);

                        return api.sendMessage(
                            "üí∞ CHUY·ªÇN ZENI TH√ÄNH C√îNG! üí∞\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `üë§ Ng∆∞·ªùi chuy·ªÉn: ${player.name}\n` +
                            `üë• Ng∆∞·ªùi nh·∫≠n: ${targetPlayer.name}\n` +
                            `üí∏ S·ªë Zeni: ${amount.toLocaleString()}\n\n` +
                            `üí∞ S·ªë d∆∞ ng∆∞·ªùi chuy·ªÉn: ${player.stats.zeni.toLocaleString()}\n` +
                            `üí∞ S·ªë d∆∞ ng∆∞·ªùi nh·∫≠n: ${targetPlayer.stats.zeni.toLocaleString()}`,
                            threadID, messageID
                        );
                    }

                    if (!target[1] || isNaN(parseInt(target[1]))) {
                        return api.sendMessage(
                            "‚ùå C√∫ ph√°p kh√¥ng h·ª£p l·ªá!\n" +
                            "C√°ch d√πng:\n" +
                            "‚Ä¢ T·∫∑ng Ng·ªçc R·ªìng: .dball give @tag <s·ªë_sao>\n" +
                            "‚Ä¢ Chuy·ªÉn Zeni: .dball give @tag zeni <s·ªë_l∆∞·ª£ng>",
                            threadID, messageID
                        );
                    }
                    const starNumber = parseInt(target[1]);
                    if (starNumber < 1 || starNumber > 7) {
                        return api.sendMessage("‚ùå S·ªë sao ph·∫£i t·ª´ 1 ƒë·∫øn 7!", threadID, messageID);
                    }

                    if (!player.inventory?.dragonBalls?.some(ball => ball.star === starNumber)) {
                        return api.sendMessage(
                            `‚ùå B·∫°n kh√¥ng s·ªü h·ªØu Ng·ªçc R·ªìng ${starNumber} sao ƒë·ªÉ t·∫∑ng!`,
                            threadID, messageID
                        );
                    }

                    const ball = player.inventory.dragonBalls.find(ball => ball.star === starNumber);

                    const dragonBallData = loadDragonBallData();
                    dragonBallData[ball.planet][starNumber] = mention;
                    saveDragonBallData(dragonBallData);

                    player.inventory.dragonBalls = player.inventory.dragonBalls.filter(b =>
                        !(b.star === starNumber && b.planet === ball.planet)
                    );

                    if (!targetPlayer.inventory) targetPlayer.inventory = { dragonBalls: [] };
                    if (!targetPlayer.inventory.dragonBalls) targetPlayer.inventory.dragonBalls = [];

                    targetPlayer.inventory.dragonBalls.push({
                        planet: ball.planet,
                        star: starNumber
                    });
                    updateQuestProgress(targetPlayer, QUEST_TYPES.COLLECT);
                    savePlayerData(playerData);

                    return api.sendMessage(
                        "üéÅ T·∫∂NG NG·ªåC R·ªíNG TH√ÄNH C√îNG! üéÅ\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `${player.name} ƒë√£ t·∫∑ng Ng·ªçc R·ªìng ${starNumber} sao cho ${targetPlayer.name}.\n\n` +
                        "üí° Ki·ªÉm tra kho ƒë·ªì b·∫±ng l·ªánh .dball info",
                        threadID, messageID
                    );
                }
                case "upgrade": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    if (!target[1]) {
                        const damageCost = UPGRADE_COSTS.damage(player.stats.damage);
                        const kiCost = UPGRADE_COSTS.ki(player.stats.ki);
                        const healthCost = UPGRADE_COSTS.health(player.stats.health);

                        return api.sendMessage(
                            "‚ö° ùó°ùóîÃÇùó°ùóö ùóñùóîÃÇÃÅùó£ ùóñùóõùóúÃâ ùó¶ùó¢ÃÇÃÅ ‚ö°\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `üìä ùóòùó´ùó£ hi·ªán t·∫°i: ${player.stats.exp.toLocaleString()}\n\n` +
                            "Ch·ªçn ch·ªâ s·ªë ƒë·ªÉ n√¢ng c·∫•p:\n\n" +
                            `1. ‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage} (+10) - C·∫ßn ${damageCost.toLocaleString()} EXP\n` +
                            `2. ‚ú® Ki: ${player.stats.ki} (+10) - C·∫ßn ${kiCost.toLocaleString()} EXP\n` +
                            `3. ‚ù§Ô∏è HP: ${player.stats.health} (+100) - C·∫ßn ${healthCost.toLocaleString()} EXP\n\n` +
                            "C√°ch d√πng: .dball upgrade <1/2/3> [s·ªë l∆∞·ª£ng]",
                            threadID, messageID
                        );
                    }

                    const choice = parseInt(target[1]);
                    const amount = parseInt(target[2]) || 1;

                    if (isNaN(choice) || choice < 1 || choice > 3) {
                        return api.sendMessage("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn 1 (S·ª©c ƒë√°nh), 2 (Ki) ho·∫∑c 3 (HP).", threadID, messageID);
                    }

                    if (isNaN(amount) || amount < 1) {
                        return api.sendMessage("‚ùå S·ªë l∆∞·ª£ng n√¢ng c·∫•p kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    let statToUpgrade, costFunction, increaseAmount, statName;

                    switch (choice) {
                        case 1:
                            statToUpgrade = "damage";
                            costFunction = UPGRADE_COSTS.damage;
                            increaseAmount = 10;
                            statName = "S·ª©c ƒë√°nh";

                            if (player.stats.damage + (increaseAmount * amount) > STAT_LIMITS.DAMAGE) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                    "S·ª©c ƒë√°nh ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                    threadID, messageID
                                );
                            }
                            break;

                        case 2:
                            statToUpgrade = "ki";
                            costFunction = UPGRADE_COSTS.ki;
                            increaseAmount = 10;
                            statName = "Ki";

                            if (player.stats.ki + (increaseAmount * amount) > STAT_LIMITS.KI) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                    "Ki ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                    threadID, messageID
                                );
                            }
                            player.stats.ki += increaseAmount * amount;
                            player.stats.currentKi = player.stats.ki;
                            break;

                        case 3:
                            statToUpgrade = "health";
                            costFunction = UPGRADE_COSTS.health;
                            increaseAmount = 100;
                            statName = "HP";

                            if (player.stats.health + (increaseAmount * amount) > STAT_LIMITS.HP) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p!\n" +
                                    "HP ƒë√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa (50,000,000)",
                                    threadID, messageID
                                );
                            }

                            player.stats.health += increaseAmount * amount;
                            player.stats.maxHealth = player.stats.health;
                            break;

                        default:
                            return api.sendMessage("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    let totalCost = 0;
                    const currentValue = player.stats[statToUpgrade];

                    for (let i = 0; i < amount; i++) {
                        totalCost += costFunction(currentValue + (i * increaseAmount));
                    }

                    if (player.stats.exp < totalCost) {
                        return api.sendMessage(
                            `‚ùå Kh√¥ng ƒë·ªß ùóòùó´ùó£ ƒë·ªÉ n√¢ng c·∫•p!\n` +
                            `üìä ùóòùó´ùó£ hi·ªán t·∫°i: ${player.stats.exp.toLocaleString()}\n` +
                            `üìä ùóòùó´ùó£ c·∫ßn: ${totalCost.toLocaleString()}\n` +
                            `üìä C√≤n thi·∫øu: ${(totalCost - player.stats.exp).toLocaleString()} EXP`,
                            threadID, messageID
                        );
                    }

                    player.stats.exp -= totalCost;
                    player.stats[statToUpgrade] += increaseAmount * amount;

                    savePlayerData(playerData);

                    return api.sendMessage(
                        "üéâ ùó°ùóîÃÇùó°ùóö ùóñùóîÃÇÃÅùó£ ùóßùóõùóîÃÄùó°ùóõ ùóñùó¢ÃÇùó°ùóö!\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `${statName} +${increaseAmount * amount}\n` +
                        `üìä ùóòùó´ùó£ -${totalCost.toLocaleString()}\n\n` +
                        "üí° Ch·ªâ s·ªë hi·ªán t·∫°i:\n" +
                        `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${player.stats.power.toLocaleString()}\n` +
                        `‚öîÔ∏è S·ª©c ƒë√°nh: ${player.stats.damage.toLocaleString()}\n` +
                        `‚ú® Ki: ${(player.stats.currentKi || player.stats.ki).toLocaleString()}/${player.stats.ki.toLocaleString()}\n` +
                        `‚ù§Ô∏è HP: ${player.stats.health.toLocaleString()}\n` +
                        `üìä EXP: ${player.stats.exp.toLocaleString()}/${MAX_EXP_STORAGE.toLocaleString()}`,
                        threadID, messageID
                    );
                }
                case "tournament":
                case "tour": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    const tournamentData = loadTournamentData();

                    if (!target[1]) {
                        if (!tournamentData.active) {
                            return api.sendMessage(
                                "üèÜ ƒê·∫†I H·ªòI V√ï THU·∫¨T üèÜ\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!\n\n" +
                                "üí° C√°c l·ªánh gi·∫£i ƒë·∫•u:\n" +
                                "‚Ä¢ .dball tour create <lo·∫°i> - T·∫°o gi·∫£i ƒë·∫•u m·ªõi\n" +
                                "‚Ä¢ .dball tour join - ƒêƒÉng k√Ω tham gia gi·∫£i ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour info - Xem th√¥ng tin gi·∫£i ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour list - Xem danh s√°ch ng∆∞·ªùi tham gia\n" +
                                "‚Ä¢ .dball tour bracket - Xem b·∫£ng ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour start - B·∫Øt ƒë·∫ßu gi·∫£i ƒë·∫•u\n\n" +
                                "üí° C√°c lo·∫°i gi·∫£i ƒë·∫•u:\n" +
                                "‚Ä¢ tenkaichi - ƒê·∫°i H·ªôi V√µ Thu·∫≠t Thi√™n H·∫°\n" +
                                "‚Ä¢ cell - Cell Games\n" +
                                "‚Ä¢ universe - Gi·∫£i ƒê·∫•u S·ª©c M·∫°nh",
                                threadID, messageID
                            );
                        }

                        if (!tournamentData.active?.type || !TOURNAMENT_TYPES[tournamentData.active.type]) {
                            return api.sendMessage("‚ùå D·ªØ li·ªáu gi·∫£i ƒë·∫•u kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                        }

                        const tournament = tournamentData.active;
                        const tournamentType = TOURNAMENT_TYPES[tournament.type];
                        const registeredPlayers = Object.keys(tournamentData.registrations || {}).length;

                        let status;
                        switch (tournament.status) {
                            case "registration":
                                status = "‚è≥ ƒêang m·ªü ƒëƒÉng k√Ω";
                                break;
                            case "ongoing":
                                status = "ü•ä ƒêang di·ªÖn ra";
                                break;
                            case "completed":
                                status = "‚úÖ ƒê√£ k·∫øt th√∫c";
                                break;
                            default:
                                status = "‚è≥ ƒêang ch·ªù ng∆∞·ªùi ƒëƒÉng k√Ω";
                        }

                        return api.sendMessage(
                            `üèÜ ${tournamentType.name.toUpperCase()} üèÜ\n` +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `üìù M√¥ t·∫£: ${tournamentType.description}\n` +
                            `üëë Ng∆∞·ªùi t·ªï ch·ª©c: ${tournament.organizer?.name || "Kh√¥ng x√°c ƒë·ªãnh"}\n` +
                            `‚è∞ Tr·∫°ng th√°i: ${status}\n` +
                            `üë• S·ªë ng∆∞·ªùi tham gia: ${registeredPlayers}/${tournamentType.maxPlayers}\n` +
                            `üí∞ L·ªá ph√≠ tham gia: ${tournamentType.entryFee.toLocaleString()} Zeni\n\n` +
                            "üèÖ Gi·∫£i th∆∞·ªüng:\n" +
                            `ü•á H·∫°ng nh·∫•t: ${tournamentType.rewards.first.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.first.exp.toLocaleString()} EXP\n` +
                            `ü•à H·∫°ng nh√¨: ${tournamentType.rewards.second.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.second.exp.toLocaleString()} EXP\n` +
                            `ü•â B√°n k·∫øt: ${tournamentType.rewards.semifinal.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.semifinal.exp.toLocaleString()} EXP\n\n` +
                            "üí° D√πng .dball tour join ƒë·ªÉ ƒëƒÉng k√Ω tham gia",
                            threadID, messageID
                        );
                    }

                    switch (target[1].toLowerCase()) {
                        case "create": {
                            if (tournamentData.active && tournamentData.active.status !== "completed") {
                                return api.sendMessage(
                                    "‚ùå ƒê√£ c√≥ gi·∫£i ƒë·∫•u ƒëang di·ªÖn ra!\n" +
                                    "Vui l√≤ng ƒë·ª£i gi·∫£i ƒë·∫•u hi·ªán t·∫°i k·∫øt th√∫c.",
                                    threadID, messageID
                                );
                            }

                            const tournamentType = target[2]?.toLowerCase();
                            if (!tournamentType || !TOURNAMENT_TYPES[tournamentType.toUpperCase()]) {
                                return api.sendMessage(
                                    "‚ùå Vui l√≤ng ch·ªçn lo·∫°i gi·∫£i ƒë·∫•u h·ª£p l·ªá!\n\n" +
                                    "C√°c lo·∫°i gi·∫£i ƒë·∫•u:\n" +
                                    "‚Ä¢ tenkaichi - ƒê·∫°i H·ªôi V√µ Thu·∫≠t Thi√™n H·∫°\n" +
                                    "‚Ä¢ cell - Cell Games\n" +
                                    "‚Ä¢ universe - Gi·∫£i ƒê·∫•u S·ª©c M·∫°nh\n\n" +
                                    "C√°ch d√πng: .dball tour create <lo·∫°i>",
                                    threadID, messageID
                                );
                            }

                            const tournamentInfo = TOURNAMENT_TYPES[tournamentType.toUpperCase()];

                            if (player.stats.power < tournamentInfo.minPower) {
                                return api.sendMessage(
                                    `‚ùå S·ª©c m·∫°nh kh√¥ng ƒë·ªß ƒë·ªÉ t·ªï ch·ª©c ${tournamentInfo.name}!\n` +
                                    `üí™ S·ª©c m·∫°nh c·ªßa b·∫°n: ${player.stats.power.toLocaleString()}\n` +
                                    `üí™ Y√™u c·∫ßu: ${tournamentInfo.minPower.toLocaleString()}`,
                                    threadID, messageID
                                );
                            }

                            const organizationFee = tournamentInfo.entryFee * 2;
                            if (player.stats.zeni < organizationFee) {
                                return api.sendMessage(
                                    `‚ùå Kh√¥ng ƒë·ªß Zeni ƒë·ªÉ t·ªï ch·ª©c gi·∫£i ƒë·∫•u!\n` +
                                    `üí∞ Zeni hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                                    `üí∞ Ph√≠ t·ªï ch·ª©c: ${organizationFee.toLocaleString()}`,
                                    threadID, messageID
                                );
                            }

                            player.stats.zeni -= organizationFee;

                            tournamentData.active = {
                                type: tournamentType.toUpperCase(),
                                status: "registration",
                                startTime: Date.now(),
                                endTime: null,
                                organizer: {
                                    id: senderID,
                                    name: player.name
                                },
                                matches: [],
                                rounds: {},
                                currentRound: 0,
                                winners: {
                                    first: null,
                                    second: null,
                                    semifinalists: []
                                }
                            };

                            tournamentData.registrations = {};

                            tournamentData.registrations[senderID] = {
                                id: senderID,
                                name: player.name,
                                power: player.stats.power,
                                registrationTime: Date.now()
                            };

                            saveTournamentData(tournamentData);
                            savePlayerData(playerData);

                            return api.sendMessage(
                                `üèÜ ƒê√É T·∫†O GI·∫¢I ƒê·∫§U TH√ÄNH C√îNG! üèÜ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üèüÔ∏è Gi·∫£i ƒë·∫•u: ${tournamentInfo.name}\n` +
                                `üëë Ng∆∞·ªùi t·ªï ch·ª©c: ${player.name}\n` +
                                `üí∞ Ph√≠ t·ªï ch·ª©c ƒë√£ tr·ª´: ${organizationFee.toLocaleString()} Zeni\n` +
                                `‚è∞ Tr·∫°ng th√°i: ƒêang m·ªü ƒëƒÉng k√Ω\n\n` +
                                `üèÖ Gi·∫£i th∆∞·ªüng:\n` +
                                `ü•á H·∫°ng nh·∫•t: ${tournamentInfo.rewards.first.zeni.toLocaleString()} Zeni, ${tournamentInfo.rewards.first.exp.toLocaleString()} EXP\n` +
                                `ü•à H·∫°ng nh√¨: ${tournamentInfo.rewards.second.zeni.toLocaleString()} Zeni, ${tournamentInfo.rewards.second.exp.toLocaleString()} EXP\n` +
                                `ü•â B√°n k·∫øt: ${tournamentInfo.rewards.semifinal.zeni.toLocaleString()} Zeni, ${tournamentInfo.rewards.semifinal.exp.toLocaleString()} EXP\n\n` +
                                `üí° D√πng .dball tour join ƒë·ªÉ ƒëƒÉng k√Ω tham gia`,
                                threadID, messageID
                            );
                        }

                        case "join": {
                            if (!tournamentData.active) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!",
                                    threadID, messageID
                                );
                            }

                            if (tournamentData.active.status !== "registration") {
                                return api.sendMessage(
                                    "‚ùå Gi·∫£i ƒë·∫•u ƒë√£ ƒë√≥ng ƒëƒÉng k√Ω ho·∫∑c ƒë√£ b·∫Øt ƒë·∫ßu!",
                                    threadID, messageID
                                );
                            }

                            if (tournamentData.registrations[senderID]) {
                                return api.sendMessage(
                                    "‚ùå B·∫°n ƒë√£ ƒëƒÉng k√Ω tham gia gi·∫£i ƒë·∫•u n√†y r·ªìi!",
                                    threadID, messageID
                                );
                            }

                            const tournamentType = TOURNAMENT_TYPES[tournamentData.active.type];

                            const participantCount = Object.keys(tournamentData.registrations).length;
                            if (participantCount >= tournamentType.maxPlayers) {
                                return api.sendMessage(
                                    "‚ùå Gi·∫£i ƒë·∫•u ƒë√£ ƒë·ªß s·ªë l∆∞·ª£ng ng∆∞·ªùi tham gia!\n" +
                                    `üë• T·ªëi ƒëa: ${tournamentType.maxPlayers} ng∆∞·ªùi`,
                                    threadID, messageID
                                );
                            }

                            if (player.stats.zeni < tournamentType.entryFee) {
                                return api.sendMessage(
                                    `‚ùå Kh√¥ng ƒë·ªß Zeni ƒë·ªÉ ƒëƒÉng k√Ω!\n` +
                                    `üí∞ Zeni hi·ªán c√≥: ${player.stats.zeni.toLocaleString()}\n` +
                                    `üí∞ L·ªá ph√≠: ${tournamentType.entryFee.toLocaleString()}`,
                                    threadID, messageID
                                );
                            }

                            if (player.stats.power < tournamentType.minPower) {
                                return api.sendMessage(
                                    `‚ùå S·ª©c m·∫°nh kh√¥ng ƒë·ªß ƒë·ªÉ tham gia ${tournamentType.name}!\n` +
                                    `üí™ S·ª©c m·∫°nh c·ªßa b·∫°n: ${player.stats.power.toLocaleString()}\n` +
                                    `üí™ Y√™u c·∫ßu t·ªëi thi·ªÉu: ${tournamentType.minPower.toLocaleString()}`,
                                    threadID, messageID
                                );
                            }

                            if (player.stats.power > tournamentType.maxPower) {
                                return api.sendMessage(
                                    `‚ùå S·ª©c m·∫°nh qu√° cao ƒë·ªÉ tham gia ${tournamentType.name}!\n` +
                                    `üí™ S·ª©c m·∫°nh c·ªßa b·∫°n: ${player.stats.power.toLocaleString()}\n` +
                                    `üí™ Gi·ªõi h·∫°n: ${tournamentType.maxPower.toLocaleString()}`,
                                    threadID, messageID
                                );
                            }

                            player.stats.zeni -= tournamentType.entryFee;

                            tournamentData.registrations[senderID] = {
                                id: senderID,
                                name: player.name,
                                power: player.stats.power,
                                registrationTime: Date.now()
                            };

                            saveTournamentData(tournamentData);
                            savePlayerData(playerData);

                            return api.sendMessage(
                                `üèÜ ƒêƒÇNG K√ù TH√ÄNH C√îNG! üèÜ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üèüÔ∏è Gi·∫£i ƒë·∫•u: ${tournamentType.name}\n` +
                                `üë§ ƒê√£ ƒëƒÉng k√Ω: ${Object.keys(tournamentData.registrations).length}/${tournamentType.maxPlayers} ng∆∞·ªùi\n` +
                                `üí∞ L·ªá ph√≠ ƒë√£ tr·ª´: ${tournamentType.entryFee.toLocaleString()} Zeni\n\n` +
                                `üí° Ch·ªù ban t·ªï ch·ª©c b·∫Øt ƒë·∫ßu gi·∫£i ƒë·∫•u`,
                                threadID, messageID
                            );
                        }

                        case "start": {
                            if (!tournamentData.active) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!",
                                    threadID, messageID
                                );
                            }

                            if (tournamentData.active.organizer.id !== senderID) {
                                return api.sendMessage(
                                    "‚ùå Ch·ªâ ng∆∞·ªùi t·ªï ch·ª©c m·ªõi c√≥ th·ªÉ b·∫Øt ƒë·∫ßu gi·∫£i ƒë·∫•u!",
                                    threadID, messageID
                                );
                            }

                            if (tournamentData.active.status !== "registration") {
                                return api.sendMessage(
                                    "‚ùå Gi·∫£i ƒë·∫•u ƒë√£ b·∫Øt ƒë·∫ßu ho·∫∑c k·∫øt th√∫c r·ªìi!",
                                    threadID, messageID
                                );
                            }

                            const tournamentType = TOURNAMENT_TYPES[tournamentData.active.type];
                            const participantCount = Object.keys(tournamentData.registrations).length;

                            if (participantCount < tournamentType.minPlayers) {
                                return api.sendMessage(
                                    `‚ùå Ch∆∞a ƒë·ªß ng∆∞·ªùi tham gia ƒë·ªÉ b·∫Øt ƒë·∫ßu gi·∫£i ƒë·∫•u!\n` +
                                    `üë• Hi·ªán t·∫°i: ${participantCount} ng∆∞·ªùi\n` +
                                    `üë• Y√™u c·∫ßu t·ªëi thi·ªÉu: ${tournamentType.minPlayers} ng∆∞·ªùi`,
                                    threadID, messageID
                                );
                            }

                            tournamentData.active.status = "ongoing";
                            tournamentData.active.startTime = Date.now();

                            const players = Object.values(tournamentData.registrations);
                            for (let i = players.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [players[i], players[j]] = [players[j], players[i]];
                            }

                            let validPlayerCount = 2;
                            while (validPlayerCount * 2 <= players.length) {
                                validPlayerCount *= 2;
                            }

                            const tournamentPlayers = players.slice(0, validPlayerCount);

                            tournamentData.active.currentRound = 1;
                            tournamentData.active.rounds = {};
                            tournamentData.active.rounds[1] = [];

                            for (let i = 0; i < tournamentPlayers.length; i += 2) {
                                const matchId = i / 2 + 1;
                                const match = {
                                    id: matchId,
                                    round: 1,
                                    player1: tournamentPlayers[i],
                                    player2: tournamentPlayers[i + 1],
                                    winner: null,
                                    loser: null,
                                    completed: false,
                                    scheduledTime: Date.now() + matchId * 300000
                                };

                                tournamentData.active.rounds[1].push(match);
                                tournamentData.active.matches.push(match);
                            }

                            saveTournamentData(tournamentData);

                            return api.sendMessage(
                                `üèÜ GI·∫¢I ƒê·∫§U ƒê√É B·∫ÆT ƒê·∫¶U! üèÜ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üèüÔ∏è Gi·∫£i ƒë·∫•u: ${tournamentType.name}\n` +
                                `üë• S·ªë ng∆∞·ªùi tham gia: ${tournamentPlayers.length} ng∆∞·ªùi\n` +
                                `ü•ä S·ªë tr·∫≠n ƒë·∫•u v√≤ng 1: ${tournamentData.active.rounds[1].length}\n\n` +
                                `üìã C√ÅC C·∫∂P ƒê·∫§U V√íNG 1:\n` +
                                tournamentData.active.rounds[1].map((match, index) =>
                                    `${index + 1}. ${match.player1.name} VS ${match.player2.name}`
                                ).join("\n") + "\n\n" +
                                `üí° D√πng .dball fight tournament ƒë·ªÉ b·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u c·ªßa b·∫°n`,
                                threadID, messageID
                            );
                        }

                        case "bracket":
                        case "brackets": {
                            if (!tournamentData.active) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!",
                                    threadID, messageID
                                );
                            }

                            if (tournamentData.active.status === "registration") {
                                return api.sendMessage(
                                    "‚ùå Gi·∫£i ƒë·∫•u ch∆∞a b·∫Øt ƒë·∫ßu n√™n ch∆∞a c√≥ b·∫£ng ƒë·∫•u!",
                                    threadID, messageID
                                );
                            }

                            const tournamentType = TOURNAMENT_TYPES[tournamentData.active.type];
                            let bracketMsg = `üèÜ B·∫¢NG ƒê·∫§U ${tournamentType.name.toUpperCase()} üèÜ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;

                            const rounds = Object.keys(tournamentData.active.rounds).sort((a, b) => parseInt(a) - parseInt(b));
                            for (const round of rounds) {
                                const matches = tournamentData.active.rounds[round];
                                bracketMsg += `\nüî∏ V√íNG ${round}:\n`;

                                matches.forEach((match, index) => {
                                    const player1 = match.player1.name;
                                    const player2 = match.player2.name;
                                    const status = match.completed
                                        ? `‚úÖ ${match.winner.name} th·∫Øng`
                                        : "‚è≥ Ch∆∞a ƒë·∫•u";

                                    bracketMsg += `${index + 1}. ${player1} VS ${player2} - ${status}\n`;
                                });
                            }

                            if (tournamentData.active.winners.first) {
                                bracketMsg += "\nüèÜ K·∫æT QU·∫¢ CHUNG CU·ªòC:\n";
                                bracketMsg += `ü•á V√¥ ƒë·ªãch: ${tournamentData.active.winners.first.name}\n`;
                                bracketMsg += `ü•à √Å qu√¢n: ${tournamentData.active.winners.second.name}\n`;

                                if (tournamentData.active.winners.semifinalists.length > 0) {
                                    bracketMsg += `ü•â B√°n k·∫øt: ${tournamentData.active.winners.semifinalists.map(p => p.name).join(", ")}\n`;
                                }
                            }

                            return api.sendMessage(bracketMsg, threadID, messageID);
                        }

                        case "list": {
                            if (!tournamentData.active) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!",
                                    threadID, messageID
                                );
                            }

                            const tournamentType = TOURNAMENT_TYPES[tournamentData.active.type];
                            const participants = Object.values(tournamentData.registrations);

                            participants.sort((a, b) => b.power - a.power);

                            let listMsg = `üë• DANH S√ÅCH NG∆Ø·ªúI THAM GIA üë•\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üèüÔ∏è Gi·∫£i ƒë·∫•u: ${tournamentType.name}\n` +
                                `üë• S·ªë ng∆∞·ªùi ƒëƒÉng k√Ω: ${participants.length}/${tournamentType.maxPlayers}\n\n`;

                            participants.forEach((player, index) => {
                                listMsg += `${index + 1}. ${player.name}\n`;
                                listMsg += `üí™ S·ª©c m·∫°nh: ${player.power.toLocaleString()}\n`;
                            });

                            return api.sendMessage(listMsg, threadID, messageID);
                        }

                        case "info": {
                            if (!tournamentData.active) {
                                return api.sendMessage(
                                    "‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!",
                                    threadID, messageID
                                );
                            }

                            const tournament = tournamentData.active;
                            const tournamentType = TOURNAMENT_TYPES[tournament.type];
                            const participants = Object.values(tournamentData.registrations);

                            let status = "‚è≥ ƒêang ch·ªù ng∆∞·ªùi ƒëƒÉng k√Ω";
                            if (tournament.status === "ongoing") status = "ü•ä ƒêang di·ªÖn ra";
                            else if (tournament.status === "completed") status = "‚úÖ ƒê√£ k·∫øt th√∫c";

                            let playerMatch = null;
                            if (tournament.status === "ongoing") {
                                playerMatch = tournament.matches.find(match =>
                                    !match.completed &&
                                    (match.player1.id === senderID || match.player2.id === senderID)
                                );
                            }

                            let playerMatchMsg = "";
                            if (playerMatch) {
                                const opponent = playerMatch.player1.id === senderID
                                    ? playerMatch.player2.name
                                    : playerMatch.player1.name;

                                playerMatchMsg = `\nü•ä TR·∫¨N ƒê·∫§U C·ª¶A B·∫†N:\n` +
                                    `ƒê·ªëi th·ªß: ${opponent}\n` +
                                    `V√≤ng: ${playerMatch.round}\n` +
                                    `‚è∞ Th·ªùi gian: ${new Date(playerMatch.scheduledTime).toLocaleString()}\n` +
                                    `üí° G√µ .dball fight tournament ƒë·ªÉ b·∫Øt ƒë·∫ßu`;
                            }

                            return api.sendMessage(
                                `üèÜ ${tournamentType.name.toUpperCase()} üèÜ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üìù M√¥ t·∫£: ${tournamentType.description}\n` +
                                `üëë Ng∆∞·ªùi t·ªï ch·ª©c: ${tournament.organizer.name}\n` +
                                `‚è∞ Tr·∫°ng th√°i: ${status}\n` +
                                `üë• S·ªë ng∆∞·ªùi tham gia: ${participants.length}/${tournamentType.maxPlayers}\n` +
                                `üí∞ L·ªá ph√≠ tham gia: ${tournamentType.entryFee.toLocaleString()} Zeni\n\n` +
                                `üèÖ Gi·∫£i th∆∞·ªüng:\n` +
                                `ü•á H·∫°ng nh·∫•t: ${tournamentType.rewards.first.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.first.exp.toLocaleString()} EXP\n` +
                                `ü•à H·∫°ng nh√¨: ${tournamentType.rewards.second.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.second.exp.toLocaleString()} EXP\n` +
                                `ü•â B√°n k·∫øt: ${tournamentType.rewards.semifinal.zeni.toLocaleString()} Zeni, ${tournamentType.rewards.semifinal.exp.toLocaleString()} EXP` +
                                playerMatchMsg,
                                threadID, messageID
                            );
                        }

                        default: {
                            return api.sendMessage(
                                "‚ùå L·ªánh gi·∫£i ƒë·∫•u kh√¥ng h·ª£p l·ªá!\n\n" +
                                "üí° C√°c l·ªánh gi·∫£i ƒë·∫•u:\n" +
                                "‚Ä¢ .dball tour create <lo·∫°i> - T·∫°o gi·∫£i ƒë·∫•u m·ªõi\n" +
                                "‚Ä¢ .dball tour join - ƒêƒÉng k√Ω tham gia gi·∫£i ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour info - Xem th√¥ng tin gi·∫£i ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour list - Xem danh s√°ch ng∆∞·ªùi tham gia\n" +
                                "‚Ä¢ .dball tour bracket - Xem b·∫£ng ƒë·∫•u\n" +
                                "‚Ä¢ .dball tour start - B·∫Øt ƒë·∫ßu gi·∫£i ƒë·∫•u\n\n" +
                                "üí° C√°c lo·∫°i gi·∫£i ƒë·∫•u:\n" +
                                "‚Ä¢ tenkaichi - ƒê·∫°i H·ªôi V√µ Thu·∫≠t Thi√™n H·∫°\n" +
                                "‚Ä¢ cell - Cell Games\n" +
                                "‚Ä¢ universe - Gi·∫£i ƒê·∫•u S·ª©c M·∫°nh",
                                threadID, messageID
                            );
                            break;
                        }
                    }
                }

                case "quest": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }
                    addMissingQuests();
                    fixPlayerQuestProgression(player);
                    if (!player.quests) {
                        player.quests = {
                            active: [],
                            completed: [],
                            progress: {}
                        };
                    }


                    console.log(`Player ${player.name} - Planet: ${player.planet}`);
                    console.log(`Completed quests: ${player.quests.completed.join(", ")}`);


                    const planetQuests = PLANET_QUEST_PROGRESSION[player.planet];
                    console.log(`Planet quests for ${player.planet}: ${planetQuests ? planetQuests.join(", ") : "undefined"}`);

                    if (!planetQuests) {
                        return api.sendMessage(
                            "‚ùå H√†nh tinh c·ªßa b·∫°n ch∆∞a c√≥ nhi·ªám v·ª•!\n" +
                            "Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.",
                            threadID, messageID
                        );
                    }


                    for (const questId in player.quests.progress) {
                        if (!QUESTS[questId]) {
                            console.log(`Removing invalid quest progress: ${questId}`);
                            delete player.quests.progress[questId];
                        }
                    }

                    player.quests.active = player.quests.active.filter(questId => {
                        if (!QUESTS[questId]) {
                            console.log(`Removing invalid active quest: ${questId}`);
                            return false;
                        }
                        return true;
                    });

                    if (player.quests.active.length === 0 && planetQuests.length > player.quests.completed.length) {
                        const nextQuestId = planetQuests[player.quests.completed.length];

                        if (QUESTS[nextQuestId]) {
                            player.quests.active.push(nextQuestId);
                            player.quests.progress[nextQuestId] = 0;
                            console.log(`Added new quest: ${nextQuestId}`);
                        } else {
                            console.error(`Quest ${nextQuestId} not found in QUESTS definition`);
                        }

                        savePlayerData(playerData);
                    }

                    if (target[1] === "ho√†n" || target[1] === "hoan" || target[1] === "complete") {
                        if (player.quests.active.length === 0) {
                            return api.sendMessage("‚ùå B·∫°n kh√¥ng c√≥ nhi·ªám v·ª• n√†o ƒëang l√†m!", threadID, messageID);
                        }

                        const questId = player.quests.active[0];

                        if (!QUESTS[questId]) {
                            console.error(`Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• v·ªõi ID: ${questId}`);


                            player.quests.active = [];


                            if (planetQuests && player.quests.completed.length < planetQuests.length) {
                                const newQuestId = planetQuests[player.quests.completed.length];
                                if (QUESTS[newQuestId]) {
                                    player.quests.active.push(newQuestId);
                                    player.quests.progress[newQuestId] = 0;
                                    savePlayerData(playerData);

                                    return api.sendMessage(
                                        "‚ö†Ô∏è Nhi·ªám v·ª• tr∆∞·ªõc ƒë√≥ kh√¥ng t·ªìn t·∫°i!\n" +
                                        "ƒê√£ t·ª± ƒë·ªông g√°n nhi·ªám v·ª• m·ªõi. H√£y th·ª≠ l·∫°i l·ªánh '.dball quest'",
                                        threadID, messageID
                                    );
                                }
                            }

                            return api.sendMessage(
                                "‚ùå C√≥ l·ªói v·ªõi nhi·ªám v·ª• c·ªßa b·∫°n!\n" +
                                "Kh√¥ng t√¨m th·∫•y th√¥ng tin nhi·ªám v·ª•. Vui l√≤ng li√™n h·ªá admin.",
                                threadID, messageID
                            );
                        }

                        const quest = QUESTS[questId];


                        if (player.quests.progress[questId] < quest.target) {
                            return api.sendMessage(
                                "‚ùå B·∫°n ch∆∞a ho√†n th√†nh nhi·ªám v·ª• n√†y!\n" +
                                `‚è≥ Ti·∫øn ƒë·ªô: ${player.quests.progress[questId]}/${quest.target}\n\n` +
                                "üí° H√£y ti·∫øp t·ª•c th·ª±c hi·ªán nhi·ªám v·ª•!",
                                threadID, messageID
                            );
                        }


                        if (quest.reward.exp) {
                            player.stats.exp += quest.reward.exp;
                            if (player.stats.exp > MAX_EXP_STORAGE) {
                                player.stats.exp = MAX_EXP_STORAGE;
                            }
                        }

                        if (quest.reward.zeni) {
                            player.stats.zeni += quest.reward.zeni;
                        }

                        if (quest.reward.item) {
                            if (!player.inventory) player.inventory = {};
                            if (!player.inventory.items) player.inventory.items = [];

                            if (quest.reward.item) {
                                const existingItem = player.inventory.items.find(i => i.id === quest.reward.item);
                                if (existingItem) {
                                    existingItem.quantity += (quest.reward.quantity || 1);
                                } else {
                                    const itemType = SHOP_ITEMS[quest.reward.item.toUpperCase()]?.type || "quest_item";
                                    player.inventory.items.push({
                                        id: quest.reward.item,
                                        quantity: quest.reward.quantity || 1,
                                        type: itemType
                                    });
                                }
                            }
                        }


                        player.quests.completed.push(questId);
                        player.quests.active = [];


                        if (planetQuests && player.quests.completed.length < planetQuests.length) {
                            const nextQuestId = planetQuests[player.quests.completed.length];
                            if (QUESTS[nextQuestId]) {
                                player.quests.active.push(nextQuestId);
                                player.quests.progress[nextQuestId] = 0;
                            } else {
                                console.error(`Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• ti·∫øp theo: ${nextQuestId}`);
                            }
                        }


                        if (player.quests.completed.length % 3 === 0) {
                            if (!player.stats.level) player.stats.level = 1;
                            player.stats.level += 1;
                        }

                        savePlayerData(playerData);


                        let rewardMsg = "";
                        if (quest.reward.exp) rewardMsg += `üìä ùóòùó´ùó£ +${quest.reward.exp}\n`;
                        if (quest.reward.zeni) rewardMsg += `üí∞ ùó≠ùó≤ùóªùó∂ +${quest.reward.zeni}\n`;
                        if (quest.reward.item && SHOP_ITEMS[quest.reward.item.toUpperCase()]) {
                            const itemName = SHOP_ITEMS[quest.reward.item.toUpperCase()]?.name || quest.reward.item;
                            rewardMsg += `üéÅ ${itemName} x${quest.reward.quantity || 1}\n`;
                        }


                        let nextQuestMsg = "";
                        if (player.quests.active.length > 0) {
                            const nextQuestId = player.quests.active[0];
                            const nextQuest = QUESTS[nextQuestId];
                            if (nextQuest) {
                                nextQuestMsg = "\nüÜï Nhi·ªám v·ª• m·ªõi ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a!\n";
                                nextQuestMsg += `üìù ${nextQuest.name}: ${nextQuest.description}\n`;
                            }
                        } else if (player.quests.completed.length >= (planetQuests?.length || 0)) {
                            nextQuestMsg = "\nüèÜ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ nhi·ªám v·ª•!";
                        } else {
                            nextQuestMsg = "\n‚ùå Kh√¥ng th·ªÉ t√¨m th·∫•y nhi·ªám v·ª• ti·∫øp theo. Li√™n h·ªá admin!";
                        }

                        return api.sendMessage(
                            "üéâ ùóõùó¢ùóîÃÄùó° ùóßùóõùóîÃÄùó°ùóõ ùó°ùóõùóúùóòÃ£ÃÇùó† ùó©ùó®Ã£!\n" +
                            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                            `‚úÖ ${quest.name}\n\n` +
                            "üéÅ Ph·∫ßn th∆∞·ªüng:\n" +
                            rewardMsg +
                            (player.quests.completed.length % 3 === 0 ? `üÜô L√™n c·∫•p! Level ${player.stats.level}\n` : "") +
                            nextQuestMsg + "\n" +
                            "üí° D√πng .dball quest ƒë·ªÉ xem th√¥ng tin nhi·ªám v·ª•",
                            threadID, messageID
                        );
                    }


                    let activeQuests = [];
                    player.quests.active.forEach(questId => {
                        const quest = QUESTS[questId];
                        if (quest) {
                            let progress = player.quests.progress[questId] || 0;
                            activeQuests.push({
                                ...quest,
                                progress: progress
                            });
                        }
                    });

                    let msg = "üìã H·ªÜ TH·ªêNG NHI·ªÜM V·ª§ üìã\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";
                    msg += `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n\n`;

                    if (activeQuests.length > 0) {
                        msg += "üîµ ùó°ùóõùóúùóòÃ£ÃÇùó† ùó©ùó®Ã£ ùóõùóúùóòÃ£ÃÇùó° ùóßùóîÃ£ùóú:\n";
                        activeQuests.forEach((quest, index) => {
                            msg += `${index + 1}. ${quest.name}\n`;
                            msg += `üìù ${quest.description}\n`;
                            msg += `‚è≥ Ti·∫øn ƒë·ªô: ${quest.progress}/${quest.target}\n`;
                            msg += `üéÅ Ph·∫ßn th∆∞·ªüng: ${quest.reward.description}\n\n`;
                        });
                    } else {

                        if (player.quests.completed.length >= planetQuests.length) {
                            msg += "‚úÖ CH√öC M·ª™NG! B·∫†N ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ NHI·ªÜM V·ª§!\n\n";
                        } else {

                            const nextQuestIndex = player.quests.completed.length;

                            if (nextQuestIndex < planetQuests.length) {
                                const nextQuestId = planetQuests[nextQuestIndex];

                                if (QUESTS[nextQuestId]) {
                                    msg += "üü¢ NHI·ªÜM V·ª§ TI·∫æP THEO:\n";
                                    msg += `${QUESTS[nextQuestId].name}\n`;
                                    msg += `üìù ${QUESTS[nextQuestId].description}\n`;
                                    msg += `üéÅ Ph·∫ßn th∆∞·ªüng: ${QUESTS[nextQuestId].reward.description}\n\n`;


                                    player.quests.active.push(nextQuestId);
                                    player.quests.progress[nextQuestId] = 0;
                                    savePlayerData(playerData);

                                    msg += "‚ú® Nhi·ªám v·ª• m·ªõi ƒë√£ ƒë∆∞·ª£c th√™m!\n\n";
                                } else {
                                    msg += `‚ùì KH√îNG T√åM TH·∫§Y NHI·ªÜM V·ª§ TI·∫æP THEO (${nextQuestId})!\n`;
                                    msg += "Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.\n\n";
                                }
                            } else {
                                msg += "‚úÖ B·∫†N ƒê√É HO√ÄN TH√ÄNH T·∫§T C·∫¢ NHI·ªÜM V·ª§!\n\n";
                            }
                        }
                    }

                    const totalQuests = planetQuests ? planetQuests.length : 0;
                    const completedCount = player.quests.completed.length;

                    msg += `üìä Ti·∫øn ƒë·ªô: ${completedCount}/${totalQuests} nhi·ªám v·ª•\n\n`;
                    msg += "üí° C√°ch d√πng: Nhi·ªám v·ª• t·ª± ƒë·ªông ho√†n th√†nh khi ƒë·∫°t ti·∫øn ƒë·ªô";

                    return api.sendMessage(msg, threadID, messageID);
                }

                case "hopthe": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    if (player.hasFused) {
                        return api.sendMessage("‚ùå B·∫°n ƒë√£ h·ª£p th·ªÉ r·ªìi! Kh√¥ng th·ªÉ h·ª£p th·ªÉ th√™m l·∫ßn n·ªØa.", threadID, messageID);
                    }

                    const hasDisciple = player.inventory?.items?.some(item => item.id === "broly_disciple" && item.quantity > 0);

                    if (!hasDisciple) {
                        return api.sendMessage(
                            "‚ùå B·∫°n c·∫ßn c√≥ ƒê·ªá T·ª≠ Broly ƒë·ªÉ th·ª±c hi·ªán h·ª£p th·ªÉ!\n" +
                            "üí° ƒê√°nh b·∫°i Legendary Super Saiyan Broly ƒë·ªÉ c√≥ c∆° h·ªôi nh·∫≠n ƒë·ªá t·ª≠.",
                            threadID, messageID
                        );
                    }

                    const oldPower = player.stats.power;
                    const oldDamage = player.stats.damage;
                    const oldKi = player.stats.ki;
                    const oldHealth = player.stats.health;

                    const bDItem = SPECIAL_ITEMS.BROLY_DISCIPLE;
                    player.stats.power = Math.floor(player.stats.power * bDItem.power_multiplier);
                    player.stats.damage = Math.floor(player.stats.damage * bDItem.damage_multiplier);
                    player.stats.ki = Math.floor(player.stats.ki * bDItem.ki_multiplier);
                    player.stats.health = Math.floor(player.stats.health * bDItem.hp_multiplier);

                    player.stats.currentHealth = player.stats.health;
                    player.stats.currentKi = player.stats.ki;

                    player.evolution = {
                        name: "Super Legendary Warrior",
                        level: 999,
                        description: "H·ª£p th·ªÉ v·ªõi ƒê·ªá T·ª≠ Broly, s·ª©c m·∫°nh kinh ho√†ng",
                        achievedAt: new Date().toISOString(),
                        auraColor: "#FF2D00"
                    };

                    const discipleItem = player.inventory.items.find(item => item.id === "broly_disciple");
                    discipleItem.quantity -= 1;
                    if (discipleItem.quantity <= 0) {
                        player.inventory.items = player.inventory.items.filter(item => item.id !== "broly_disciple");
                    }

                    if (!player.skills) player.skills = [];
                    if (!player.skills.includes("GOKU:GREAT_APE")) {
                        player.skills.push("GOKU:GREAT_APE");
                    }
                    if (!player.skills.includes("KAME:SPIRIT_BOMB")) {
                        player.skills.push("KAME:SPIRIT_BOMB");
                    }

                    player.hasFused = true;
                    savePlayerData(playerData);

                    return api.sendMessage(
                        "üåü H·ª¢P TH·ªÇ HUY·ªÄN THO·∫†I TH√ÄNH C√îNG! üåü\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        "B·∫°n ƒë√£ h·ª£p th·ªÉ th√†nh c√¥ng v·ªõi ƒê·ªá T·ª≠ Broly!\n\n" +
                        "üë§ H√¨nh th√°i m·ªõi: Super Legendary Warrior\n" +
                        "üí™ S·ª©c m·∫°nh: " + oldPower.toLocaleString() + " ‚Üí " + player.stats.power.toLocaleString() + "\n" +
                        "‚öîÔ∏è S·ª©c ƒë√°nh: " + oldDamage.toLocaleString() + " ‚Üí " + player.stats.damage.toLocaleString() + "\n" +
                        "‚ú® Ki: " + oldKi.toLocaleString() + " ‚Üí " + player.stats.ki.toLocaleString() + "\n" +
                        "‚ù§Ô∏è HP: " + oldHealth.toLocaleString() + " ‚Üí " + player.stats.health.toLocaleString() + "\n\n" +
                        "üî• K·ªπ nƒÉng m·ªõi m·ªü kh√≥a: Bi·∫øn Kh·ªâ Kh·ªïng L·ªì, Qu·∫£ C·∫ßu Kinh Kh√≠\n\n" +
                        "‚ö†Ô∏è L∆∞u √Ω: H·ª£p th·ªÉ n√†y l√† vƒ©nh vi·ªÖn!",
                        threadID, messageID
                    );
                }


                case "learn": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    if (!player.planet || !PLANETS[player.planet]) {
                        return api.sendMessage("‚ùå H√†nh tinh c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }

                    const planetMasters = PLANETS[player.planet].masters;
                    if (!planetMasters || planetMasters.length === 0) {
                        return api.sendMessage(
                            "‚ùå Ch·ªâ c√≥ th·ªÉ h·ªçc k·ªπ nƒÉng khi ƒë√£ ch·ªçn s∆∞ ph·ª•!\n" +
                            "üí° M·ªói h√†nh tinh c√≥ s∆∞ ph·ª• ri√™ng:\n" +
                            "‚Ä¢ Tr√°i ƒê·∫•t - Master Roshi\n" +
                            "‚Ä¢ Namek - Piccolo\n" +
                            "‚Ä¢ Saiyan - Goku",
                            threadID, messageID
                        );
                    }

                    if (!target[1]) {

                        let allSkills = [];
                        let skillIndex = 0;

                        const masterId = planetMasters[0];
                        const master = MASTERS[masterId];

                        Object.entries(master.skills).forEach(([skillId, skill]) => {
                            skillIndex++;
                            const isLearned = player.skills.includes(`${masterId}:${skillId}`);
                            const canLearn = player.stats.power >= skill.powerRequired;

                            allSkills.push({
                                index: skillIndex,
                                name: skill.name,
                                description: skill.description,
                                powerRequired: skill.powerRequired,
                                powerScale: skill.powerScale,
                                kiCost: skill.kiCost,
                                isLearned: isLearned,
                                canLearn: canLearn
                            });
                        });


                        const learnImageData = {
                            playerID: senderID,
                            playerName: player.name,
                            playerPower: player.stats.power,
                            playerDamage: player.stats.damage,
                            playerKi: player.stats.ki,
                            master: master.name,
                            masterDescription: master.description,
                            raceName: PLANETS[player.planet].name,
                            planetTheme: PLANET_THEME_COLORS[player.planet] || PLANET_THEME_COLORS.EARTH,
                            skills: allSkills
                        };


                        const learnImagePath = await createLearnImage(learnImageData);

                        if (learnImagePath) {
                            return api.sendMessage(
                                {
                                    body: `üë®‚Äçüè´ ${master.name} - K·ª∏ NƒÇNG C√ì TH·ªÇ H·ªåC üë®‚Äçüè´\nCh·ªçn s·ªë k·ªπ nƒÉng ƒë·ªÉ h·ªçc: .dball learn <s·ªë>`,
                                    attachment: fs.createReadStream(learnImagePath)
                                },
                                threadID,
                                () => fs.unlinkSync(learnImagePath),
                                messageID
                            );
                        } else {

                            let msg = "üë®‚Äçüè´ C√ÅC S∆Ø PH·ª§ C√ì TH·ªÇ H·ªåC:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                            let skillIndex = 1;

                            planetMasters.forEach(masterId => {
                                const master = MASTERS[masterId];
                                msg += `${master.name} (${master.race})\n`;
                                msg += `üìù ${master.description}\n\n`;
                                msg += "C√°c k·ªπ nƒÉng:\n";

                                Object.entries(master.skills).forEach(([skillId, skill]) => {
                                    const isLearned = player.skills.includes(`${masterId}:${skillId}`);
                                    const canLearn = player.stats.power >= skill.powerRequired;

                                    const status = isLearned ? "‚úÖ ƒê√£ h·ªçc" : canLearn ? "‚ú≥Ô∏è C√≥ th·ªÉ h·ªçc" : "‚ùå Ch∆∞a ƒë·ªß s·ª©c m·∫°nh";

                                    const damage = skill.powerScale > 0 ?
                                        Math.floor(player.stats.damage * skill.powerScale) : 0;

                                    const kiCost = skill.kiCost != 0 ?
                                        Math.abs(Math.floor(player.stats.ki * skill.kiCost)) : 0;

                                    let skillInfo = "";
                                    if (skill.powerScale > 0) {
                                        skillInfo = `‚öîÔ∏è ${damage.toLocaleString()} DMG, ${skill.kiCost > 0 ? "‚ú® -" + kiCost + " Ki" : ""}`;
                                    } else if (skill.kiCost < 0) {
                                        skillInfo = `${skill.description}, ‚ú® +${kiCost} Ki`;
                                    } else {
                                        skillInfo = `${skill.description}, ‚ú® -${kiCost} Ki`;
                                    }

                                    msg += `${skillIndex}. ${skill.name} - ${skillInfo}\n`;
                                    msg += `üí™ Y√™u c·∫ßu: ${skill.powerRequired.toLocaleString()} s·ª©c m·∫°nh - ${status}\n\n`;

                                    skillIndex++;
                                });
                            });

                            msg += "üí° C√°ch h·ªçc: .dball learn <s·ªë th·ª© t·ª± k·ªπ nƒÉng>";
                            return api.sendMessage(msg, threadID, messageID);
                        }
                    }
                    const skillIndex = parseInt(target[1]) - 1;
                    const availableMasters = PLANETS[player.planet].masters;
                    let allSkills = [];

                    availableMasters.forEach(masterId => {
                        Object.entries(MASTERS[masterId].skills).forEach(([skillId, skill]) => {
                            allSkills.push({ masterId, skillId, ...skill });
                        });
                    });

                    if (isNaN(skillIndex) || skillIndex < 0 || skillIndex >= allSkills.length) {
                        return api.sendMessage(
                            "‚ùå S·ªë th·ª© t·ª± k·ªπ nƒÉng kh√¥ng h·ª£p l·ªá!\n" +
                            "Vui l√≤ng ch·ªçn t·ª´ 1 ƒë·∫øn " + allSkills.length,
                            threadID, messageID
                        );
                    }

                    const chosenSkill = allSkills[skillIndex];
                    const skillId = `${chosenSkill.masterId}:${chosenSkill.skillId}`;

                    if (player.skills.includes(skillId)) {
                        return api.sendMessage("‚ùå B·∫°n ƒë√£ h·ªçc k·ªπ nƒÉng n√†y r·ªìi!", threadID, messageID);
                    }

                    if (player.stats.power < chosenSkill.powerRequired) {
                        return api.sendMessage(
                            "‚ùå ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ kh√¥ng ƒë·ªß ƒë·ªÉ h·ªçc k·ªπ nƒÉng n√†y!\n" +
                            `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ hi·ªán t·∫°i: ${player.stats.power.toLocaleString()}\n` +
                            `‚ö° Y√™u c·∫ßu: ${chosenSkill.powerRequired.toLocaleString()}\n\n` +
                            "üí° H√£y ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ tƒÉng s·ª©c m·∫°nh!",
                            threadID, messageID
                        );
                    }

                    player.skills.push(skillId);
                    savePlayerData(playerData);

                    const estimatedDamage = chosenSkill.powerScale > 0 ?
                        Math.floor(player.stats.damage * chosenSkill.powerScale) : 0;
                    const kiText = chosenSkill.kiCost < 0 ?
                        `H·ªìi ${Math.abs(Math.floor(player.stats.ki * chosenSkill.kiCost))} Ki` :
                        `T·ªën ${Math.floor(player.stats.ki * chosenSkill.kiCost)} Ki`;

                    return api.sendMessage(
                        "üéâ ùóõùó¢Ã£ùóñ ùóûùó¨ÃÉ ùó°ùóîÃÜùó°ùóö ùóßùóõùóîÃÄùó°ùóõ ùóñùó¢ÃÇùó°ùóö!\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                        `ƒê√£ h·ªçc ${chosenSkill.name} t·ª´ ${MASTERS[chosenSkill.masterId].name}\n` +
                        (estimatedDamage > 0 ? `üí• S√°t th∆∞∆°ng: ${estimatedDamage}\n` : "") +
                        `‚ú® Ki: ${kiText}\n` +
                        `üìù M√¥ t·∫£: ${chosenSkill.description}`,
                        threadID, messageID
                    );
                }
                case "inventory":
                case "inv": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    let inventoryMsg = "üì¶ KHO ƒê·ªí üì¶\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";

                    const equippedItems = player.inventory?.items?.filter(item => item.equipped) || [];
                    if (equippedItems.length > 0) {
                        inventoryMsg += "üéΩ ƒêANG TRANG B·ªä:\n";
                        equippedItems.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryMsg += `${itemData.emoji} ${itemData.name} - ${itemData.description}\n`;
                            }
                        });
                        inventoryMsg += "\n";
                    }

                    const consumables = player.inventory?.items?.filter(item => !item.equipped &&
                        Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "consumable") || [];

                    if (consumables.length > 0) {
                        inventoryMsg += "üß™ V·∫¨T PH·∫®M TI√äU HAO:\n";
                        consumables.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                            }
                        });
                        inventoryMsg += "\n";
                    }

                    const unusedEquipment = player.inventory?.items?.filter(item => !item.equipped &&
                        Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "equipment") || [];

                    if (unusedEquipment.length > 0) {
                        inventoryMsg += "üéÆ TRANG B·ªä CH∆ØA D√ôNG:\n";
                        unusedEquipment.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                            }
                        });
                        inventoryMsg += "\n";
                    }

                    const specialItems = player.inventory?.items?.filter(item =>
                        Object.values(SHOP_ITEMS).find(shop => shop.id === item.id)?.type === "special") || [];

                    if (specialItems.length > 0) {
                        inventoryMsg += "‚ú® V·∫¨T PH·∫®M ƒê·∫∂C BI·ªÜT:\n";
                        specialItems.forEach(item => {
                            const itemData = Object.values(SHOP_ITEMS).find(shop => shop.id === item.id);
                            if (itemData) {
                                inventoryMsg += `${itemData.emoji} ${itemData.name} (x${item.quantity}) - .dball use ${item.id}\n`;
                            }
                        });
                        inventoryMsg += "\n";
                    }

                    if (player.inventory?.dragonBalls?.length > 0) {
                        inventoryMsg += "üîÆ NG·ªåC R·ªíNG:\n";
                        const dragonBallsByPlanet = {};

                        player.inventory.dragonBalls.forEach(ball => {
                            if (!dragonBallsByPlanet[ball.planet]) {
                                dragonBallsByPlanet[ball.planet] = [];
                            }
                            dragonBallsByPlanet[ball.planet].push(ball.star);
                        });

                        Object.entries(dragonBallsByPlanet).forEach(([planet, stars]) => {
                            stars.sort((a, b) => a - b);
                            inventoryMsg += `${PLANETS[planet].name}: ${stars.map(s => `${s}‚≠ê`).join(", ")}\n`;

                            if (stars.length === 7) {
                                inventoryMsg += `\nüêâ B·∫°n ƒë√£ thu th·∫≠p ƒë·ªß 7 vi√™n Ng·ªçc R·ªìng ${PLANETS[planet].name}!\n`;
                                inventoryMsg += "üí° D√πng .ùó±ùóØùóÆùóπùóπ ùòÑùó∂ùòÄùóµ ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu ∆∞·ªõc\n\n";
                            }
                        });
                    }

                    if (!player.inventory ||
                        (!player.inventory.items?.length && !player.inventory.dragonBalls?.length)) {
                        inventoryMsg += "‚ùå Kho ƒë·ªì tr·ªëng!\n\n";
                        inventoryMsg += "üí° H√£y mua v·∫≠t ph·∫©m t·ª´ shop ho·∫∑c t√¨m Ng·ªçc R·ªìng!";
                    }

                    inventoryMsg += "\nüí° D√πng .dball shop ƒë·ªÉ mua th√™m v·∫≠t ph·∫©m";

                    return api.sendMessage(inventoryMsg, threadID, messageID);
                }
                case "fight": {
                    const player = playerData[senderID];
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                    }

                    if (player.stats.currentHealth <= 50 && player.stats.currentKi < player.stats.ki * 0.1) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ƒëang trong tr·∫°ng th√°i ki·ªát s·ª©c!\n" +
                            "üí° H√£y d√πng ƒë·∫≠u th·∫ßn (.dball use senzu) ƒë·ªÉ h·ªìi ph·ª•c tr∆∞·ªõc khi chi·∫øn ƒë·∫•u.",
                            threadID, messageID
                        );
                    }
                    if (target[1]?.toLowerCase() === "Boss" || target[1]?.toLowerCase() === "boss") {
                        BOSS_SYSTEM.checkForBossEvents();
                        const planetEvents = BOSS_SYSTEM.getPlanetEvents(player.planet);

                        // If no events or no specific event specified
                        if (Object.keys(planetEvents).length === 0) {
                            return api.sendMessage(
                                "üîç KH√îNG T√åM TH·∫§Y BOSS N√ÄO ƒêANG XU·∫§T HI·ªÜN! üîç\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `üëÅÔ∏è Kh√¥ng c√≥ boss n√†o ƒëang xu·∫•t hi·ªán t·∫°i ${PLANETS[player.planet].name}.\n` +
                                "üí° Boss s·∫Ω xu·∫•t hi·ªán ng·∫´u nhi√™n, h√£y ki·ªÉm tra th∆∞·ªùng xuy√™n!\n" +
                                "üí™ Luy·ªán t·∫≠p ƒë·ªÉ c√≥ ƒë·ªß s·ª©c m·∫°nh ƒë·ªëi ƒë·∫ßu v·ªõi c√°c boss.",
                                threadID, messageID
                            );
                        }

                        // If no specific boss is specified, just show list of active bosses
                        if (!target[2]) {
                            let msg = "üëπ BOSS ƒêANG XU·∫§T HI·ªÜN üëπ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";

                            Object.values(planetEvents).forEach((event, index) => {
                                const bossHealth = event.boss.health - Object.values(event.damageDealt).reduce((sum, damage) => sum + damage, 0);
                                const healthPercent = Math.max(0, Math.floor((bossHealth / event.boss.health) * 100));
                                const timeLeft = Math.floor((event.expireTime - Date.now()) / 60000); // minutes

                                msg += `${index + 1}. ${event.boss.name}\n`;
                                msg += `üìç ƒê·ªãa ƒëi·ªÉm: ${event.location.name}\n`;
                                msg += `‚ù§Ô∏è HP: ${bossHealth.toLocaleString()}/${event.boss.health.toLocaleString()} (${healthPercent}%)\n`;
                                msg += `üí™ S·ª©c m·∫°nh: ${event.boss.power.toLocaleString()}\n`;
                                msg += `‚è≥ C√≤n l·∫°i: ${timeLeft} ph√∫t\n`;
                                msg += `üë• Ng∆∞·ªùi tham gia: ${Object.keys(event.participants).length}\n`;
                                msg += `üí∞ Ph·∫ßn th∆∞·ªüng: ${event.boss.zeniReward.min.toLocaleString()} - ${event.boss.zeniReward.max.toLocaleString()} Zeni\n`;
                                msg += `üí° ƒê·ªÉ ƒë√°nh boss: .dball fight boss ${index + 1}\n\n`;
                            });

                            msg += "‚ö†Ô∏è L∆∞u √Ω: C·∫ßn s·ª©c m·∫°nh t·ªëi thi·ªÉu ƒë·ªÉ ƒë√°nh boss.\n";
                            msg += "üí° ƒê√°nh boss c√†ng nhi·ªÅu, ph·∫ßn th∆∞·ªüng c√†ng l·ªõn!";

                            return api.sendMessage(msg, threadID, messageID);
                        }

                        // Player wants to fight a specific boss
                        const bossIndex = parseInt(target[2]) - 1;
                        const events = Object.values(planetEvents);

                        if (isNaN(bossIndex) || bossIndex < 0 || bossIndex >= events.length) {
                            return api.sendMessage("‚ùå S·ªë th·ª© t·ª± boss kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                        }

                        const selectedEvent = events[bossIndex];
                        const eventId = selectedEvent.id;

                        // Check if player meets minimum power requirement
                        if (player.stats.power < selectedEvent.boss.minPowerRequired) {
                            return api.sendMessage(
                                `‚ùå S·ª©c m·∫°nh c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·ªëi ƒë·∫ßu v·ªõi ${selectedEvent.boss.name}!\n` +
                                `üí™ S·ª©c m·∫°nh hi·ªán t·∫°i: ${player.stats.power.toLocaleString()}\n` +
                                `üí™ S·ª©c m·∫°nh c·∫ßn thi·∫øt: ${selectedEvent.boss.minPowerRequired.toLocaleString()}\n\n` +
                                "üí° H√£y luy·ªán t·∫≠p th√™m ƒë·ªÉ ƒë·ªß s·ª©c ƒë√°nh boss!",
                                threadID, messageID
                            );
                        }

                        // Check if boss is already defeated
                        if (selectedEvent.defeated) {
                            return api.sendMessage(
                                `‚ùå ${selectedEvent.boss.name} ƒë√£ b·ªã ƒë√°nh b·∫°i!\n` +
                                "H√£y ch·ªù boss m·ªõi xu·∫•t hi·ªán.",
                                threadID, messageID
                            );
                        }

                        // Check player cooldown
                        const now = Date.now();
                        const bossCooldown = 120000; // 2 minutes

                        if (player.lastBossFight && now - player.lastBossFight < bossCooldown) {
                            const timeLeft = Math.ceil((bossCooldown - (now - player.lastBossFight)) / 1000);
                            return api.sendMessage(
                                `‚è≥ Vui l√≤ng ƒë·ª£i ${timeLeft}s ƒë·ªÉ h·ªìi s·ª©c sau khi ƒë√°nh boss!`,
                                threadID, messageID
                            );
                        }

                        // Create boss object
                        const boss = {
                            id: selectedEvent.boss.id,
                            name: selectedEvent.boss.name,
                            stats: {
                                power: selectedEvent.boss.power,
                                health: selectedEvent.boss.health,
                                damage: selectedEvent.boss.damage,
                                ki: selectedEvent.boss.ki
                            },
                            skills: selectedEvent.boss.skills || []
                        };

                        // Initial message
                        api.sendMessage(
                            `‚öîÔ∏è CU·ªòC CHI·∫æN V·ªöI BOSS B·∫ÆT ƒê·∫¶U! ‚öîÔ∏è\n` +
                            `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                            `üë§ ${player.name} ƒëang t·∫•n c√¥ng ${boss.name}!\n` +
                            `üìç ƒê·ªãa ƒëi·ªÉm: ${selectedEvent.location.name}\n` +
                            `üí™ S·ª©c m·∫°nh boss: ${boss.stats.power.toLocaleString()}\n\n` +
                            "üí° ƒêang chi·∫øn ƒë·∫•u...",
                            threadID
                        );

                        // Use existing battle simulation
                        const battleResult = simulateBattle(player, boss, {
                            battleType: "BOSS",
                            maxTurns: 15,
                            isPlayerAttacker: true,
                            isPlayerDefender: false,
                            bossMode: true
                        });

                        // Update player stats
                        player.stats.currentKi = battleResult.player1Ki;
                        player.stats.currentHealth = battleResult.player1HP;
                        player.lastBossFight = now;

                        // Calculate damage dealt to boss
                        const damageDealt = battleResult.totalDamageDealt.attacker;

                        // Register damage to the boss event
                        const bossDefeated = BOSS_SYSTEM.registerDamage(eventId, senderID, player.name, damageDealt);

                        // Update player's stats/inventory
                        if (bossDefeated) {
                            // Get rewards based on contribution
                            const rewards = BOSS_SYSTEM.getPlayerRewards(eventId, senderID);

                            if (rewards) {
                                player.stats.exp += rewards.exp;
                                player.stats.zeni += rewards.zeni;

                                // Add items to inventory
                                rewards.drops.forEach(drop => {
                                    if (!player.inventory) player.inventory = { items: [] };
                                    if (!player.inventory.items) player.inventory.items = [];

                                    const existingItem = player.inventory.items.find(i => i.id === drop.item);
                                    if (existingItem) {
                                        existingItem.quantity += drop.quantity;
                                    } else {
                                        player.inventory.items.push({
                                            id: drop.item,
                                            quantity: drop.quantity,
                                            type: "boss_drop"
                                        });
                                    }
                                });

                                // Boss defeat message with rewards
                                api.sendMessage(
                                    `üéâ BOSS ƒê√É B·ªä ƒê√ÅNH B·∫†I! üéâ\n` +
                                    `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                    `üë§ ${player.name} ƒë√£ g√≥p ph·∫ßn ƒë√°nh b·∫°i ${boss.name}!\n` +
                                    `üìä ƒê√≥ng g√≥p c·ªßa b·∫°n: ${Math.floor(rewards.contribution * 100)}%\n\n` +
                                    `üéÅ Ph·∫ßn th∆∞·ªüng:\n` +
                                    `üìä EXP: +${rewards.exp.toLocaleString()}\n` +
                                    `üí∞ Zeni: +${rewards.zeni.toLocaleString()}\n` +
                                    (rewards.drops.length > 0
                                        ? `üéÅ V·∫≠t ph·∫©m: ${rewards.drops.map(d => `${SHOP_ITEMS[d.item.toUpperCase()]?.name || d.item} x${d.quantity}`).join(", ")}\n`
                                        : "") +
                                    `\nüí° Ki·ªÉm tra kho ƒë·ªì v·ªõi .dball inventory`,
                                    threadID
                                );
                            } else {
                                api.sendMessage(
                                    `üéâ BOSS ƒê√É B·ªä ƒê√ÅNH B·∫†I! üéâ\n` +
                                    `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                    `üë§ ${player.name} ƒë√£ tham gia tr·∫≠n chi·∫øn v·ªõi ${boss.name}!\n` +
                                    `‚ùå B·∫°n kh√¥ng g√¢y ƒë∆∞·ª£c ƒë·ªß s√°t th∆∞∆°ng ƒë·ªÉ nh·∫≠n ph·∫ßn th∆∞·ªüng.\n` +
                                    `üí° H√£y tƒÉng s·ª©c m·∫°nh ƒë·ªÉ ƒë√≥ng g√≥p nhi·ªÅu h∆°n trong nh·ªØng tr·∫≠n sau!`,
                                    threadID
                                );
                            }
                        } else {
                            // Boss not defeated, show battle result
                            api.sendMessage(
                                `‚öîÔ∏è K·∫æT QU·∫¢ ƒê√ÅNH BOSS ‚öîÔ∏è\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üë§ ${player.name} VS ${boss.name}\n` +
                                `üìç ƒê·ªãa ƒëi·ªÉm: ${selectedEvent.location.name}\n\n` +
                                battleResult.battleLog.slice(-8).join("\n") + "\n\n" +
                                `üí¢ S√°t th∆∞∆°ng ƒë√£ g√¢y ra: ${damageDealt.toLocaleString()}\n` +
                                `‚ù§Ô∏è HP c√≤n l·∫°i: ${Math.floor(battleResult.player1HP).toLocaleString()}/${player.stats.health.toLocaleString()}\n` +
                                `‚ú® Ki c√≤n l·∫°i: ${Math.floor(battleResult.player1Ki).toLocaleString()}/${player.stats.ki.toLocaleString()}\n\n` +
                                `üí° Boss v·∫´n ch∆∞a b·ªã ƒë√°nh b·∫°i! H√£y ti·∫øp t·ª•c t·∫•n c√¥ng ho·∫∑c r·ªß th√™m ng∆∞·ªùi tham gia!`,
                                threadID, messageID
                            );
                        }

                        BOSS_SYSTEM.saveBossData();
                        savePlayerData(playerData);
                        return;
                    }

                    BOSS_SYSTEM.loadBossData();


                    if (target[1]?.toLowerCase() === "tournament" || target[1]?.toLowerCase() === "tour") {

                        const tournamentData = loadTournamentData();
                        if (!tournamentData.active || tournamentData.active.status !== "ongoing") {
                            return api.sendMessage("‚ùå Kh√¥ng c√≥ gi·∫£i ƒë·∫•u n√†o ƒëang di·ªÖn ra!", threadID, messageID);
                        }

                        if (!tournamentData.registrations[senderID]) {
                            return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia gi·∫£i ƒë·∫•u n√†y!", threadID, messageID);
                        }

                        const currentMatch = findPlayerMatch(tournamentData, senderID);
                        if (!currentMatch) {
                            return api.sendMessage("‚ùå B·∫°n kh√¥ng c√≥ tr·∫≠n ƒë·∫•u n√†o ƒëang di·ªÖn ra!", threadID, messageID);
                        }

                        const opponent = currentMatch.player1.id === senderID ? currentMatch.player2 : currentMatch.player1;
                        const opponentData = playerData[opponent.id];
                        if (!opponentData) {
                            return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒë·ªëi th·ªß!", threadID, messageID);
                        }

                        if (Date.now() < currentMatch.scheduledTime) {
                            const timeLeft = Math.ceil((currentMatch.scheduledTime - Date.now()) / 60000);
                            return api.sendMessage(`‚è≥ Ch∆∞a ƒë·∫øn l∆∞·ª£t ƒë·∫•u c·ªßa b·∫°n! Vui l√≤ng ƒë·ª£i ${timeLeft} ph√∫t n·ªØa.`, threadID, messageID);
                        }

                        api.sendMessage(
                            `üèÜ TR·∫¨N ƒê·∫§U B·∫ÆT ƒê·∫¶U! üèÜ\n` +
                            `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                            `üë• ${player.name} VS ${opponentData.name}\n` +
                            `üèüÔ∏è ${TOURNAMENT_TYPES[tournamentData.active.type].name} - V√≤ng ${currentMatch.round}\n\n` +
                            `üí° Tr·∫≠n ƒë·∫•u ƒëang di·ªÖn ra...`,
                            threadID, messageID
                        );


                        const battleResult = simulateBattle(player, opponentData, {
                            battleType: "TOURNAMENT",
                            maxTurns: 30,
                            isPlayerAttacker: true,
                            isPlayerDefender: true,
                            tournamentMatch: currentMatch
                        });

                        const playerWon =
                            battleResult.winner.id === senderID ||
                            battleResult.winner.name === player.name ||
                            (battleResult.player2HP <= 0 && battleResult.player1HP > 0) ||
                            battleResult.battleLog.some(msg => msg.includes(`${opponentData.name} ƒë√£ b·ªã ƒë√°nh b·∫°i`));

                        currentMatch.completed = true;

                        if (playerWon) {
                            currentMatch.winner = { id: senderID, name: player.name };
                            currentMatch.loser = { id: opponent.id, name: opponentData.name };


                            checkTournamentQuest(player, tournamentData, {
                                winner: { id: senderID, name: player.name },
                                loser: { id: opponent.id, name: opponentData.name }
                            });
                        } else {
                            currentMatch.winner = { id: opponent.id, name: opponentData.name };
                            currentMatch.loser = { id: senderID, name: player.name };


                            if (opponentData) {
                                checkTournamentQuest(opponentData, tournamentData, {
                                    winner: { id: opponent.id, name: opponentData.name },
                                    loser: { id: senderID, name: player.name }
                                });
                            }
                        }


                        updateTournamentBracket(tournamentData);
                        saveTournamentData(tournamentData);
                        savePlayerData(playerData);

                        player.stats.currentKi = battleResult.player1Ki;
                        opponentData.stats.currentKi = battleResult.player2Ki;

                        if (playerWon) {
                            player.stats.exp += 20;
                        } else {
                            opponentData.stats.exp += 20;
                        }

                        saveTournamentData(tournamentData);
                        savePlayerData(playerData);

                        return api.sendMessage(
                            `üèÜ ${playerWon ? "ùêÇùêáùêàùêÑÃÇÃÅùêç ùêìùêáùêÄÃÜÃÅùêçùêÜ!" : "ùêìùêáùêÄÃÇÃÅùêì ùêÅùêÄÃ£ùêà!"} üèÜ\n` +
                            `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                            `üëë ${TOURNAMENT_TYPES[tournamentData.active.type].name} - V√≤ng ${currentMatch.round}\n` +
                            battleResult.battleLog.slice(-7).join("\n") + "\n\n" +
                            `üë§ ${playerWon ? player.name : opponentData.name} ƒë√£ chi·∫øn th·∫Øng!\n` +
                            `üí° H√£y ch·ªù tr·∫≠n ƒë·∫•u ti·∫øp theo.\n\n` +
                            `üí° D√πng .dball tour bracket ƒë·ªÉ xem b·∫£ng ƒë·∫•u`,
                            threadID, messageID
                        );
                    }
                    else if (target[1]?.toLowerCase() === "camp" || target[1]?.toLowerCase() === "doanh" || target[1]?.toLowerCase() === "tr·∫°i") {

                        const vietnamTime = new Date(new Date().getTime() + (7 * 60 * 60 * 1000));
                        const currentHour = vietnamTime.getUTCHours();

                        const isLunchHours = currentHour >= 11 && currentHour < 13;
                        const isEveningHours = currentHour >= 19 && currentHour < 24;

                        if (!isLunchHours && !isEveningHours) {
                            return api.sendMessage(
                                "‚è∞ DOANH TR·∫†I ƒê·ªòC NH√ÉN CH·ªà M·ªû C·ª¨A TRONG C√ÅC KHUNG GI·ªú! ‚è∞\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                "üïö Bu·ªïi tr∆∞a: 11:00 - 13:00\n" +
                                "üåô Bu·ªïi t·ªëi: 19:00 - 24:00\n\n" +
                                "Vui l√≤ng quay l·∫°i trong khung gi·ªù ho·∫°t ƒë·ªông.\n" +
                                "Hi·ªán t·∫°i: " + vietnamTime.getUTCHours() + ":" +
                                (vietnamTime.getUTCMinutes() < 10 ? "0" : "") + vietnamTime.getUTCMinutes() + "\n\n" +
                                "üí° B·∫°n c√≥ th·ªÉ ƒëi luy·ªán t·∫≠p (.dball train) ho·∫∑c ƒë√°nh qu√°i (.dball fight monster) trong l√∫c ch·ªù ƒë·ª£i!",
                                threadID, messageID
                            );
                        }


                        const now = Date.now();
                        const campCooldown = 300000;

                        if (player.lastCampFight && now - player.lastCampFight < campCooldown) {
                            const timeLeft = Math.ceil((campCooldown - (now - player.lastCampFight)) / 1000);
                            return api.sendMessage(
                                `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.floor(timeLeft / 60)}m ${timeLeft % 60}s ƒë·ªÉ h·ªìi ph·ª•c s·ª©c!`,
                                threadID, messageID
                            );
                        }


                        if (!player.campProgress) player.campProgress = 0;
                        const nextLevelIndex = player.campProgress;

                        if (!CAMP_LEVELS[nextLevelIndex]) {
                            return api.sendMessage(
                                "üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c t·∫ßng trong Tr·∫°i ƒê·ªôc Nh√£n!",
                                threadID, messageID
                            );
                        }

                        const currentLevel = CAMP_LEVELS[nextLevelIndex];


                        if (player.stats.power < currentLevel.requiredPower) {
                            return api.sendMessage(
                                `‚ùå ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ kh√¥ng ƒë·ªß ƒë·ªÉ th√°ch ƒë·∫•u ${currentLevel.name}!\n` +
                                `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ hi·ªán t·∫°i: ${player.stats.power.toLocaleString()}\n` +
                                `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ y√™u c·∫ßu: ${currentLevel.requiredPower.toLocaleString()}\n\n` +
                                "üí° H√£y luy·ªán t·∫≠p th√™m ƒë·ªÉ tƒÉng s·ª©c m·∫°nh!",
                                threadID, messageID
                            );
                        }


                        const enemy = {
                            id: 'camp_boss_' + nextLevelIndex,
                            name: currentLevel.enemy,
                            stats: {
                                power: currentLevel.power,
                                health: currentLevel.hp,
                                damage: currentLevel.power / 10,
                                ki: currentLevel.power / 2
                            },
                            skills: [],
                            campLevel: currentLevel
                        };


                        const battleResult = simulateBattle(player, enemy, {
                            battleType: "CAMP",
                            maxTurns: 25,
                            isPlayerAttacker: true,
                            isPlayerDefender: false
                        });

                        player.lastCampFight = now;

                        const playerWon =
                            battleResult.winner?.id === senderID ||
                            (battleResult.player2HP <= 0 && battleResult.player1HP > 0) ||
                            battleResult.winner?.name === player.name;

                        if (playerWon) {
                            player.campProgress++;

                            const dragonBallStar = 7 - Math.min(6, Math.floor(nextLevelIndex / 2));

                            if (!player.inventory) player.inventory = { dragonBalls: [] };
                            if (!player.inventory.dragonBalls) player.inventory.dragonBalls = [];

                            const existingBall = player.inventory.dragonBalls.find(
                                ball => ball.planet === player.planet && ball.star === dragonBallStar
                            );

                            let dragonBallMessage = "";
                            if (!existingBall) {
                                player.inventory.dragonBalls.push({
                                    planet: player.planet,
                                    star: dragonBallStar
                                });

                                const dragonBallData = loadDragonBallData();
                                dragonBallData[player.planet][dragonBallStar] = senderID;
                                saveDragonBallData(dragonBallData);

                                dragonBallMessage = `\nüîÆ B·∫°n ƒë√£ t√¨m th·∫•y Ng·ªçc R·ªìng ${dragonBallStar} sao!`;
                            } else {
                                const zeniBonusDragonBall = 10000 * dragonBallStar;
                                player.stats.zeni += zeniBonusDragonBall;
                                dragonBallMessage = `\nüí∞ B·∫°n ƒë√£ c√≥ Ng·ªçc R·ªìng ${dragonBallStar} sao n√™n nh·∫≠n ${zeniBonusDragonBall.toLocaleString()} Zeni!`;
                            }

                            const expGain = Math.floor(currentLevel.exp);
                            const zeniGain = currentLevel.zeni;

                            player.stats.exp += expGain;
                            player.stats.zeni += zeniGain;

                            if (player.stats.exp > MAX_EXP_STORAGE) {
                                player.stats.exp = MAX_EXP_STORAGE;
                            }

                            player.stats.currentHealth = battleResult.player1HP;
                            player.stats.currentKi = battleResult.player1Ki;

                            updateQuestProgress(player, QUEST_TYPES.COMBAT, playerData, { monster: currentLevel.enemy.toLowerCase().replace(/\s+/g, '_') });
                            savePlayerData(playerData);

                            let nextLevelMsg = "";
                            if (CAMP_LEVELS[player.campProgress]) {
                                nextLevelMsg = `\n\nüí° T·∫ßng ti·∫øp theo: ${CAMP_LEVELS[player.campProgress].name}\n` +
                                    `üëπ K·∫ª ƒë·ªãch: ${CAMP_LEVELS[player.campProgress].enemy}\n` +
                                    `üí™ Y√™u c·∫ßu: ${CAMP_LEVELS[player.campProgress].requiredPower.toLocaleString()} s·ª©c m·∫°nh`;
                            } else {
                                nextLevelMsg = "\n\nüéâ B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c t·∫ßng c·ªßa Tr·∫°i ƒê·ªôc Nh√£n!";
                            }

                            return api.sendMessage(
                                `üéâ CHI·∫æN TH·∫ÆNG! üéâ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üëπ ƒê√°nh b·∫°i: ${currentLevel.enemy} t·∫°i ${currentLevel.name}\n\n` +
                                `üìä Th√¥ng tin tr·∫≠n ƒë·∫•u:\n` +
                                battleResult.battleLog.slice(-8).join("\n") + "\n\n" +
                                `üìä ùóòùó´ùó£ +${expGain.toLocaleString()}\n` +
                                `üí∞ ùó≠ùó≤ùóªùó∂ +${zeniGain.toLocaleString()}\n` +
                                `‚ù§Ô∏è HP c√≤n l·∫°i: ${Math.floor(battleResult.player1HP).toLocaleString()}/${player.stats.health.toLocaleString()}\n` +
                                `‚ú® Ki c√≤n l·∫°i: ${Math.floor(battleResult.player1Ki).toLocaleString()}/${player.stats.ki.toLocaleString()}` +
                                dragonBallMessage +
                                nextLevelMsg,
                                threadID, messageID
                            );
                        } else {
                            player.campProgress = 0;
                            player.stats.currentHealth = Math.floor(player.stats.health * 0.3);
                            player.stats.currentKi = Math.floor(player.stats.ki * 0.5);

                            savePlayerData(playerData);

                            return api.sendMessage(
                                `üíÄ ùêòùêéùêî ùêÉùêàùêÑùêÉ! üíÄ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                `üëπ T·ª≠ vong t·∫°i: ${currentLevel.name}\n` +
                                `‚öîÔ∏è K·∫ª ƒë·ªãch: ${currentLevel.enemy}\n\n` +
                                `üìä Th√¥ng tin tr·∫≠n ƒë·∫•u:\n` +
                                battleResult.battleLog.slice(-8).join("\n") + "\n\n" +
                                `‚ö†Ô∏è B·∫°n ƒë√£ th·∫•t b·∫°i v√† ph·∫£i b·∫Øt ƒë·∫ßu l·∫°i t·ª´ ƒë·∫ßu!\n` +
                                `‚ù§Ô∏è HP hi·ªán t·∫°i: ${player.stats.currentHealth.toLocaleString()}\n` +
                                `‚ú® Ki hi·ªán t·∫°i: ${player.stats.currentKi.toLocaleString()}\n\n` +
                                `üí° H√£y h·ªìi ph·ª•c v√† th·ª≠ l·∫°i sau!`,
                                threadID, messageID
                            );
                        }
                    }

                    else if (target[1]?.toLowerCase() === "monster" || target[1]?.toLowerCase() === "quai") {

                        const monsterType = target[2]?.toLowerCase();
                        const monsterData = monsterType ?
                            Object.entries(MONSTERS).find(([id, data]) => id.toLowerCase() === monsterType || data.name.toLowerCase() === monsterType)?.[1]
                            : selectRandomMonster(player.planet);

                        if (!monsterData) {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng t√¨m th·∫•y qu√°i v·∫≠t n√†y!\n" +
                                "H√£y ch·ªçn qu√°i v·∫≠t t·ª´ danh s√°ch d∆∞·ªõi ƒë√¢y:\n" +
                                Object.entries(MONSTERS)
                                    .filter(([id, data]) => data.planet === player.planet)
                                    .map(([id, data]) => `- ${data.name} (${id})`)
                                    .join("\n") +
                                "\n\nC√°ch d√πng: .dball fight monster <t√™n_qu√°i>",
                                threadID, messageID
                            );
                        }

                        const monster = {
                            id: monsterType || 'random_monster',
                            name: monsterData.name,
                            stats: {
                                power: monsterData.power,
                                health: monsterData.hp || monsterData.health || Math.floor(monsterData.power * 2),
                                currentHealth: monsterData.hp || monsterData.health || Math.floor(monsterData.power * 2),
                                damage: monsterData.damage || Math.floor(monsterData.power / 10),
                                ki: monsterData.ki || Math.floor(monsterData.power / 3),
                                currentKi: monsterData.ki || Math.floor(monsterData.power / 3)
                            },
                            skills: monsterData.skills || [],
                            planet: monsterData.planet,
                            dropChance: monsterData.dropChance || 0
                        };

                        const now = Date.now();
                        const fightCooldown = 30000;

                        if (player.lastMonsterFight && now - player.lastMonsterFight < fightCooldown) {
                            const timeLeft = Math.ceil((fightCooldown - (now - player.lastMonsterFight)) / 1000);
                            return api.sendMessage(`‚è≥ Vui l√≤ng ƒë·ª£i ${timeLeft}s ƒë·ªÉ ph·ª•c h·ªìi s·ª©c!`, threadID, messageID);
                        }


                        if (!player.quests?.active || player.quests.active.length === 0) {
                            return api.sendMessage(
                                "‚ùå B·∫°n ch∆∞a c√≥ nhi·ªám v·ª• n√†o!\n" +
                                "üí° D√πng .dball quest ƒë·ªÉ nh·∫≠n nhi·ªám v·ª• m·ªõi",
                                threadID, messageID
                            );
                        }

                        const currentQuestId = player.quests.active[0];
                        const currentQuest = QUESTS[currentQuestId];

                        if (!currentQuest || currentQuest.type !== QUEST_TYPES.COMBAT) {
                            return api.sendMessage(
                                "‚ùå Nhi·ªám v·ª• hi·ªán t·∫°i kh√¥ng ph·∫£i l√† nhi·ªám v·ª• ƒë√°nh qu√°i!\n" +
                                "üí° Ho√†n th√†nh nhi·ªám v·ª• hi·ªán t·∫°i tr∆∞·ªõc",
                                threadID, messageID
                            );
                        }

                        const questMonster = MONSTERS[currentQuest.monster];
                        if (!questMonster) {
                            return api.sendMessage("‚ùå C√≥ l·ªói v·ªõi nhi·ªám v·ª•, vui l√≤ng th·ª≠ l·∫°i sau!", threadID, messageID);
                        }

                        const questProgress = player.quests.progress[currentQuestId] || 0;
                        if (questProgress >= currentQuest.target) {
                            return api.sendMessage(
                                "‚úÖ B·∫°n ƒë√£ ho√†n th√†nh ƒë·ªß s·ªë l·∫ßn ƒë√°nh qu√°i cho nhi·ªám v·ª• n√†y!\n",
                                threadID, messageID
                            );
                        }


                        const battleResult = simulateBattle(player, monster, {
                            battleType: "MONSTER",
                            maxTurns: 20,
                            isPlayerAttacker: true,
                            isPlayerDefender: false
                        });

                        player.lastMonsterFight = now;


                        const playerWon = battleResult.winner.id === senderID ||
                            (battleResult.winner.name === player.name);

                        if (playerWon) {

                            player.stats.currentHealth = battleResult.player1HP;
                            player.stats.currentKi = battleResult.player1Ki;


                            let expGain = Math.floor(monster.stats.power * 0.1);
                            let zeniGain = Math.floor(monster.stats.power * 0.05) + 100;

                            const playerLevel = player.stats.level || 1;
                            const levelFactor = Math.max(0.5, 2 - Math.log10(playerLevel + 1));
                            expGain = Math.floor(expGain * levelFactor);
                            zeniGain = Math.floor(zeniGain * levelFactor);
                            if (player.stats.exp + expGain > MAX_EXP_STORAGE) {
                                player.stats.exp = MAX_EXP_STORAGE;
                            } else {
                                player.stats.exp += expGain;
                            }

                            player.stats.zeni += zeniGain;

                            player.stats.currentHealth = battleResult.player1HP;
                            player.stats.currentKi = battleResult.player1Ki;


                            let dropMessage = "";
                            if (monster.dropChance > 0 && Math.random() < monster.dropChance) {
                                const dropItem = monster.dropItem;
                                if (dropItem && SHOP_ITEMS[dropItem.toUpperCase()]) {
                                    if (!player.inventory) player.inventory = { items: [] };
                                    if (!player.inventory.items) player.inventory.items = [];

                                    const item = SHOP_ITEMS[dropItem.toUpperCase()];
                                    const existingItem = player.inventory.items.find(i => i.id === dropItem);

                                    if (existingItem) {
                                        existingItem.quantity += 1;
                                    } else {
                                        player.inventory.items.push({
                                            id: dropItem,
                                            quantity: 1,
                                            type: item.type
                                        });
                                    }

                                    dropMessage = `\nüéÅ ${monster.name} r∆°i ra: ${item.name}!`;
                                }
                            }


                            player.quests.progress[currentQuestId] = (player.quests.progress[currentQuestId] || 0) + 1;
                            const remainingKills = currentQuest.target - player.quests.progress[currentQuestId];

                            updateQuestProgress(player, QUEST_TYPES.COMBAT, playerData, { monster: currentQuest.monster });
                            savePlayerData(playerData);

                            return api.sendMessage(
                                "üèÜ ùóñùóõùóúùóòÃÇÃÅùó° ùóßùóõùóîÃÜÃÅùó°ùóö! üèÜ\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n` +
                                battleResult.battleLog.slice(-5).join("\n") + "\n\n" +
                                "üí° K·∫øt qu·∫£:\n" +
                                `üìä ùóòùó´ùó£ +${expGain.toLocaleString()}\n` +
                                `üí∞ ùó≠ùó≤ùóªùó∂ +${zeniGain.toLocaleString()}` +
                                `\n‚ù§Ô∏è HP: ${player.stats.currentHealth.toLocaleString()}/${player.stats.health.toLocaleString()}` +
                                dropMessage + "\n\n" +
                                `üìã Nhi·ªám v·ª•: ${currentQuest.name}\n` +
                                `‚è≥ Ti·∫øn ƒë·ªô: ${player.quests.progress[currentQuestId]}/${currentQuest.target}\n` +
                                `üí™ C√≤n ${remainingKills} l·∫ßn ƒë√°nh n·ªØa!\n\n` +
                                "üí° D√πng ƒë·∫≠u th·∫ßn (.dball use senzu) ƒë·ªÉ h·ªìi ph·ª•c\n" +
                                "üí° G√µ .dball fight monster ƒë·ªÉ ƒë√°nh ti·∫øp",
                                threadID, messageID
                            );
                        } else {

                            return api.sendMessage(
                                "üíÄ TH·∫§T B·∫†I! üíÄ\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                `üåç H√†nh tinh: ${PLANETS[player.planet].name}\n` +
                                battleResult.battleLog.slice(-5).join("\n") + "\n\n" +
                                `‚ùå B·∫°n ƒë√£ b·ªã ƒë√°nh b·∫°i b·ªüi ${monster.name}!\n` +
                                `‚ù§Ô∏è HP c·ªßa b·∫°n c√≤n: ${Math.floor(battleResult.player1HP).toLocaleString()}/${player.stats.health.toLocaleString()}\n` +
                                `‚ù§Ô∏è HP c·ªßa ${monster.name}: ${Math.floor(battleResult.player2HP).toLocaleString()}/${monster.stats.health.toLocaleString()}\n` +
                                "üí° H√£y luy·ªán t·∫≠p th√™m ƒë·ªÉ tr·ªü n√™n m·∫°nh h∆°n!",
                                threadID, messageID
                            );
                        }

                        return;
                    }
                    else {

                        const mention = Object.keys(event.mentions)[0];
                        if (!mention) {
                            return api.sendMessage(
                                "‚ùì B·∫°n mu·ªën ƒë√°nh ai?\n" +
                                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" +
                                "‚Ä¢ .dball fight @ng∆∞·ªùi_ch∆°i - PvP v·ªõi ng∆∞·ªùi ch∆°i kh√°c\n" +
                                "‚Ä¢ .dball fight monster - ƒê√°nh qu√°i v·∫≠t\n" +
                                "‚Ä¢ .dball fight camp - ƒêi Doanh Tr·∫°i ƒê·ªôc Nh√£n t√¨m ng·ªçc r·ªìng\n" +
                                "‚Ä¢ .dball fight tour - ƒê·∫•u ƒë·∫°i h·ªôi v√µ thu·∫≠t\n" +
                                "‚Ä¢ .dball fight boss - ƒê√°nh boss\n",
                                threadID, messageID
                            );
                        }

                        const now = Date.now();
                        const pvpCooldown = 60000;

                        if (player.lastPvpFight && now - player.lastPvpFight < pvpCooldown) {
                            const timeLeft = Math.ceil((pvpCooldown - (now - player.lastPvpFight)) / 1000);
                            return api.sendMessage(
                                `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.floor(timeLeft / 60)}m ${timeLeft % 60}s ƒë·ªÉ h·ªìi s·ª©c sau tr·∫≠n PvP!`,
                                threadID, messageID
                            );
                        }

                        const opponent = playerData[mention];
                        if (!opponent) {
                            return api.sendMessage("‚ùå ƒê·ªëi th·ªß ch∆∞a t·∫°o nh√¢n v·∫≠t!", threadID, messageID);
                        }

                        if (opponent.lastPvpFight && now - opponent.lastPvpFight < pvpCooldown) {
                            const timeLeft = Math.ceil((pvpCooldown - (now - opponent.lastPvpFight)) / 1000);
                            return api.sendMessage(
                                `‚ùå ƒê·ªëi th·ªß ƒëang trong th·ªùi gian h·ªìi s·ª©c sau tr·∫≠n PvP!\n` +
                                `‚è≥ C√≤n ${Math.floor(timeLeft / 60)}m ${timeLeft % 60}s n·ªØa m·ªõi c√≥ th·ªÉ th√°ch ƒë·∫•u.`,
                                threadID, messageID
                            );
                        }


                        const battleResult = simulateBattle(player, opponent, {
                            battleType: "PVP",
                            maxTurns: 30,
                            isPlayerAttacker: true,
                            isPlayerDefender: true
                        });


                        player.stats.currentKi = battleResult.player1Ki;
                        opponent.stats.currentKi = battleResult.player2Ki;


                        player.lastPvpFight = now;
                        opponent.lastPvpFight = now;


                        battleResult.winner.stats.exp += 20;


                        savePlayerData(playerData);
                        const maxLogEntries = 30;
                        const battleLogEntries = battleResult.battleLog.slice(-maxLogEntries);
                        const battleSummary = battleLogEntries.join("\n");

                        const sendBattleInChunks = (battleResult, player1, player2) => {

                            const battleLogs = battleResult.battleLog;
                            const totalTurns = battleLogs.length;
                            const isPlayerWinner = battleResult.winner.id === senderID ||
                                battleResult.winner === player1;


                            const chunk1End = Math.floor(totalTurns * 0.3);
                            const chunk2End = Math.floor(totalTurns * 0.7);


                            const formatLogs = (logs) => {
                                const formattedLogs = [];
                                let turnCounter = 1;

                                logs.forEach(log => {

                                    if (log.includes("L∆∞·ª£t") || log.includes("Turn")) {
                                        formattedLogs.push(`\nüîÑ L∆Ø·ª¢T ${turnCounter++} üîÑ`);
                                    }


                                    if (log.includes("s·ª≠ d·ª•ng")) {
                                        formattedLogs.push(`üî• ${log}`);
                                    }

                                    else if (log.includes("s√°t th∆∞∆°ng") || log.includes("damage")) {
                                        formattedLogs.push(`üí• ${log}`);
                                    }

                                    else if (log.includes("h·ªìi ph·ª•c") || log.includes("heal")) {
                                        formattedLogs.push(`‚ú® ${log}`);
                                    }

                                    else {
                                        formattedLogs.push(`${log}`);
                                    }
                                });

                                return formattedLogs.join("\n");
                            };


                            const chunk1Logs = formatLogs(battleLogs.slice(0, chunk1End));
                            const chunk2Logs = formatLogs(battleLogs.slice(chunk1End, chunk2End));
                            const chunk3Logs = formatLogs(battleLogs.slice(chunk2End));


                            const battleHeader = `‚öîÔ∏è TR·∫¨N ƒê·∫§U PVP GI·ªÆA ‚öîÔ∏è\n` +
                                `üîµ ${player1.name} (${PLANETS[player1.planet].name}${player1.evolution ? ` - ${player1.evolution.name}` : ''})\n` +
                                `üî¥ ${player2.name} (${PLANETS[player2.planet].name}${player2.evolution ? ` - ${player2.evolution.name}` : ''})\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`;


                            api.sendMessage(
                                `${battleHeader}\n` +
                                `üèÅ GIAI ƒêO·∫†N ƒê·∫¶U TR·∫¨N üèÅ\n` +
                                `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                chunk1Logs,
                                threadID
                            );


                            setTimeout(() => {
                                api.sendMessage(
                                    `${battleHeader}\n` +
                                    `‚ö° GIAI ƒêO·∫†N GI·ªÆA TR·∫¨N ‚ö°\n` +
                                    `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                    chunk2Logs,
                                    threadID
                                );

                                setTimeout(() => {
                                    const expGain = isPlayerWinner ? 20 : 5;
                                    ·∫£
                                    const playerHPPercent = Math.floor((isPlayerWinner ? battleResult.player1HP : battleResult.player2HP) /
                                        battleResult.winner.stats.health * 100);
                                    const playerKiPercent = Math.floor((isPlayerWinner ? battleResult.player1Ki : battleResult.player2Ki) /
                                        battleResult.winner.stats.ki * 100);

                                    const createBar = (percent, fullChar = 'üü©', emptyChar = '‚¨ú') => {
                                        const barLength = 10;
                                        const filledCount = Math.ceil(percent * barLength / 100);
                                        return fullChar.repeat(filledCount) + emptyChar.repeat(Math.max(0, barLength - filledCount));
                                    };

                                    const hpBar = createBar(playerHPPercent);
                                    const kiBar = createBar(playerKiPercent, 'üü¶');

                                    api.sendMessage(
                                        `${battleHeader}\n` +
                                        `üî• H·ªíI K·∫æT TR·∫¨N ƒê·∫§U üî•\n` +
                                        `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                        chunk3Logs + `\n\n` +
                                        `üèÜ K·∫æT QU·∫¢ TR·∫¨N ƒê·∫§U üèÜ\n` +
                                        `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
                                        `üëë Ng∆∞·ªùi th·∫Øng: ${battleResult.winner.name}\n` +
                                        `üíî Ng∆∞·ªùi thua: ${battleResult.loser.name}\n\n` +
                                        `‚ù§Ô∏è HP c√≤n l·∫°i: ${Math.floor(isPlayerWinner ? battleResult.player1HP : battleResult.player2HP).toLocaleString()}/${Math.floor(battleResult.winner.stats.health).toLocaleString()} (${playerHPPercent}%)\n${hpBar}\n` +
                                        `‚ú® Ki c√≤n l·∫°i: ${Math.floor(isPlayerWinner ? battleResult.player1Ki : battleResult.player2Ki).toLocaleString()}/${Math.floor(battleResult.winner.stats.ki).toLocaleString()} (${playerKiPercent}%)\n${kiBar}\n\n` +
                                        `üí¢ T·ªïng s√°t th∆∞∆°ng g√¢y ra: ${battleResult.totalDamage.attacker.toLocaleString()}\n` +
                                        `üí¢ T·ªïng s√°t th∆∞∆°ng nh·∫≠n v√†o: ${battleResult.totalDamage.defender.toLocaleString()}\n\n` +
                                        `üìä ùóòùó´ùó£ th∆∞·ªüng: +${expGain}\n` +
                                        `‚è≥ Th·ªùi gian h·ªìi PvP: 1 ph√∫t`,
                                        threadID,
                                        messageID
                                    );
                                }, 50000);
                            }, 50000);
                        };

                        sendBattleInChunks(battleResult, player, opponent);
                    }
                    return;
                }

                case "rank": {
                    const players = Object.entries(playerData)
                        .map(([id, data]) => ({
                            id,
                            name: data.name,
                            power: data.stats.power,
                            race: PLANETS[data.planet].name,
                            planet: data.planet,
                            evolution: data.evolution?.name || null
                        }))
                        .sort((a, b) => b.power - a.power)
                        .slice(0, 10);

                    let ranking = "üèÜ B·∫¢NG X·∫æP H·∫†NG S·ª®C M·∫†NH üèÜ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n";
                    players.forEach((player, index) => {

                        const medal = index === 0 ? "ü•á" : index === 1 ? "ü•à" : index === 2 ? "ü•â" : `${index + 1}.`;

                        const raceEmoji = player.planet === "EARTH" ? "üåé" :
                            player.planet === "NAMEK" ? "üëΩ" :
                                player.planet === "SAIYAN" ? "üêí" : "üëΩ";

                        const evolutionInfo = player.evolution ? ` (${player.evolution})` : '';

                        ranking += `${medal} ${player.name}\n`;
                        ranking += `${raceEmoji} T·ªôc: ${player.race}${evolutionInfo}\n`;
                        ranking += `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${player.power.toLocaleString()}\n\n`;
                    });

                    if (playerData[senderID]) {
                        const player = playerData[senderID];
                        const userRank = Object.entries(playerData)
                            .map(([id, data]) => ({
                                id,
                                power: data.stats.power
                            }))
                            .sort((a, b) => b.power - a.power)
                            .findIndex(p => p.id === senderID) + 1;

                        ranking += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
                        ranking += `üë§ H·∫°ng c·ªßa b·∫°n: #${userRank}\n`;
                        ranking += `üí™ ùó¶ùòÇÃõÃÅùó∞ ùó∫ùóÆÃ£ùóªùóµ: ${player.stats.power.toLocaleString()}\n`;
                        ranking += `üåç T·ªôc: ${PLANETS[player.planet].name}\n`;
                        if (player.evolution) {
                            ranking += `üåü Ti·∫øn h√≥a: ${player.evolution.name}\n`;
                        }
                    }

                    return api.sendMessage(ranking, threadID, messageID);
                }

                default: {
                    if (!playerData[senderID]) {
                        return api.sendMessage(
                            "‚ùå Vui l√≤ng ch·ªçn h√†nh tinh h·ª£p l·ªá!\n\n" +
                            "C√°c h√†nh tinh:\n" +
                            Object.entries(PLANETS).map(([key, data]) =>
                                `- ${key}: ${data.name} (x${data.powerBonus})`
                            ).join("\n"),
                            threadID, messageID
                        );
                    }
                    return api.sendMessage(
                        "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!\n\n" +
                        "C√°c l·ªánh:\n" +
                        "‚Ä¢ info - Xem th√¥ng tin\n" +
                        "‚Ä¢ train - Luy·ªán t·∫≠p\n" +
                        "‚Ä¢ fight - ƒê·∫•u v·ªõi ng∆∞·ªùi kh√°c\n" +
                        "‚Ä¢ rank - Xem b·∫£ng x·∫øp h·∫°ng",
                        threadID, messageID
                    );
                }
            }
        } catch (error) {
            console.error("L·ªói nghi√™m tr·ªçng trong onLaunch:", error);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói trong h·ªá th·ªëng. Vui l√≤ng th·ª≠ l·∫°i sau!", threadID, messageID);
        }
    }
};
