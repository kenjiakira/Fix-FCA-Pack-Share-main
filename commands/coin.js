const fs = require('fs');
const path = require('path');
const getName = require('../utils/getName');
const vipService = require('../game/vip/vipService');
const { getMiningBalance, updateMiningBalance } = require('../game/mining/miningCurrency');

// Mining configuration - ƒêI·ªÄU CH·ªàNH ƒê·ªÇ TƒÇNG H·∫§P D·∫™N
const MINING_CONFIG = {
    BASE_RATE: 2.0, // TƒÉng t·ª´ 0.8 l√™n 2.0 - tƒÉng 2.5x
    COOLDOWN: 25 * 1000, // Gi·∫£m t·ª´ 30s xu·ªëng 25s - nhanh h∆°n 5s
    MAX_OFFLINE_HOURS: 8, // TƒÉng t·ª´ 6h l√™n 8h - thu offline l√¢u h∆°n
    LEVEL_MULTIPLIER: 0.05, // Gi·ªØ nguy√™n
    TEAM_BONUS: 0.015, // Gi·ªØ nguy√™n
    VIP_MULTIPLIERS: {
        GOLD: 1.8  // Gi·ªØ nguy√™n 1.8
    },
    // H·ªá th·ªëng ph√≠ th∆∞∆°ng m·∫°i - GI·∫¢M NH·∫∏
    FEES: {
        WITHDRAWAL_FEE: 0.10, // Gi·∫£m t·ª´ 12% xu·ªëng 10%
        AUTO_MINING_FEE: 0.12, // Gi·∫£m t·ª´ 15% xu·ªëng 12%
        TEAM_CREATE_FEE: 3000, // Gi·ªØ nguy√™n
        EQUIPMENT_TAX: 0.08,
        DAILY_MINING_LIMIT_FEE: 100, // Gi·∫£m t·ª´ 120 xu·ªëng 100 coins
    },
    // Gi·ªõi h·∫°n r√∫t ti·ªÅn - GI·∫¢M THRESHOLD
    WITHDRAWAL: {
        MIN_AMOUNT: 8000, // Gi·∫£m t·ª´ 15k xu·ªëng 8k - d·ªÖ r√∫t h∆°n
        DAILY_LIMIT: 50000, // TƒÉng t·ª´ 40k l√™n 50k
        VIP_BONUS_LIMIT: {
            GOLD: 2.0
        }
    },
    // Gi·ªõi h·∫°n ƒë√†o h√†ng ng√†y - TƒÇNG
    DAILY_MINING: {
        FREE_LIMIT: 15, // TƒÉng t·ª´ 10 l√™n 15 l∆∞·ª£t
        VIP_LIMIT: 60, // TƒÉng t·ª´ 50 l√™n 60 l∆∞·ª£t
        EXTRA_COST: 100 // Gi·∫£m t·ª´ 120 xu·ªëng 100 coins
    },
    // H·ªá th·ªëng th∆∞·ªüng cho ng∆∞·ªùi m·ªõi - TƒÇNG
    NEWBIE_BONUS: {
        FIRST_WEEK_MULTIPLIER: 2.2, // TƒÉng t·ª´ 1.8 l√™n 2.2
        FIRST_MONTH_MULTIPLIER: 1.3, // Gi·ªØ nguy√™n
        WELCOME_BONUS: 3000, // TƒÉng t·ª´ 2k l√™n 3k
        DAILY_LOGIN_BONUS: 150, // TƒÉng t·ª´ 100 l√™n 150
        LEVEL_UP_BONUS: 200, // Gi·ªØ nguy√™n
        MAX_NEWBIE_DAYS: 10 // TƒÉng t·ª´ 7 l√™n 10 ng√†y
    },
    // H·ªá th·ªëng nhi·ªám v·ª• h√†ng ng√†y - TƒÇNG
    DAILY_QUESTS: {
        MINE_10_TIMES: { reward: 800, description: "ƒê√†o 10 l·∫ßn" }, // TƒÉng t·ª´ 500 l√™n 800
        MINE_20_TIMES: { reward: 1800, description: "ƒê√†o 20 l·∫ßn" }, // TƒÉng t·ª´ 1200 l√™n 1800
        JOIN_TEAM: { reward: 1200, description: "Tham gia team" }, // TƒÉng t·ª´ 800 l√™n 1200
        USE_AUTO_MINING: { reward: 900, description: "S·ª≠ d·ª•ng auto mining" } // TƒÉng t·ª´ 600 l√™n 900
    },
    // TH√äM: H·ªá th·ªëng coin sinks
    COIN_SINKS: {
        EQUIPMENT_DURABILITY: true, // Thi·∫øt b·ªã b·ªã h·ªèng theo th·ªùi gian
        MONTHLY_MAINTENANCE: 1000, // Ph√≠ duy tr√¨ h√†ng th√°ng
        INSURANCE_FEE: 0.05, // 5% ph√≠ b·∫£o hi·ªÉm cho s·ªë d∆∞ l·ªõn
        STORAGE_FEE: 100 // Ph√≠ l∆∞u tr·ªØ coins/ng√†y n·∫øu > 50k coins
    },
    // H·ªá th·ªëng ki·ªÉm so√°t kinh t·∫ø - TƒÇNG C∆Ø·ªúNG
    ECONOMY_CONTROL: {
        DAILY_COIN_DESTRUCTION: 0.03, // TƒÉng t·ª´ 2% l√™n 3%
        INFLATION_CONTROL_RATE: 0.99, // Gi·∫£m 1% mining rate m·ªói tu·∫ßn
        MAX_COINS_IN_SYSTEM: 5000000, // Gi·∫£m t·ª´ 10M xu·ªëng 5M
        EMERGENCY_BRAKE: true,
        WEALTH_TAX_THRESHOLD: 100000, // ƒê√°nh thu·∫ø user c√≥ > 100k coins
        WEALTH_TAX_RATE: 0.01 // 1% thu·∫ø gi√†u/ng√†y
    }
};

// Data storage paths
const MINING_DATA_FILE = path.join(__dirname, './json/mining_data.json');
const MINING_TEAMS_FILE = path.join(__dirname, './json/mining_teams.json');

// Initialize data files
function initializeDataFiles() {
    [MINING_DATA_FILE, MINING_TEAMS_FILE].forEach(file => {
        if (!fs.existsSync(file)) {
            const dir = path.dirname(file);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(file, JSON.stringify({}));
        }
    });
}

// Load and save mining data
function loadMiningData() {
    try {
        return JSON.parse(fs.readFileSync(MINING_DATA_FILE, 'utf8'));
    } catch {
        return {};
    }
}

function saveMiningData(data) {
    fs.writeFileSync(MINING_DATA_FILE, JSON.stringify(data, null, 2));
}

function loadTeamData() {
    try {
        return JSON.parse(fs.readFileSync(MINING_TEAMS_FILE, 'utf8'));
    } catch {
        return {};
    }
}

function saveTeamData(data) {
    fs.writeFileSync(MINING_TEAMS_FILE, JSON.stringify(data, null, 2));
}

// Initialize user mining data
function initUser(userId) {
    const data = loadMiningData();
    if (!data[userId]) {
        data[userId] = {
            level: 1,
            experience: 0,
            totalMined: 0,
            miningCount: 0,
            lastMined: 0,
            miningPower: 1,
            team: null,
            autoMining: {
                active: false,
                startTime: 0,
                rate: 0
            },
            achievements: [],
            equipment: [],
            boosts: [],
            // TH√äM: D·ªØ li·ªáu ng∆∞·ªùi m·ªõi
            createdAt: Date.now(),
            lastLogin: Date.now(),
            dailyQuests: {},
            streakDays: 0,
            hasReceivedWelcomeBonus: false
        };
        
        // T·∫∑ng welcome bonus cho ng∆∞·ªùi m·ªõi
        if (!data[userId].hasReceivedWelcomeBonus) {
            updateMiningBalance(userId, MINING_CONFIG.NEWBIE_BONUS.WELCOME_BONUS);
            data[userId].hasReceivedWelcomeBonus = true;
        }
        
        saveMiningData(data);
    }
    return data[userId];
}

// Get user VIP status (integrate with existing VIP system)
function getUserVIP(userId) {
    try {
        const vipStatus = vipService.checkVIP(userId);
        // console.log('[DEBUG] VIP Status:', vipStatus);
        
        if (vipStatus && vipStatus.success && vipStatus.packageId === 3) {
            const benefits = vipService.getVIPBenefits(userId);
            // console.log('[DEBUG] VIP Benefits:', benefits);
            
            return {
                active: true,
                tier: 'GOLD',
                packageId: vipStatus.packageId,
                benefits: benefits,
                expireTime: vipStatus.expireTime,
                daysLeft: vipStatus.daysLeft,
                miningBonus: MINING_CONFIG.VIP_MULTIPLIERS.GOLD
            };
        }
        return null;
    } catch (error) {
        console.error('[ERROR] Error getting VIP status:', error);
        return null;
    }
}

// TH√äM: Ki·ªÉm tra bonus ng∆∞·ªùi m·ªõi v·ªõi gi·ªõi h·∫°n th·ªùi gian
function getNewbieMultiplier(userId) {
    const user = initUser(userId);
    const accountAge = Date.now() - user.createdAt;
    const daysOld = accountAge / (24 * 60 * 60 * 1000);
    
    // Ch·ªâ √°p d·ª•ng trong 10 ng√†y ƒë·∫ßu
    if (daysOld <= MINING_CONFIG.NEWBIE_BONUS.MAX_NEWBIE_DAYS) {
        return MINING_CONFIG.NEWBIE_BONUS.FIRST_WEEK_MULTIPLIER;
    }
    return 1.0;
}

// TH√äM: Ki·ªÉm tra daily login bonus v·ªõi gi·ªõi h·∫°n
function checkDailyLoginBonus(userId) {
    const user = initUser(userId);
    const today = new Date().toDateString();
    const lastLoginDay = new Date(user.lastLogin).toDateString();
    
    if (today !== lastLoginDay) {
        const accountAge = Date.now() - user.createdAt;
        const daysOld = accountAge / (24 * 60 * 60 * 1000);
        
        // Ch·ªâ t·∫∑ng daily login trong 30 ng√†y ƒë·∫ßu
        if (daysOld <= 30) {
            updateMiningBalance(userId, MINING_CONFIG.NEWBIE_BONUS.DAILY_LOGIN_BONUS);
            
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayString = yesterday.toDateString();
            
            if (lastLoginDay === yesterdayString) {
                user.streakDays++;
            } else {
                user.streakDays = 1;
            }
            
            user.lastLogin = Date.now();
            
            const data = loadMiningData();
            data[userId] = user;
            saveMiningData(data);
            
            return {
                bonus: MINING_CONFIG.NEWBIE_BONUS.DAILY_LOGIN_BONUS,
                streak: user.streakDays,
                isNewDay: true
            };
        }
    }
    
    return { isNewDay: false };
}

// TH√äM: √Åp d·ª•ng wealth tax v√† storage fees
function applyDailyCosts(userId) {
    const userBalance = getMiningBalance(userId);
    let totalCosts = 0;
    let messages = [];
    
    // Wealth tax cho user gi√†u
    if (userBalance > MINING_CONFIG.ECONOMY_CONTROL.WEALTH_TAX_THRESHOLD) {
        const wealthTax = Math.floor(userBalance * MINING_CONFIG.ECONOMY_CONTROL.WEALTH_TAX_RATE);
        updateMiningBalance(userId, -wealthTax);
        totalCosts += wealthTax;
        messages.push(`üí∏ Thu·∫ø gi√†u: -${wealthTax} coins`);
    }
    
    // Storage fee cho s·ªë d∆∞ l·ªõn
    if (userBalance > 50000) {
        const storageFee = MINING_CONFIG.COIN_SINKS.STORAGE_FEE;
        updateMiningBalance(userId, -storageFee);
        totalCosts += storageFee;
        messages.push(`üì¶ Ph√≠ l∆∞u tr·ªØ: -${storageFee} coins`);
    }
    
    return { totalCosts, messages };
}

// TH√äM: C·∫≠p nh·∫≠t daily quests v·ªõi rewards th·∫•p h∆°n
function updateDailyQuests(userId, action, amount = 1) {
    const user = initUser(userId);
    const today = new Date().toDateString();
    
    if (!user.dailyQuests[today]) {
        user.dailyQuests[today] = {
            mineCount: 0,
            joinedTeam: false,
            usedAutoMining: false,
            completed: []
        };
    }
    
    const todayQuests = user.dailyQuests[today];
    let rewards = [];
    
    switch (action) {
        case 'mine':
            todayQuests.mineCount += amount;
            
            if (todayQuests.mineCount >= 10 && !todayQuests.completed.includes('MINE_10_TIMES')) {
                todayQuests.completed.push('MINE_10_TIMES');
                updateMiningBalance(userId, MINING_CONFIG.DAILY_QUESTS.MINE_10_TIMES.reward);
                rewards.push({
                    name: MINING_CONFIG.DAILY_QUESTS.MINE_10_TIMES.description,
                    reward: MINING_CONFIG.DAILY_QUESTS.MINE_10_TIMES.reward
                });
            }
            
            if (todayQuests.mineCount >= 20 && !todayQuests.completed.includes('MINE_20_TIMES')) {
                todayQuests.completed.push('MINE_20_TIMES');
                updateMiningBalance(userId, MINING_CONFIG.DAILY_QUESTS.MINE_20_TIMES.reward);
                rewards.push({
                    name: MINING_CONFIG.DAILY_QUESTS.MINE_20_TIMES.description,
                    reward: MINING_CONFIG.DAILY_QUESTS.MINE_20_TIMES.reward
                });
            }
            break;
            
        case 'join_team':
            if (!todayQuests.joinedTeam && !todayQuests.completed.includes('JOIN_TEAM')) {
                todayQuests.joinedTeam = true;
                todayQuests.completed.push('JOIN_TEAM');
                updateMiningBalance(userId, MINING_CONFIG.DAILY_QUESTS.JOIN_TEAM.reward);
                rewards.push({
                    name: MINING_CONFIG.DAILY_QUESTS.JOIN_TEAM.description,
                    reward: MINING_CONFIG.DAILY_QUESTS.JOIN_TEAM.reward
                });
            }
            break;
            
        case 'auto_mining':
            if (!todayQuests.usedAutoMining && !todayQuests.completed.includes('USE_AUTO_MINING')) {
                todayQuests.usedAutoMining = true;
                todayQuests.completed.push('USE_AUTO_MINING');
                updateMiningBalance(userId, MINING_CONFIG.DAILY_QUESTS.USE_AUTO_MINING.reward);
                rewards.push({
                    name: MINING_CONFIG.DAILY_QUESTS.USE_AUTO_MINING.description,
                    reward: MINING_CONFIG.DAILY_QUESTS.USE_AUTO_MINING.reward
                });
            }
            break;
    }
    
    const data = loadMiningData();
    data[userId] = user;
    saveMiningData(data);
    
    return rewards;
}

// TH√äM: H·ªá th·ªëng t√≠nh to√°n mining v·ªõi inflation control
function calculateMining(userId, timeDiff = null) {
    const user = initUser(userId);
    const now = Date.now();
    
    if (!timeDiff) {
        timeDiff = Math.min((now - user.lastMined) / 1000, MINING_CONFIG.MAX_OFFLINE_HOURS * 3600);
    }
    
    let baseEarnings = MINING_CONFIG.BASE_RATE * (timeDiff / 60);
    
    // √Åp d·ª•ng inflation control
    const inflationMultiplier = getInflationMultiplier();
    baseEarnings *= inflationMultiplier;
    
    // Level bonus (gi·∫£m)
    const levelBonus = 1 + (user.level - 1) * MINING_CONFIG.LEVEL_MULTIPLIER;
    
    // Mining power bonus
    const powerBonus = user.miningPower;
    
    // Team bonus (gi·∫£m)
    let teamBonus = 1;
    if (user.team) {
        const teamData = loadTeamData();
        const team = teamData[user.team];
        if (team) {
            teamBonus = 1 + (team.members.length * MINING_CONFIG.TEAM_BONUS);
        }
    }
    
    // VIP bonus
    let vipBonus = 1;
    const vipData = getUserVIP(userId);
    if (vipData && vipData.active && vipData.benefits) {
        if (vipData.benefits.miningBonus) {
            vipBonus = 1 + vipData.benefits.miningBonus;
        } else {
            vipBonus = MINING_CONFIG.VIP_MULTIPLIERS[vipData.tier] || 1;
        }
    }
    
    // Newbie bonus (gi·ªõi h·∫°n th·ªùi gian)
    const newbieMultiplier = getNewbieMultiplier(userId);
    
    // Equipment bonus
    let equipmentBonus = 1;
    user.equipment.forEach(eq => {
        equipmentBonus += eq.bonus || 0;
    });
    
    // Active boosts
    let boostMultiplier = 1;
    const activeBoosts = user.boosts.filter(boost => boost.expires > now);
    activeBoosts.forEach(boost => {
        boostMultiplier += boost.multiplier || 0;
    });
    
    const finalEarnings = baseEarnings * levelBonus * powerBonus * teamBonus * vipBonus * newbieMultiplier * equipmentBonus * boostMultiplier;
    
    return {
        amount: Math.floor(finalEarnings),
        levelBonus,
        powerBonus,
        teamBonus,
        vipBonus,
        newbieMultiplier,
        equipmentBonus,
        boostMultiplier,
        inflationMultiplier,
        vipData
    };
}

// TH√äM: H·ªá th·ªëng r√∫t ti·ªÅn v·ªõi ph√≠ cao h∆°n v√† gi·ªõi h·∫°n ch·∫∑t
function processWithdrawal(userId, amount) {
    const user = initUser(userId);
    const userBalance = getMiningBalance(userId); // Thay ƒë·ªïi ·ªü ƒë√¢y
    
    // Ki·ªÉm tra s·ªë d∆∞ t·ªëi thi·ªÉu
    if (userBalance < MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT) {
        return {
            success: false,
            message: `‚ùå C·∫ßn √≠t nh·∫•t ${MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT.toLocaleString()} coins ƒë·ªÉ r√∫t ti·ªÅn!`
        };
    }
    
    // Ki·ªÉm tra s·ªë ti·ªÅn r√∫t
    if (amount < MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT) {
        return {
            success: false,
            message: `‚ùå S·ªë ti·ªÅn r√∫t t·ªëi thi·ªÉu l√† ${MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT.toLocaleString()} coins!`
        };
    }
    
    if (amount > userBalance) {
        return {
            success: false,
            message: "‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß!"
        };
    }
    
    // Ki·ªÉm tra gi·ªõi h·∫°n h√†ng ng√†y
    const today = new Date().toDateString();
    if (!user.withdrawalHistory) user.withdrawalHistory = {};
    if (!user.withdrawalHistory[today]) user.withdrawalHistory[today] = 0;
    
    let dailyLimit = MINING_CONFIG.WITHDRAWAL.DAILY_LIMIT;
    const vipData = getUserVIP(userId);
    if (vipData && vipData.active && vipData.tier === 'GOLD') {
        dailyLimit *= MINING_CONFIG.WITHDRAWAL.VIP_BONUS_LIMIT.GOLD;
    }
    
    if (user.withdrawalHistory[today] + amount > dailyLimit) {
        return {
            success: false,
            message: `‚ùå V∆∞·ª£t qu√° gi·ªõi h·∫°n r√∫t ti·ªÅn h√†ng ng√†y! C√≤n l·∫°i: ${(dailyLimit - user.withdrawalHistory[today]).toLocaleString()} coins`
        };
    }
    
    // T√≠nh ph√≠ r√∫t ti·ªÅn (tƒÉng l√™n 12%)
    const fee = Math.floor(amount * MINING_CONFIG.FEES.WITHDRAWAL_FEE);
    const actualAmount = amount - fee;
    
    // X·ª≠ l√Ω r√∫t ti·ªÅn
    updateMiningBalance(userId, -amount); // Thay ƒë·ªïi ·ªü ƒë√¢y
    user.withdrawalHistory[today] += amount;
    
    // L∆∞u d·ªØ li·ªáu
    const data = loadMiningData();
    data[userId] = user;
    saveMiningData(data);
    
    return {
        success: true,
        amount: actualAmount,
        fee: fee,
        remaining: userBalance - amount
    };
}

// TH√äM: Ki·ªÉm so√°t l·∫°m ph√°t
function getInflationMultiplier() {
    const data = loadMiningData();
    const totalCoinsInSystem = Object.values(data).reduce((sum, user) => {
        return sum + (user.totalMined || 0);
    }, 0);
    
    // N·∫øu qu√° nhi·ªÅu coins trong h·ªá th·ªëng, gi·∫£m mining rate
    if (totalCoinsInSystem > MINING_CONFIG.ECONOMY_CONTROL.MAX_COINS_IN_SYSTEM) {
        const excess = totalCoinsInSystem - MINING_CONFIG.ECONOMY_CONTROL.MAX_COINS_IN_SYSTEM;
        const reductionFactor = Math.max(0.3, 1 - (excess / MINING_CONFIG.ECONOMY_CONTROL.MAX_COINS_IN_SYSTEM));
        return reductionFactor;
    }
    
    return 1.0;
}

// Calculate required XP for next level
function getRequiredXP(level) {
    return Math.floor(100 * Math.pow(1.5, level - 1));
}

// Handle level up
function checkLevelUp(userId) {
    const data = loadMiningData();
    const user = data[userId];
    
    if (!user) return false;
    
    const requiredXP = getRequiredXP(user.level);
    
    if (user.experience >= requiredXP) {
        user.level++;
        user.experience -= requiredXP;
        user.miningPower += 0.1;
        
        // TH√äM: Level up bonus
        updateMiningBalance(userId, MINING_CONFIG.NEWBIE_BONUS.LEVEL_UP_BONUS);
        
        saveMiningData(data);
        return true;
    }
    
    return false;
}

// Auto-mining system
function startAutoMining(userId, hours) {
    const data = loadMiningData();
    const user = data[userId];
    
    if (!user) return false;
    
    const now = Date.now();
    user.autoMining = {
        active: true,
        startTime: now,
        endTime: now + (hours * 60 * 60 * 1000),
        rate: calculateMining(userId, 3600).amount // hourly rate
    };
    
    saveMiningData(data);
    return true;
}

function claimAutoMining(userId) {
    const data = loadMiningData();
    const user = data[userId];
    
    if (!user || !user.autoMining.active) return null;
    
    const now = Date.now();
    const miningTime = Math.min(now - user.autoMining.startTime, user.autoMining.endTime - user.autoMining.startTime);
    const hoursActive = miningTime / (60 * 60 * 1000);
    
    const earnings = Math.floor(user.autoMining.rate * hoursActive);
    
    // Reset auto mining if expired
    if (now >= user.autoMining.endTime) {
        user.autoMining.active = false;
    } else {
        user.autoMining.startTime = now;
    }
    
    user.totalMined += earnings;
    updateMiningBalance(userId, earnings);
    
    saveMiningData(data);
    
    return {
        amount: earnings,
        hoursActive: hoursActive.toFixed(1),
        stillActive: user.autoMining.active
    };
}

// TH√äM: Ki·ªÉm tra gi·ªõi h·∫°n ƒë√†o h√†ng ng√†y
function checkDailyMiningLimit(userId) {
    const user = initUser(userId);
    const today = new Date().toDateString();
    
    if (!user.dailyMining) user.dailyMining = {};
    if (!user.dailyMining[today]) user.dailyMining[today] = 0;
    
    const vipData = getUserVIP(userId);
    // console.log('[DEBUG] VIP Data for mining limit:', vipData);
    
    // Ki·ªÉm tra VIP ch·∫∑t ch·∫Ω h∆°n
    const isVip = vipData && vipData.active && vipData.packageId === 3;
    const dailyLimit = isVip ? MINING_CONFIG.DAILY_MINING.VIP_LIMIT : MINING_CONFIG.DAILY_MINING.FREE_LIMIT;

    // console.log('[DEBUG] Mining limit check:', {
    //     userId,
    //     isVip,
    //     dailyLimit,
    //     currentCount: user.dailyMining[today]
    // });
    
    return {
        count: user.dailyMining[today],
        limit: dailyLimit,
        canMine: user.dailyMining[today] < dailyLimit,
        needsPay: user.dailyMining[today] >= dailyLimit,
        isVip
    };
}

function incrementDailyMining(userId) {
    const user = initUser(userId);
    const today = new Date().toDateString();
    
    if (!user.dailyMining) user.dailyMining = {};
    if (!user.dailyMining[today]) user.dailyMining[today] = 0;
    
    user.dailyMining[today]++;
    
    const data = loadMiningData();
    data[userId] = user;
    saveMiningData(data);
}

// Initialize data files
initializeDataFiles();

module.exports = {
    name: "coin",
    dev: "HNT", 
    category: "Games",
    info: "MMO Mining Game",
    onPrefix: true,
    usages: "coin [mine/auto/team/shop/stats]",
    cooldowns: 2,

    onLoad: function() {
        console.log('[MINING] MMO Mining system loaded');
    },

    onLaunch: async function({ api, event, target = [] }) {
        const { threadID, messageID, senderID } = event;
        const action = target[0]?.toLowerCase();

        try {
            const user = initUser(senderID);
            const userName = await getName(senderID);

            switch (action) {
                case "help":
                case "h∆∞·ªõng_d·∫´n": {
                    return api.sendMessage(
                        "üìö H∆Ø·ªöNG D·∫™N CHI TI·∫æT MINING üìö\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "1Ô∏è‚É£ B·∫ÆT ƒê·∫¶U:\n" +
                        "‚Ä¢ .coin mine - ƒê√†o coin c∆° b·∫£n\n" +
                        "‚Ä¢ Free user: 15 l∆∞·ª£t/ng√†y\n" +
                        "‚Ä¢ VIP Gold: 60 l∆∞·ª£t/ng√†y\n" +
                        "‚Ä¢ Cooldown: 25 gi√¢y/l·∫ßn ƒë√†o\n\n" +
                        
                        "2Ô∏è‚É£ N√ÇNG CAO HI·ªÜU QU·∫¢:\n" +
                        "‚Ä¢ Tham gia team (+1.5%/th√†nh vi√™n)\n" +
                        "‚Ä¢ Mua VIP Gold (+80% coins)\n" +
                        "‚Ä¢ S·ª≠ d·ª•ng auto mining (AFK)\n" +
                        "‚Ä¢ Thu ho·∫°ch offline (t·ªëi ƒëa 8h)\n\n" +
                        
                        "3Ô∏è‚É£ H·ªÜ TH·ªêNG TEAM:\n" +
                        "‚Ä¢ .coin team create [t√™n] - T·∫°o team\n" +
                        "‚Ä¢ .coin team join [ID] - V√†o team\n" +
                        "‚Ä¢ .coin team info - Xem th√¥ng tin\n" +
                        "‚Ä¢ .coin team leave - R·ªùi team\n" +
                        "‚Ä¢ Ph√≠ t·∫°o team: 3,000 coins\n" +
                        "‚Ä¢ T·ªëi ƒëa 10 th√†nh vi√™n/team\n\n" +
                        
                        "4Ô∏è‚É£ AUTO MINING:\n" +
                        "‚Ä¢ .coin auto start [gi·ªù] - B·∫≠t auto\n" +
                        "‚Ä¢ .coin auto claim - Thu ho·∫°ch\n" +
                        "‚Ä¢ Chi ph√≠: 80 coins/gi·ªù\n" +
                        "‚Ä¢ Ph√≠ d·ªãch v·ª•: 12%\n" +
                        "‚Ä¢ Th·ªùi gian: 1-24 gi·ªù\n\n" +
                        
                        "5Ô∏è‚É£ NHI·ªÜM V·ª§ H√ÄNG NG√ÄY:\n" +
                        "‚Ä¢ ƒê√†o 10 l·∫ßn: +800 coins\n" +
                        "‚Ä¢ ƒê√†o 20 l·∫ßn: +1,800 coins\n" +
                        "‚Ä¢ Tham gia team: +1,200 coins\n" +
                        "‚Ä¢ Auto mining: +900 coins\n" +
                        "‚Ä¢ Reset v√†o 00:00 m·ªói ng√†y\n\n" +
                        
                        "6Ô∏è‚É£ R√öT TI·ªÄN & PH√ç:\n" +
                        "‚Ä¢ .coin withdraw [s·ªë ti·ªÅn]\n" +
                        "‚Ä¢ R√∫t t·ªëi thi·ªÉu: 8,000 coins\n" +
                        "‚Ä¢ Ph√≠ r√∫t: 10% s·ªë ti·ªÅn r√∫t\n" +
                        "‚Ä¢ Gi·ªõi h·∫°n/ng√†y: 50,000 coins\n" +
                        "‚Ä¢ VIP: +100% gi·ªõi h·∫°n r√∫t\n\n" +
                        
                        "7Ô∏è‚É£ TI·ªÜN √çCH KH√ÅC:\n" +
                        "‚Ä¢ .coin stats - Xem th√¥ng s·ªë\n" +
                        "‚Ä¢ .coin shop - Mua v·∫≠t ph·∫©m\n" +
                        "‚Ä¢ .coin leaderboard - BXH\n" +
                        "‚Ä¢ .coin quests - Nhi·ªám v·ª•\n\n" +
                        
                        "üíé L∆ØU √ù QUAN TR·ªåNG:\n" +
                        "‚Ä¢ Newbie ƒë∆∞·ª£c x2.2 coins trong 10 ng√†y ƒë·∫ßu\n" +
                        "‚Ä¢ Daily login bonus trong 30 ng√†y ƒë·∫ßu\n" +
                        "‚Ä¢ Thu·∫ø gi√†u khi c√≥ >100k coins\n" +
                        "‚Ä¢ Ph√≠ l∆∞u tr·ªØ khi c√≥ >50k coins\n" +
                        "‚Ä¢ C√≥ th·ªÉ AFK ƒë·ªÉ auto mining v√† thu offline\n\n" +
                        
                        "üëë ∆ØU ƒê√ÉI VIP GOLD (49K/TH√ÅNG):\n" +
                        "‚Ä¢ 60 l∆∞·ª£t ƒë√†o/ng√†y (thay v√¨ 15)\n" + 
                        "‚Ä¢ +80% coins khi ƒë√†o\n" +
                        "‚Ä¢ x2 gi·ªõi h·∫°n r√∫t ti·ªÅn/ng√†y\n" +
                        "‚Ä¢ Gi·∫£m ph√≠ auto mining\n" +
                        "‚Ä¢ ∆Øu ti√™n h·ªó tr·ª£ 24/7\n\n" +
                        
                        "üí∞ THU NH·∫¨P D·ª∞ KI·∫æN:\n" +
                        "üÜì Free User: 80-100 coins/ng√†y ‚Üí R√∫t ƒë∆∞·ª£c sau 80-100 ng√†y\n" +
                        "üëë VIP Gold: 750-800 coins/ng√†y ‚Üí R√∫t ƒë∆∞·ª£c sau 10-12 ng√†y\n\n" +
                        
                        "üí° M·∫∏O CH∆†I HI·ªÜU QU·∫¢:\n" +
                        "1. Tham gia team c√†ng s·ªõm c√†ng t·ªët\n" +
                        "2. D√πng auto mining khi offline\n" +
                        "3. L√†m nhi·ªám v·ª• h√†ng ng√†y\n" +
                        "4. ƒê·∫ßu t∆∞ VIP ƒë·ªÉ tƒÉng thu nh·∫≠p x8\n" +
                        "5. Thu ho·∫°ch ƒë·ªÅu ƒë·∫∑n tr√°nh m·∫•t coins\n\n" +
                        
                        "‚ö†Ô∏è C·∫¢NH B√ÅO GIAN L·∫¨N:\n" +
                        "‚Ä¢ Nghi√™m c·∫•m s·ª≠ d·ª•ng tool auto/hack\n" +
                        "‚Ä¢ Nghi√™m c·∫•m l·∫°m d·ª•ng l·ªói h·ªá th·ªëng\n" +
                        "‚Ä¢ Vi ph·∫°m s·∫Ω b·ªã kh√≥a t√†i kho·∫£n vƒ©nh vi·ªÖn\n\n" +
                        
                        "üìû H·ªñ TR·ª¢ & B√ÅO L·ªñI:\n" +
                        "‚Ä¢ B√°o c√°o l·ªói: Admin HNT\n" +
                        "‚Ä¢ Group h·ªó tr·ª£: fb.com/groups/...\n" +
                        "‚Ä¢ Fanpage: fb.com/...",
                        threadID, messageID
                    );
                    break;
                }
                
                case "mine":
                case "ƒë√†o": {
                    // √Åp d·ª•ng daily costs tr∆∞·ªõc khi mining
                    const dailyCosts = applyDailyCosts(senderID);
                    let costMessage = "";
                    if (dailyCosts.totalCosts > 0) {
                        costMessage = `\n${dailyCosts.messages.join('\n')}`;
                    }

                    // Ki·ªÉm tra daily login bonus
                    const loginBonus = checkDailyLoginBonus(senderID);
                    let loginMessage = "";
                    if (loginBonus.isNewDay) {
                        loginMessage = `\nüéÅ Daily Login: +${loginBonus.bonus} coins (Streak: ${loginBonus.streak} ng√†y)`;
                    }

                    const now = Date.now();
                    const timeSinceLastMine = now - user.lastMined;

                    if (timeSinceLastMine < MINING_CONFIG.COOLDOWN) {
                        const remainingTime = Math.ceil((MINING_CONFIG.COOLDOWN - timeSinceLastMine) / 1000);
                        return api.sendMessage(
                            `‚è≥ B·∫°n c·∫ßn ƒë·ª£i ${remainingTime} gi√¢y n·ªØa ƒë·ªÉ ƒë√†o ti·∫øp!${loginMessage}${costMessage}`,
                            threadID, messageID
                        );
                    }

                    // Ki·ªÉm tra gi·ªõi h·∫°n ƒë√†o h√†ng ng√†y
                    const dailyLimit = checkDailyMiningLimit(senderID);
                    
                    if (dailyLimit.needsPay) {
                        const extraCost = MINING_CONFIG.DAILY_MINING.EXTRA_COST;
                        
                        if (getMiningBalance(senderID) < extraCost) {
                            return api.sendMessage(
                                `‚ùå ƒê√£ h·∫øt l∆∞·ª£t ƒë√†o mi·ªÖn ph√≠!\n\n` +
                                `üìä H√¥m nay: ${dailyLimit.count}/${dailyLimit.limit} l∆∞·ª£t\n` +
                                `üí∞ ƒê√†o th√™m: ${extraCost} coins/l·∫ßn\n` +
                                `üíé S·ªë d∆∞: ${getMiningBalance(senderID)} coins\n\n` +
                                `üëë VIP Gold: ${dailyLimit.isVip ? "‚úÖ" : "‚ùå"}\n` +
                                `üí° Mua VIP Gold 49k/th√°ng ƒë·ªÉ c√≥ ${MINING_CONFIG.DAILY_MINING.VIP_LIMIT} l∆∞·ª£t/ng√†y!${loginMessage}${costMessage}`,
                                threadID, messageID
                            );
                        }
                        
                        updateMiningBalance(senderID, -extraCost);
                    }

                    incrementDailyMining(senderID);

                    // Calculate offline earnings if applicable
                    let offlineMessage = "";
                    if (user.lastMined > 0 && timeSinceLastMine > MINING_CONFIG.COOLDOWN) {
                        const offlineHours = Math.min(timeSinceLastMine / (60 * 60 * 1000), MINING_CONFIG.MAX_OFFLINE_HOURS);
                        if (offlineHours >= 0.1) {
                            const offlineEarnings = calculateMining(senderID, offlineHours * 3600);
                            updateMiningBalance(senderID, offlineEarnings.amount);
                            user.totalMined += offlineEarnings.amount;
                            offlineMessage = `\nüí§ Thu nh·∫≠p offline: ${offlineEarnings.amount} coins (${offlineHours.toFixed(1)}h)`;
                        }
                    }

                    // Regular mining
                    const mining = calculateMining(senderID, 60);
                    const minedAmount = mining.amount;

                    // Update user data
                    const data = loadMiningData();
                    data[senderID].lastMined = now;
                    data[senderID].miningCount++;
                    data[senderID].totalMined += minedAmount;
                    data[senderID].experience += minedAmount;
                    updateMiningBalance(senderID, minedAmount);
                    saveMiningData(data);

                    // C·∫≠p nh·∫≠t daily quests
                    const questRewards = updateDailyQuests(senderID, 'mine', 1);
                    let questMessage = "";
                    if (questRewards.length > 0) {
                        questMessage = `\nüéØ Ho√†n th√†nh nhi·ªám v·ª•:`;
                        questRewards.forEach(quest => {
                            questMessage += `\n‚úÖ ${quest.name}: +${quest.reward} coins`;
                        });
                    }

                    // Check for level up
                    const leveledUp = checkLevelUp(senderID);
                    let levelUpMessage = "";
                    if (leveledUp) {
                        levelUpMessage = `\nüéâ LEVEL UP! B·∫°n ƒë√£ ƒë·∫°t level ${user.level + 1}!\nüí∞ Th∆∞·ªüng level up: +${MINING_CONFIG.NEWBIE_BONUS.LEVEL_UP_BONUS} coins`;
                    }

                    // Prepare bonus info
                    let bonusMessage = "";
                    if (mining.vipData && mining.vipData.active) {
                        bonusMessage += `\nüëë VIP ${mining.vipData.tier}: +${((mining.vipBonus - 1) * 100).toFixed(0)}%`;
                    }
                    if (mining.newbieMultiplier > 1) {
                        bonusMessage += `\nüÜï Newbie Bonus: x${mining.newbieMultiplier}`;
                    }
                    if (mining.inflationMultiplier < 1) {
                        bonusMessage += `\n‚ö†Ô∏è Economic adjustment: x${mining.inflationMultiplier.toFixed(2)}`;
                    }

                    // Th√¥ng tin gi·ªõi h·∫°n ƒë√†o
                    const newDailyLimit = checkDailyMiningLimit(senderID);
                    let limitMessage = `\nüìä L∆∞·ª£t ƒë√†o: ${newDailyLimit.count}/${newDailyLimit.limit}`;
                    if (dailyLimit.needsPay) {
                        limitMessage += ` (ƒë√£ tr·∫£ ${MINING_CONFIG.DAILY_MINING.EXTRA_COST} coins)`;
                    }

                    return api.sendMessage(
                        `‚õèÔ∏è MINING TH√ÄNH C√îNG! ‚õèÔ∏è\n` +
                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                        `üí∞ ƒê√£ ƒë√†o: ${minedAmount} coins\n` +
                        `‚ö° Mining Power: ${user.miningPower.toFixed(1)}x\n` +
                        `üìä Level: ${user.level} (${user.experience}/${getRequiredXP(user.level)} XP)\n` +
                        `üíé T·ªïng ƒë√†o: ${user.totalMined} coins\n` +
                        `üî¢ L·∫ßn ƒë√†o: ${user.miningCount}\n` +
                        `üíµ S·ªë d∆∞: ${getMiningBalance(senderID)} coins${limitMessage}${loginMessage}${costMessage}${offlineMessage}${bonusMessage}${questMessage}${levelUpMessage}`,
                        threadID, messageID
                    );
                    break;
                }

                case "auto": {
                    const subAction = target[1]?.toLowerCase();
                    
                    if (subAction === "start") {
                        const hours = parseInt(target[2]) || 1;
                        if (hours < 1 || hours > 24) {
                            return api.sendMessage("‚ùå Th·ªùi gian auto mining ph·∫£i t·ª´ 1-24 gi·ªù!", threadID, messageID);
                        }
                        
                        const baseCost = hours * 80; // Gi·∫£m t·ª´ 100 xu·ªëng 80 coins/gi·ªù
                        const serviceFee = Math.floor(baseCost * MINING_CONFIG.FEES.AUTO_MINING_FEE);
                        const totalCost = baseCost + serviceFee;
                        
                        if (getMiningBalance(senderID) < totalCost) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng ƒë·ªß coins!\n` +
                                `üí∞ Chi ph√≠: ${baseCost.toLocaleString()} coins\n` +
                                `üí∏ Ph√≠ d·ªãch v·ª•: ${serviceFee.toLocaleString()} coins (${(MINING_CONFIG.FEES.AUTO_MINING_FEE * 100)}%)\n` +
                                `üíé T·ªïng c·ªông: ${totalCost.toLocaleString()} coins`,
                                threadID, messageID
                            );
                        }
                        
                        updateMiningBalance(senderID, -totalCost);
                        startAutoMining(senderID, hours);
                        
                        // TH√äM: C·∫≠p nh·∫≠t quest auto mining
                        const questRewards = updateDailyQuests(senderID, 'auto_mining');
                        let questMessage = "";
                        if (questRewards.length > 0) {
                            questMessage = `\nüéØ Ho√†n th√†nh nhi·ªám v·ª•: ${questRewards[0].name} (+${questRewards[0].reward} coins)`;
                        }
                        
                        return api.sendMessage(
                            `‚úÖ ƒê√£ k√≠ch ho·∫°t auto mining ${hours} gi·ªù!\n` +
                            `üí∞ Chi ph√≠ c∆° b·∫£n: ${baseCost.toLocaleString()} coins\n` +
                            `üí∏ Ph√≠ d·ªãch v·ª•: ${serviceFee.toLocaleString()} coins (${(MINING_CONFIG.FEES.AUTO_MINING_FEE * 100)}%)\n` +
                            `üíé T·ªïng thanh to√°n: ${totalCost.toLocaleString()} coins\n` +
                            `‚è∞ K·∫øt th√∫c: ${new Date(Date.now() + hours * 60 * 60 * 1000).toLocaleString()}${questMessage}`,
                            threadID, messageID
                        );
                    } else if (subAction === "claim") {
                        const claimed = claimAutoMining(senderID);
                        if (!claimed) {
                            return api.sendMessage("‚ùå B·∫°n kh√¥ng c√≥ auto mining n√†o ƒëang ho·∫°t ƒë·ªông!", threadID, messageID);
                        }
                        
                        return api.sendMessage(
                            `üí∞ Thu ho·∫°ch auto mining!\n` +
                            `üíé Nh·∫≠n ƒë∆∞·ª£c: ${claimed.amount} coins\n` +
                            `‚è∞ Th·ªùi gian: ${claimed.hoursActive} gi·ªù\n` +
                            `${claimed.stillActive ? "üü¢ Auto mining v·∫´n ƒëang ho·∫°t ƒë·ªông" : "üî¥ Auto mining ƒë√£ k·∫øt th√∫c"}`,
                            threadID, messageID
                        );
                    } else {
                        return api.sendMessage(
                            "ü§ñ AUTO MINING ü§ñ\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üìù L·ªÜNH:\n" +
                            "‚Ä¢ .mining auto start [gi·ªù] - B·∫≠t auto mining\n" +
                            "‚Ä¢ .mining auto claim - Thu ho·∫°ch\n\n" +
                            "üí∞ CHI PH√ç:\n" +
                            "‚Ä¢ Ph√≠ c∆° b·∫£n: 80 coins/gi·ªù\n" +
                            `‚Ä¢ Ph√≠ d·ªãch v·ª•: ${(MINING_CONFIG.FEES.AUTO_MINING_FEE * 100)}% (duy tr√¨ h·ªá th·ªëng)\n` +
                            "‚Ä¢ V√≠ d·ª•: 10 gi·ªù = 800 + 96 = 896 coins\n\n" +
                            "‚è∞ T·ªëi ƒëa: 24 gi·ªù\n" +
                            "üí° Auto mining s·∫Ω ƒë√†o coin cho b·∫°n khi offline!",
                            threadID, messageID
                        );
                    }
                    break;
                }

                case "team": {
                    const subAction = target[1]?.toLowerCase();
                    const teamData = loadTeamData();
                    
                    if (subAction === "create") {
                        const teamName = target.slice(2).join(" ");
                        if (!teamName || teamName.length < 3) {
                            return api.sendMessage("‚ùå T√™n team ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±!", threadID, messageID);
                        }
                        
                        if (user.team) {
                            return api.sendMessage("‚ùå B·∫°n ƒë√£ c√≥ team r·ªìi!", threadID, messageID);
                        }
                        
                        // Ki·ªÉm tra ph√≠ t·∫°o team
                        if (getMiningBalance(senderID) < MINING_CONFIG.FEES.TEAM_CREATE_FEE) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng ƒë·ªß coins ƒë·ªÉ t·∫°o team!\n` +
                                `üí∞ Ph√≠ t·∫°o team: ${MINING_CONFIG.FEES.TEAM_CREATE_FEE.toLocaleString()} coins\n` +
                                `üíé S·ªë d∆∞ c·ªßa b·∫°n: ${getMiningBalance(senderID).toLocaleString()} coins`,
                                threadID, messageID
                            );
                        }
                        
                        // Check if team name exists
                        const teamExists = Object.values(teamData).some(team => team.name.toLowerCase() === teamName.toLowerCase());
                        if (teamExists) {
                            return api.sendMessage("‚ùå T√™n team ƒë√£ t·ªìn t·∫°i!", threadID, messageID);
                        }
                        
                        // Tr·ª´ ph√≠ t·∫°o team
                        updateMiningBalance(senderID, -MINING_CONFIG.FEES.TEAM_CREATE_FEE);
                        
                        const teamId = `team_${Date.now()}`;
                        teamData[teamId] = {
                            name: teamName,
                            leader: senderID,
                            members: [senderID],
                            totalMined: 0,
                            level: 1,
                            created: Date.now()
                        };
                        
                        const data = loadMiningData();
                        data[senderID].team = teamId;
                        
                        saveTeamData(teamData);
                        saveMiningData(data);
                        
                        return api.sendMessage(
                            `‚úÖ ƒê√£ t·∫°o team "${teamName}" th√†nh c√¥ng!\n` +
                            `üëë B·∫°n l√† leader\n` +
                            `üí∞ ƒê√£ tr·ª´ ph√≠: ${MINING_CONFIG.FEES.TEAM_CREATE_FEE.toLocaleString()} coins\n` +
                            `üÜî Team ID: ${teamId}`,
                            threadID, messageID
                        );
                    } else if (subAction === "join") {
                        const teamId = target[2];
                        if (!teamId || !teamData[teamId]) {
                            return api.sendMessage("‚ùå Team kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                        }
                        
                        if (user.team) {
                            return api.sendMessage("‚ùå B·∫°n ƒë√£ c√≥ team r·ªìi! H√£y r·ªùi team hi·ªán t·∫°i tr∆∞·ªõc.", threadID, messageID);
                        }
                        
                        const team = teamData[teamId];
                        if (team.members.length >= 10) {
                            return api.sendMessage("‚ùå Team ƒë√£ ƒë·∫ßy (t·ªëi ƒëa 10 th√†nh vi√™n)!", threadID, messageID);
                        }
                        
                        team.members.push(senderID);
                        const data = loadMiningData();
                        data[senderID].team = teamId;
                        
                        saveTeamData(teamData);
                        saveMiningData(data);
                        
                        return api.sendMessage(
                            `‚úÖ ƒê√£ tham gia team "${team.name}"!\n` +
                            `üë• Th√†nh vi√™n: ${team.members.length}/10\n` +
                            `üéÅ Bonus team: +${team.members.length * 5}%`,
                            threadID, messageID
                        );
                    } else if (subAction === "leave") {
                        if (!user.team) {
                            return api.sendMessage("‚ùå B·∫°n ch∆∞a c√≥ team!", threadID, messageID);
                        }
                        
                        const team = teamData[user.team];
                        if (team.leader === senderID) {
                            return api.sendMessage("‚ùå Leader kh√¥ng th·ªÉ r·ªùi team! H√£y chuy·ªÉn quy·ªÅn leader tr∆∞·ªõc.", threadID, messageID);
                        }
                        
                        team.members = team.members.filter(id => id !== senderID);
                        const data = loadMiningData();
                        data[senderID].team = null;
                        
                        saveTeamData(teamData);
                        saveMiningData(data);
                        
                        return api.sendMessage(`‚úÖ ƒê√£ r·ªùi team "${team.name}"!`, threadID, messageID);
                    } else if (subAction === "info") {
                        if (!user.team) {
                            return api.sendMessage("‚ùå B·∫°n ch∆∞a c√≥ team!", threadID, messageID);
                        }
                        
                        const team = teamData[user.team];
                        const isLeader = team.leader === senderID;
                        
                        return api.sendMessage(
                            `üè∞ TH√îNG TIN TEAM üè∞\n` +
                            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                            `üìõ T√™n: ${team.name}\n` +
                            `üëë Leader: ${await getName(team.leader)}\n` +
                            `üë• Th√†nh vi√™n: ${team.members.length}/10\n` +
                            `‚≠ê Level: ${team.level}\n` +
                            `üíé T·ªïng ƒë√†o: ${team.totalMined} coins\n` +
                            `üéÅ Bonus: +${team.members.length * 5}%\n` +
                            `üÜî ID: ${user.team}\n\n` +
                            `${isLeader ? "üëë B·∫°n l√† leader c·ªßa team n√†y" : "üë§ B·∫°n l√† th√†nh vi√™n"}`,
                            threadID, messageID
                        );
                    } else {
                        return api.sendMessage(
                            "üè∞ TEAM SYSTEM üè∞\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üìù L·ªÜNH:\n" +
                            "‚Ä¢ .coin team create [t√™n] - T·∫°o team\n" +
                            "‚Ä¢ .coin team join [ID] - Tham gia team\n" +
                            "‚Ä¢ .coin team leave - R·ªùi team\n" +
                            "‚Ä¢ .coin team info - Xem th√¥ng tin team\n\n" +
                            "üí∞ PH√ç D·ªäCH V·ª§:\n" +
                            `‚Ä¢ Ph√≠ t·∫°o team: ${MINING_CONFIG.FEES.TEAM_CREATE_FEE.toLocaleString()} coins\n` +
                            "‚Ä¢ Tham gia team: Mi·ªÖn ph√≠\n\n" +
                            "üéÅ BONUS:\n" +
                            "‚Ä¢ M·ªói th√†nh vi√™n: +5% mining power\n" +
                            "‚Ä¢ T·ªëi ƒëa 10 th√†nh vi√™n: +50%\n" +
                            "‚Ä¢ C√πng nhau ƒë√†o coin hi·ªáu qu·∫£ h∆°n!",
                            threadID, messageID
                        );
                    }
                    break;
                }

                case "stats":
                case "th·ªëng_k√™": {
                    const requiredXP = getRequiredXP(user.level);
                    const team = user.team ? loadTeamData()[user.team] : null;
                    const vipData = getUserVIP(senderID);
                    
                    let vipInfo = "‚ùå Kh√¥ng c√≥ VIP Gold";
                    if (vipData && vipData.active && vipData.tier === 'GOLD') {
                        vipInfo = `‚úÖ VIP GOLD (c√≤n ${vipData.daysLeft} ng√†y)`;
                        if (vipData.benefits && vipData.benefits.miningBonus) {
                            vipInfo += `\nüéÅ Mining bonus: +${(vipData.benefits.miningBonus * 100).toFixed(0)}%`;
                        }
                    }
                    
                    return api.sendMessage(
                        `üìä TH·ªêNG K√ä MINING üìä\n` +
                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                        `üë§ Ng∆∞·ªùi ch∆°i: ${userName}\n` +
                        `‚≠ê Level: ${user.level}\n` +
                        `üî∏ XP: ${user.experience}/${requiredXP}\n` +
                        `‚ö° Mining Power: ${user.miningPower.toFixed(1)}x\n` +
                        `üíé T·ªïng ƒë√†o: ${user.totalMined} coins\n` +
                        `üî¢ S·ªë l·∫ßn ƒë√†o: ${user.miningCount}\n` +
                        `üí∞ S·ªë d∆∞ hi·ªán t·∫°i: ${getMiningBalance(senderID)} coins\n\n` +
                        `üè∞ Team: ${team ? team.name : "Ch∆∞a c√≥"}\n` +
                        `${team ? `üéÅ Team bonus: +${team.members.length * 5}%` : "üí° Tham gia team ƒë·ªÉ c√≥ bonus!"}\n\n` +
                        `üëë VIP: ${vipInfo}\n\n` +
                        `ü§ñ Auto mining: ${user.autoMining.active ? "üü¢ ƒêang ho·∫°t ƒë·ªông" : "üî¥ Kh√¥ng ho·∫°t ƒë·ªông"}`,
                        threadID, messageID
                    );
                    break;
                }

                case "shop":
                case "c·ª≠a_h√†ng": {
                    return api.sendMessage(
                        "üõí MINING SHOP üõí\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "‚öíÔ∏è THI·∫æT B·ªä MINING:\n" +
                        "‚Ä¢ Pickaxe ƒê·ªìng: 2,000 coins (+0.2x power)\n" +
                        "‚Ä¢ Pickaxe B·∫°c: 8,000 coins (+0.5x power)\n" +
                        "‚Ä¢ Pickaxe V√†ng: 25,000 coins (+1.0x power)\n\n" +
                        "‚ö° BOOST ITEMS:\n" +
                        "‚Ä¢ Speed Boost 1h: 1,000 coins (+50% speed)\n" +
                        "‚Ä¢ Speed Boost 24h: 15,000 coins (+50% speed)\n" +
                        "‚Ä¢ Double Earnings 1h: 2,000 coins (+100% coins)\n\n" +
                        "üëë VIP GOLD PACKAGE:\n" +
                        "‚Ä¢ VIP Gold: 49,000 VND/th√°ng\n" +
                        "‚Ä¢ +80% mining bonus\n" +
                        "‚Ä¢ +100% gi·ªõi h·∫°n r√∫t ti·ªÅn\n" +
                        "‚Ä¢ 50 l∆∞·ª£t ƒë√†o/ng√†y (thay v√¨ 10)\n" +
                        "‚Ä¢ Gi·∫£m ph√≠ auto mining 5%\n" +
                        "‚Ä¢ Xem chi ti·∫øt: .vip\n\n" +
                        "üí° VIP Gold 49k - ƒê·∫ßu t∆∞ hi·ªáu qu·∫£ nh·∫•t!",
                        threadID, messageID
                    );
                    break;
                }

                case "leaderboard":
                case "b·∫£ng_x·∫øp_h·∫°ng": {
                    const allUsers = loadMiningData();
                    const sortedUsers = Object.entries(allUsers)
                        .sort(([,a], [,b]) => b.totalMined - a.totalMined)
                        .slice(0, 10);
                    
                    let leaderboard = "üèÜ B·∫¢NG X·∫æP H·∫†NG MINING üèÜ\n";
                    leaderboard += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                    
                    for (let i = 0; i < sortedUsers.length; i++) {
                        const [userId, userData] = sortedUsers[i];
                        const userName = await getName(userId);
                        const medal = i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : `${i + 1}.`;
                        
                        leaderboard += `${medal} ${userName}\n`;
                        leaderboard += `   üíé ${userData.totalMined} coins | ‚≠ê Lv.${userData.level}\n\n`;
                    }
                    
                    // Find user's rank
                    const userRank = Object.entries(allUsers)
                        .sort(([,a], [,b]) => b.totalMined - a.totalMined)
                        .findIndex(([id]) => id === senderID) + 1;
                    
                    leaderboard += `üìç H·∫°ng c·ªßa b·∫°n: #${userRank}`;
                    
                    return api.sendMessage(leaderboard, threadID, messageID);
                    break;
                }

                case "quests":
                case "nhi·ªám_v·ª•": {
                    const today = new Date().toDateString();
                    const todayQuests = user.dailyQuests?.[today] || {
                        mineCount: 0,
                        joinedTeam: false,
                        usedAutoMining: false,
                        completed: []
                    };
                    
                    return api.sendMessage(
                        "üéØ NHI·ªÜM V·ª§ H√ÄNG NG√ÄY üéØ\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üìÖ Ng√†y: ${new Date().toLocaleDateString()}\n\n` +
                        `${todayQuests.completed.includes('MINE_10_TIMES') ? '‚úÖ' : '‚è≥'} ƒê√†o 10 l·∫ßn (${Math.min(todayQuests.mineCount, 10)}/10) - ${MINING_CONFIG.DAILY_QUESTS.MINE_10_TIMES.reward} coins\n` +
                        `${todayQuests.completed.includes('MINE_20_TIMES') ? '‚úÖ' : '‚è≥'} ƒê√†o 20 l·∫ßn (${Math.min(todayQuests.mineCount, 20)}/20) - ${MINING_CONFIG.DAILY_QUESTS.MINE_20_TIMES.reward} coins\n` +
                        `${todayQuests.completed.includes('JOIN_TEAM') ? '‚úÖ' : '‚è≥'} Tham gia team - ${MINING_CONFIG.DAILY_QUESTS.JOIN_TEAM.reward} coins\n` +
                        `${todayQuests.completed.includes('USE_AUTO_MINING') ? '‚úÖ' : '‚è≥'} S·ª≠ d·ª•ng auto mining - ${MINING_CONFIG.DAILY_QUESTS.USE_AUTO_MINING.reward} coins\n\n` +
                        `üí∞ ƒê√£ ho√†n th√†nh: ${todayQuests.completed.length}/4 nhi·ªám v·ª•\n` +
                        `üîÑ Reset v√†o 00:00 h√†ng ng√†y\n\n` +
                        "üí° Ho√†n th√†nh nhi·ªám v·ª• ƒë·ªÉ nh·∫≠n th∆∞·ªüng coins!",
                        threadID, messageID
                    );
                    break;
                }

                case "bank":
                case "linkbank":
                case "li√™n_k·∫øt_ng√¢n_h√†ng": {
                    const subAction = target[1]?.toLowerCase();
                    
                    if (subAction === "link") {
                        // Ki·ªÉm tra xem ƒë√£ li√™n k·∫øt ch∆∞a
                        if (user.bankAccount && user.bankAccount.linked) {
                            return api.sendMessage(
                                "üè¶ TH√îNG TIN NG√ÇN H√ÄNG HI·ªÜN T·∫†I üè¶\n" +
                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                `üèß Ng√¢n h√†ng: ${user.bankAccount.bankName}\n` +
                                `üí≥ S·ªë t√†i kho·∫£n: ${user.bankAccount.accountNumber.replace(/(.{4})/g, '$1 ')}\n` +
                                `üë§ Ch·ªß t√†i kho·∫£n: ${user.bankAccount.accountName}\n` +
                                `üìÖ Li√™n k·∫øt l√∫c: ${new Date(user.bankAccount.linkedAt).toLocaleString()}\n\n` +
                                "‚ö†Ô∏è C·∫¢NH B√ÅO NGHI√äM TR·ªåNG\n" +
                                "‚Ä¢ T√†i kho·∫£n ng√¢n h√†ng ƒë√£ ƒë∆∞·ª£c li√™n k·∫øt vƒ©nh vi·ªÖn\n" +
                                "‚Ä¢ KH√îNG TH·ªÇ thay ƒë·ªïi ho·∫∑c h·ªßy li√™n k·∫øt\n" +
                                "‚Ä¢ ƒê√¢y l√† bi·ªán ph√°p b·∫£o m·∫≠t tuy·ªát ƒë·ªëi\n\n" +
                                "‚úÖ Tr·∫°ng th√°i: ƒê√£ x√°c th·ª±c v√† b·∫£o m·∫≠t",
                                threadID, messageID
                            );
                        }
                        
                        const bankName = target[2];
                        const accountNumber = target[3];
                        const accountName = target.slice(4).join(" ");
                        
                        if (!bankName || !accountNumber || !accountName) {
                            return api.sendMessage(
                                "üè¶ LI√äN K·∫æT NG√ÇN H√ÄNG üè¶\n" +
                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                "üìù C√ÅCH S·ª¨ D·ª§NG:\n" +
                                ".coin bank link [T√™n ng√¢n h√†ng] [S·ªë t√†i kho·∫£n] [T√™n ch·ªß TK]\n\n" +
                                "üìã V√ç D·ª§:\n" +
                                ".coin bank link Vietcombank 1234567890 NGUYEN VAN A\n" +
                                ".coin bank link Techcombank 9876543210 TRAN THI B\n" +
                                ".coin bank link BIDV 5555666677 LE VAN C\n\n" +
                                "üèß NG√ÇN H√ÄNG H·ªñ TR·ª¢:\n" +
                                "‚Ä¢ Vietcombank, Techcombank, BIDV\n" +
                                "‚Ä¢ VietinBank, Agribank, Sacombank\n" +
                                "‚Ä¢ MBBank, VPBank, TPBank, ACB\n\n" +
                                "‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG:\n" +
                                "‚Ä¢ Ch·ªâ ƒë∆∞·ª£c li√™n k·∫øt 1 l·∫ßn duy nh·∫•t\n" +
                                "‚Ä¢ Kh√¥ng th·ªÉ s·ª≠a ƒë·ªïi sau khi li√™n k·∫øt\n" +
                                "‚Ä¢ Nh·∫≠p ch√≠nh x√°c th√¥ng tin ng√¢n h√†ng\n" +
                                "‚Ä¢ T√™n ch·ªß TK ph·∫£i vi·∫øt HOA, kh√¥ng d·∫•u\n\n" +
                                "üîí B·∫£o m·∫≠t tuy·ªát ƒë·ªëi - Thao t√°c kh√¥ng th·ªÉ ho√†n t√°c!",
                                threadID, messageID
                            );
                        }
                        
                        // Validate account number (ch·ªâ s·ªë, 6-20 k√Ω t·ª±)
                        if (!/^\d{6,20}$/.test(accountNumber)) {
                            return api.sendMessage(
                                "‚ùå S·ªë t√†i kho·∫£n kh√¥ng h·ª£p l·ªá!\n\n" +
                                "üìã Y√äU C·∫¶U:\n" +
                                "‚Ä¢ Ch·ªâ ch·ª©a s·ªë (0-9)\n" +
                                "‚Ä¢ ƒê·ªô d√†i t·ª´ 6-20 k√Ω t·ª±\n" +
                                "‚Ä¢ Kh√¥ng c√≥ kho·∫£ng tr·∫Øng ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát\n\n" +
                                "üí° Ki·ªÉm tra l·∫°i s·ªë t√†i kho·∫£n v√† th·ª≠ l·∫°i!",
                                threadID, messageID
                            );
                        }
                        
                        // Validate account name (ch·ªâ ch·ªØ c√°i v√† kho·∫£ng tr·∫Øng, vi·∫øt hoa)
                        if (!/^[A-Z\s]+$/.test(accountName)) {
                            return api.sendMessage(
                                "‚ùå T√™n ch·ªß t√†i kho·∫£n kh√¥ng h·ª£p l·ªá!\n\n" +
                                "üìã Y√äU C·∫¶U:\n" +
                                "‚Ä¢ Ch·ªâ ch·ª©a ch·ªØ c√°i ti·∫øng Anh\n" +
                                "‚Ä¢ Vi·∫øt HOA t·∫•t c·∫£\n" +
                                "‚Ä¢ Kh√¥ng d·∫•u, kh√¥ng s·ªë, kh√¥ng k√Ω t·ª± ƒë·∫∑c bi·ªát\n\n" +
                                "‚úÖ V√ç D·ª§ ƒê√öNG:\n" +
                                "‚Ä¢ NGUYEN VAN A\n" +
                                "‚Ä¢ TRAN THI B\n" +
                                "‚Ä¢ LE MINH C\n\n" +
                                "üí° S·ª≠a l·∫°i t√™n theo ƒë·ªãnh d·∫°ng tr√™n!",
                                threadID, messageID
                            );
                        }
                        
                        // Danh s√°ch ng√¢n h√†ng ƒë∆∞·ª£c h·ªó tr·ª£
                        const supportedBanks = [
                            'vietcombank', 'techcombank', 'bidv', 'vietinbank', 
                            'agribank', 'sacombank', 'mbbank', 'vpbank', 
                            'tpbank', 'acb', 'hdbank', 'shb', 'eximbank',
                            'oceanbank', 'namabank', 'pgbank', 'kienlongbank'
                        ];
                        
                        if (!supportedBanks.includes(bankName.toLowerCase())) {
                            return api.sendMessage(
                                "‚ùå Ng√¢n h√†ng kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£!\n\n" +
                                "üèß NG√ÇN H√ÄNG H·ªñ TR·ª¢:\n" +
                                "‚Ä¢ Vietcombank, Techcombank, BIDV\n" +
                                "‚Ä¢ VietinBank, Agribank, Sacombank\n" +
                                "‚Ä¢ MBBank, VPBank, TPBank, ACB\n" +
                                "‚Ä¢ HDBank, SHB, Eximbank\n" +
                                "‚Ä¢ OceanBank, NamABank, PGBank\n\n" +
                                "üí° Ch·ªçn m·ªôt trong c√°c ng√¢n h√†ng tr√™n!",
                                threadID, messageID
                            );
                        }
                        
                        // L∆∞u th√¥ng tin t·∫°m th·ªùi v√† ƒë·∫∑t th·ªùi gian h·∫øt h·∫°n
                        const data = loadMiningData();
                        data[senderID].bankAccount = {
                            bankName: bankName.toUpperCase(),
                            accountNumber: accountNumber,
                            accountName: accountName,
                            linked: false,
                            tempCreatedAt: Date.now(),
                            expiresAt: Date.now() + (60 * 1000) // H·∫øt h·∫°n sau 60 gi√¢y
                        };
                        saveMiningData(data);
                        
                        // X√°c nh·∫≠n li√™n k·∫øt v·ªõi c·∫£nh b√°o nghi√™m tr·ªçng
                        return api.sendMessage(
                            "‚ö†Ô∏è X√ÅC NH·∫¨N LI√äN K·∫æT NG√ÇN H√ÄNG ‚ö†Ô∏è\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üìã TH√îNG TIN LI√äN K·∫æT:\n" +
                            `üèß Ng√¢n h√†ng: ${bankName.toUpperCase()}\n` +
                            `üí≥ S·ªë t√†i kho·∫£n: ${accountNumber}\n` +
                            `üë§ Ch·ªß t√†i kho·∫£n: ${accountName}\n\n` +
                            "üö® C·∫¢NH B√ÅO NGHI√äM TR·ªåNG:\n" +
                            "‚Ä¢ ƒê√¢y l√† thao t√°c KH√îNG TH·ªÇ HO√ÄN T√ÅC\n" +
                            "‚Ä¢ Sau khi x√°c nh·∫≠n, KH√îNG TH·ªÇ s·ª≠a ƒë·ªïi\n" +
                            "‚Ä¢ Th√¥ng tin sai s·∫Ω g√¢y m·∫•t ti·ªÅn khi r√∫t\n" +
                            "‚Ä¢ Ki·ªÉm tra K·ª∏ L∆Ø·ª†NG tr∆∞·ªõc khi x√°c nh·∫≠n\n\n" +
                            "‚úÖ G√µ: .coin bank confirm - ƒë·ªÉ x√°c nh·∫≠n\n" +
                            "‚ùå G√µ: .coin bank cancel - ƒë·ªÉ h·ªßy b·ªè\n\n" +
                            "‚è∞ L·ªánh x√°c nh·∫≠n c√≥ hi·ªáu l·ª±c trong 60 gi√¢y!\n" +
                            `‚è≥ H·∫øt h·∫°n l√∫c: ${new Date(Date.now() + 60000).toLocaleTimeString()}`,
                            threadID, messageID
                        );
                        
                    } else if (subAction === "confirm") {
                        // Ki·ªÉm tra xem c√≥ th√¥ng tin t·∫°m th·ªùi kh√¥ng v√† c√≤n hi·ªáu l·ª±c kh√¥ng
                        if (!user.bankAccount || user.bankAccount.linked) {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng c√≥ th√¥ng tin li√™n k·∫øt n√†o ƒëang ch·ªù x√°c nh·∫≠n!\n\n" +
                                "üí° S·ª≠ d·ª•ng: .mining bank link [th√¥ng tin] ƒë·ªÉ b·∫Øt ƒë·∫ßu li√™n k·∫øt",
                                threadID, messageID
                            );
                        }
                        
                        // Ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n
                        if (Date.now() > user.bankAccount.expiresAt) {
                            // X√≥a th√¥ng tin ƒë√£ h·∫øt h·∫°n
                            const data = loadMiningData();
                            delete data[senderID].bankAccount;
                            saveMiningData(data);
                            
                            return api.sendMessage(
                                "‚è∞ Th√¥ng tin li√™n k·∫øt ƒë√£ h·∫øt h·∫°n!\n\n" +
                                "‚ùå Phi√™n x√°c nh·∫≠n ƒë√£ qu√° 60 gi√¢y\n" +
                                "üí° Vui l√≤ng t·∫°o l·∫°i li√™n k·∫øt b·∫±ng:\n" +
                                ".coin bank link [th√¥ng tin ng√¢n h√†ng]",
                                threadID, messageID
                            );
                        }
                        
                        // L∆∞u th√¥ng tin ng√¢n h√†ng vƒ©nh vi·ªÖn
                        const data = loadMiningData();
                        data[senderID].bankAccount = {
                            bankName: user.bankAccount.bankName,
                            accountNumber: user.bankAccount.accountNumber,
                            accountName: user.bankAccount.accountName,
                            linked: true,
                            linkedAt: Date.now(),
                            securityHash: `${senderID}_${Date.now()}_${Math.random()}`.toString().hashCode ? `${senderID}_${Date.now()}_${Math.random()}`.toString().hashCode() : `${senderID}_${Date.now()}`
                        };
                        
                        saveMiningData(data);
                        
                        return api.sendMessage(
                            "‚úÖ LI√äN K·∫æT NG√ÇN H√ÄNG TH√ÄNH C√îNG! ‚úÖ\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üéâ Ch√∫c m·ª´ng! T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c li√™n k·∫øt th√†nh c√¥ng\n\n" +
                            "üìã TH√îNG TIN ƒê√É L∆ØU:\n" +
                            `üèß Ng√¢n h√†ng: ${data[senderID].bankAccount.bankName}\n` +
                            `üí≥ S·ªë t√†i kho·∫£n: ${data[senderID].bankAccount.accountNumber}\n` +
                            `üë§ Ch·ªß t√†i kho·∫£n: ${data[senderID].bankAccount.accountName}\n` +
                            `üîí M√£ b·∫£o m·∫≠t: ${data[senderID].bankAccount.securityHash}\n\n` +
                            "‚ú® T√çNH NƒÇNG M·ªöI:\n" +
                            "‚Ä¢ R√∫t ti·ªÅn tr·ª±c ti·∫øp v·ªÅ ng√¢n h√†ng\n" +
                            "‚Ä¢ Giao d·ªãch t·ª± ƒë·ªông v√† an to√†n\n" +
                            "‚Ä¢ Kh√¥ng c·∫ßn nh·∫≠p l·∫°i th√¥ng tin\n\n" +
                            "üîê B·∫¢O M·∫¨T TUY·ªÜT ƒê·ªêI:\n" +
                            "‚Ä¢ Th√¥ng tin ƒë∆∞·ª£c m√£ h√≥a\n" +
                            "‚Ä¢ Kh√¥ng th·ªÉ thay ƒë·ªïi\n" +
                            "‚Ä¢ Ch·ªâ b·∫°n m·ªõi c√≥ th·ªÉ r√∫t ti·ªÅn\n\n" +
                            "üéØ S·ª≠ d·ª•ng: .coin r√∫t [s·ªë ti·ªÅn] ƒë·ªÉ r√∫t ti·ªÅn!",
                            threadID, messageID
                        );
                        
                    } else if (subAction === "cancel") {
                        const data = loadMiningData();
                        if (data[senderID].bankAccount && !data[senderID].bankAccount.linked) {
                            delete data[senderID].bankAccount;
                            saveMiningData(data);
                            
                            return api.sendMessage(
                                "‚ùå ƒê√£ h·ªßy b·ªè li√™n k·∫øt ng√¢n h√†ng!\n\n" +
                                "üí° B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i b·∫•t c·ª© l√∫c n√†o b·∫±ng:\n" +
                                ".coin bank link [th√¥ng tin ng√¢n h√†ng]",
                                threadID, messageID
                            );
                        } else {
                            return api.sendMessage(
                                "‚ùå Kh√¥ng c√≥ th√¥ng tin li√™n k·∫øt n√†o ƒë·ªÉ h·ªßy!",
                                threadID, messageID
                            );
                        }
                        
                    } else if (subAction === "info") {
                        if (!user.bankAccount || !user.bankAccount.linked) {
                            return api.sendMessage(
                                "‚ùå B·∫°n ch∆∞a li√™n k·∫øt ng√¢n h√†ng!\n\n" +
                                "üí° S·ª≠ d·ª•ng: .coin bank link [th√¥ng tin] ƒë·ªÉ li√™n k·∫øt",
                                threadID, messageID
                            );
                        }
                        
                        return api.sendMessage(
                            "üè¶ TH√îNG TIN NG√ÇN H√ÄNG üè¶\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            `üèß Ng√¢n h√†ng: ${user.bankAccount.bankName}\n` +
                            `üí≥ S·ªë t√†i kho·∫£n: ${user.bankAccount.accountNumber.replace(/(.{4})/g, '$1 ')}\n` +
                            `üë§ Ch·ªß t√†i kho·∫£n: ${user.bankAccount.accountName}\n` +
                            `üìÖ Li√™n k·∫øt l√∫c: ${new Date(user.bankAccount.linkedAt).toLocaleString()}\n` +
                            `üîí Tr·∫°ng th√°i: ƒê√£ x√°c th·ª±c\n\n` +
                            "‚úÖ T√çNH NƒÇNG:\n" +
                            "‚Ä¢ R√∫t ti·ªÅn t·ª± ƒë·ªông v·ªÅ t√†i kho·∫£n\n" +
                            "‚Ä¢ B·∫£o m·∫≠t tuy·ªát ƒë·ªëi\n" +
                            "‚Ä¢ Giao d·ªãch nhanh ch√≥ng\n\n" +
                            "üí° S·ª≠ d·ª•ng: .coin r√∫t [s·ªë ti·ªÅn]",
                            threadID, messageID
                        );
                        
                    } else {
                        return api.sendMessage(
                            "üè¶ H·ªÜ TH·ªêNG NG√ÇN H√ÄNG üè¶\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üìù L·ªÜNH:\n" +
                            "‚Ä¢ .coin bank link - Li√™n k·∫øt ng√¢n h√†ng\n" +
                            "‚Ä¢ .coin bank info - Xem th√¥ng tin\n" +
                            "‚Ä¢ .coin bank confirm - X√°c nh·∫≠n li√™n k·∫øt\n" +
                            "‚Ä¢ .coin bank cancel - H·ªßy li√™n k·∫øt\n\n" +
                            "üéØ M·ª§C ƒê√çCH:\n" +
                            "‚Ä¢ R√∫t ti·ªÅn tr·ª±c ti·∫øp v·ªÅ ng√¢n h√†ng\n" +
                            "‚Ä¢ T·ª± ƒë·ªông h√≥a giao d·ªãch\n" +
                            "‚Ä¢ TƒÉng t√≠nh b·∫£o m·∫≠t\n\n" +
                            "‚ö†Ô∏è L∆ØU √ù:\n" +
                            "‚Ä¢ Ch·ªâ li√™n k·∫øt ƒë∆∞·ª£c 1 l·∫ßn duy nh·∫•t\n" +
                            "‚Ä¢ Kh√¥ng th·ªÉ s·ª≠a ƒë·ªïi sau khi x√°c nh·∫≠n\n" +
                            "‚Ä¢ Nh·∫≠p th√¥ng tin ch√≠nh x√°c\n" +
                            "‚Ä¢ X√°c nh·∫≠n trong v√≤ng 60 gi√¢y\n\n" +
                            "üîí B·∫£o m·∫≠t cao - Thu·∫≠n ti·ªán t·ªëi ƒëa!",
                            threadID, messageID
                        );
                    }
                    break;
                }
                
                case "withdraw":
                case "r√∫t":
                case "rut": {
                    const amount = parseInt(target[1]);
                    
                    if (!amount || amount <= 0) {
                        return api.sendMessage(
                            "üí∞ R√öT TI·ªÄN MINING üí∞\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "üìù C√ÅCH S·ª¨ D·ª§NG:\n" +
                            ".coin withdraw [s·ªë ti·ªÅn]\n" +
                            ".coin r√∫t [s·ªë ti·ªÅn]\n\n" +
                            "üìã V√ç D·ª§:\n" +
                            ".coin withdraw 50000\n" +
                            ".coin r√∫t 100000\n\n" +
                            "‚ö†Ô∏è Y√äU C·∫¶U:\n" +
                            `‚Ä¢ S·ªë ti·ªÅn t·ªëi thi·ªÉu: ${MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT.toLocaleString()} coins\n` +
                            `‚Ä¢ Ph√≠ r√∫t ti·ªÅn: ${(MINING_CONFIG.FEES.WITHDRAWAL_FEE * 100)}%\n` +
                            `‚Ä¢ Gi·ªõi h·∫°n/ng√†y: ${MINING_CONFIG.WITHDRAWAL.DAILY_LIMIT.toLocaleString()} coins\n` +
                            `‚Ä¢ VIP Gold: x2 gi·ªõi h·∫°n\n\n` +
                            "üè¶ L∆ØU √ù:\n" +
                            "‚Ä¢ C·∫ßn li√™n k·∫øt ng√¢n h√†ng tr∆∞·ªõc: .mining bank\n" +
                            "‚Ä¢ Ti·ªÅn s·∫Ω ƒë∆∞·ª£c chuy·ªÉn trong 24h\n" +
                            "‚Ä¢ Ki·ªÉm tra th√¥ng tin ng√¢n h√†ng c·∫©n th·∫≠n\n\n" +
                            `üíé S·ªë d∆∞ hi·ªán t·∫°i: ${getMiningBalance(senderID).toLocaleString()} coins`,
                            threadID, messageID
                        );
                    }
                    
                    // Ki·ªÉm tra ƒë√£ li√™n k·∫øt ng√¢n h√†ng ch∆∞a
                    if (!user.bankAccount || !user.bankAccount.linked) {
                        return api.sendMessage(
                            "‚ùå CH∆ØA LI√äN K·∫æT NG√ÇN H√ÄNG!\n\n" +
                            "üè¶ B·∫°n c·∫ßn li√™n k·∫øt ng√¢n h√†ng tr∆∞·ªõc khi r√∫t ti·ªÅn\n\n" +
                            "üìù H∆Ø·ªöNG D·∫™N:\n" +
                            "1. .coin bank link [ng√¢n h√†ng] [s·ªë TK] [t√™n ch·ªß TK]\n" +
                            "2. .coin bank confirm\n" +
                            "3. .coin withdraw [s·ªë ti·ªÅn]\n\n" +
                            "üí° V√≠ d·ª• li√™n k·∫øt:\n" +
                            ".coin bank link Vietcombank 1234567890 NGUYEN VAN A",
                            threadID, messageID
                        );
                    }
                    
                    // X·ª≠ l√Ω r√∫t ti·ªÅn
                    const withdrawResult = processWithdrawal(senderID, amount);
                    
                    if (!withdrawResult.success) {
                        return api.sendMessage(withdrawResult.message, threadID, messageID);
                    }
                    
                    // T·∫°o ƒë∆°n r√∫t ti·ªÅn
                    const withdrawalOrder = {
                        orderId: `WD${Date.now()}${Math.random().toString(36).substr(2, 6).toUpperCase()}`,
                        userId: senderID,
                        userName: userName,
                        amount: amount,
                        actualAmount: withdrawResult.amount,
                        fee: withdrawResult.fee,
                        bankInfo: {
                            bankName: user.bankAccount.bankName,
                            accountNumber: user.bankAccount.accountNumber,
                            accountName: user.bankAccount.accountName
                        },
                        status: 'pending',
                        createdAt: Date.now(),
                        note: `R√∫t ${amount.toLocaleString()} coins (ph√≠ ${withdrawResult.fee.toLocaleString()})`
                    };
                    
                    // L∆∞u ƒë∆°n r√∫t ti·ªÅn
                    const withdrawalFile = path.join(__dirname, './json/withdrawal_orders.json');
                    let withdrawalData = {};
                    
                    try {
                        if (fs.existsSync(withdrawalFile)) {
                            withdrawalData = JSON.parse(fs.readFileSync(withdrawalFile, 'utf8'));
                        }
                    } catch (error) {
                        withdrawalData = {};
                    }
                    
                    withdrawalData[withdrawalOrder.orderId] = withdrawalOrder;
                    fs.writeFileSync(withdrawalFile, JSON.stringify(withdrawalData, null, 2));
                    
                    return api.sendMessage(
                        "‚úÖ T·∫†O ƒê∆°N R√öT TI·ªÄN TH√ÄNH C√îNG!\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üÜî M√£ ƒë∆°n: ${withdrawalOrder.orderId}\n` +
                        `üí∞ S·ªë ti·ªÅn r√∫t: ${amount.toLocaleString()} coins\n` +
                        `üí∏ Ph√≠ r√∫t: ${withdrawResult.fee.toLocaleString()} coins (${(MINING_CONFIG.FEES.WITHDRAWAL_FEE * 100)}%)\n` +
                        `üíé Th·ª±c nh·∫≠n: ${withdrawResult.amount.toLocaleString()} coins\n\n` +
                        "üè¶ TH√îNG TIN NG√ÇN H√ÄNG:\n" +
                        `üèß Ng√¢n h√†ng: ${user.bankAccount.bankName}\n` +
                        `üí≥ S·ªë TK: ${user.bankAccount.accountNumber}\n` +
                        `üë§ Ch·ªß TK: ${user.bankAccount.accountName}\n\n` +
                        "‚è∞ TH·ªúI GIAN X·ª¨ L√ù:\n" +
                        "‚Ä¢ ƒê∆°n ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn admin\n" +
                        "‚Ä¢ Th·ªùi gian x·ª≠ l√Ω: 12-24 gi·ªù\n" +
                        "‚Ä¢ B·∫°n s·∫Ω ƒë∆∞·ª£c th√¥ng b√°o khi ho√†n th√†nh\n\n" +
                        `üíµ S·ªë d∆∞ c√≤n l·∫°i: ${withdrawResult.remaining.toLocaleString()} coins\n\n` +
                        "üìû H·ªñ TR·ª¢:\n" +
                        "‚Ä¢ Li√™n h·ªá admin n·∫øu qu√° 24h ch∆∞a nh·∫≠n ƒë∆∞·ª£c ti·ªÅn\n" +
                        "‚Ä¢ G·ª≠i k√®m m√£ ƒë∆°n ƒë·ªÉ tra c·ª©u nhanh",
                        threadID, messageID
                    );
                    break;
                }

                // L·ªÜNH ·∫®N CHO ADMIN - Ch·ªâ admin c√≥ th·ªÉ s·ª≠ d·ª•ng
                case "admin_withdrawal_list": 
                case "awl": {
                    // Ki·ªÉm tra quy·ªÅn admin - ch·ªâ cho ph√©p m·ªôt s·ªë userID c·ª• th·ªÉ
                    const adminIds = ['61573427362389', '61573427362389']; // Thay b·∫±ng ID admin th·ª±c t·∫ø
                    
                    if (!adminIds.includes(senderID)) {
                        return api.sendMessage("‚ùå L·ªánh kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }
                    
                    const withdrawalFile = path.join(__dirname, './json/withdrawal_orders.json');
                    let withdrawalData = {};
                    
                    try {
                        if (fs.existsSync(withdrawalFile)) {
                            withdrawalData = JSON.parse(fs.readFileSync(withdrawalFile, 'utf8'));
                        }
                    } catch (error) {
                        return api.sendMessage("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu ƒë∆°n r√∫t ti·ªÅn!", threadID, messageID);
                    }
                    
                    const pendingOrders = Object.values(withdrawalData).filter(order => order.status === 'pending');
                    
                    if (pendingOrders.length === 0) {
                        return api.sendMessage(
                            "üìã DANH S√ÅCH ƒê∆†N R√öT TI·ªÄN\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "‚úÖ Kh√¥ng c√≥ ƒë∆°n r√∫t ti·ªÅn n√†o ƒëang ch·ªù x·ª≠ l√Ω\n\n" +
                            "üìä L·ªÜNH ADMIN:\n" +
                            "‚Ä¢ .mining awl - Xem danh s√°ch ƒë∆°n\n" +
                            "‚Ä¢ .mining approve [m√£ ƒë∆°n] - Duy·ªát ƒë∆°n\n" +
                            "‚Ä¢ .mining reject [m√£ ƒë∆°n] [l√Ω do] - T·ª´ ch·ªëi ƒë∆°n",
                            threadID, messageID
                        );
                    }
                    
                    let message = "üìã DANH S√ÅCH ƒê∆†N R√öT TI·ªÄN\n";
                    message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                    message += `üîÑ ƒêang ch·ªù x·ª≠ l√Ω: ${pendingOrders.length} ƒë∆°n\n\n`;
                    
                    for (let i = 0; i < Math.min(pendingOrders.length, 10); i++) {
                        const order = pendingOrders[i];
                        const timeAgo = Math.floor((Date.now() - order.createdAt) / (60 * 1000));
                        
                        message += `${i + 1}. üÜî ${order.orderId}\n`;
                        message += `   üë§ ${order.userName} (${order.userId})\n`;
                        message += `   üí∞ ${order.amount.toLocaleString()} ‚Üí ${order.actualAmount.toLocaleString()} coins\n`;
                        message += `   üè¶ ${order.bankInfo.bankName} - ${order.bankInfo.accountNumber}\n`;
                        message += `   üë§ ${order.bankInfo.accountName}\n`;
                        message += `   ‚è∞ ${timeAgo} ph√∫t tr∆∞·ªõc\n\n`;
                    }
                    
                    if (pendingOrders.length > 10) {
                        message += `... v√† ${pendingOrders.length - 10} ƒë∆°n kh√°c\n\n`;
                    }
                    
                    message += "üìä L·ªÜNH ADMIN:\n";
                    message += "‚Ä¢ .mining approve [m√£ ƒë∆°n] - Duy·ªát ƒë∆°n\n";
                    message += "‚Ä¢ .mining reject [m√£ ƒë∆°n] [l√Ω do] - T·ª´ ch·ªëi ƒë∆°n\n";
                    message += "‚Ä¢ .mining awl - Refresh danh s√°ch";
                    
                    return api.sendMessage(message, threadID, messageID);
                    break;
                }

                case "approve": {
                    const adminIds = ['100004870529456', '100066749404031']; // Thay b·∫±ng ID admin th·ª±c t·∫ø
                    
                    if (!adminIds.includes(senderID)) {
                        return api.sendMessage("‚ùå L·ªánh kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }
                    
                    const orderId = target[1];
                    if (!orderId) {
                        return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p m√£ ƒë∆°n!\nV√≠ d·ª•: .mining approve WD1234567890ABC", threadID, messageID);
                    }
                    
                    const withdrawalFile = path.join(__dirname, './json/withdrawal_orders.json');
                    let withdrawalData = {};
                    
                    try {
                        withdrawalData = JSON.parse(fs.readFileSync(withdrawalFile, 'utf8'));
                    } catch (error) {
                        return api.sendMessage("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu ƒë∆°n r√∫t ti·ªÅn!", threadID, messageID);
                    }
                    
                    if (!withdrawalData[orderId]) {
                        return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n r√∫t ti·ªÅn v·ªõi m√£ n√†y!", threadID, messageID);
                    }
                    
                    const order = withdrawalData[orderId];
                    
                    if (order.status !== 'pending') {
                        return api.sendMessage(`‚ùå ƒê∆°n n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc ƒë√≥ (${order.status})!`, threadID, messageID);
                    }
                    
                    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n
                    order.status = 'approved';
                    order.approvedAt = Date.now();
                    order.approvedBy = senderID;
                    
                    fs.writeFileSync(withdrawalFile, JSON.stringify(withdrawalData, null, 2));
                    
                    // Th√¥ng b√°o cho user
                    api.sendMessage(
                        "‚úÖ ƒê∆†N R√öT TI·ªÄN ƒê√É ƒê∆Ø·ª¢C DUY·ªÜT!\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üÜî M√£ ƒë∆°n: ${orderId}\n` +
                        `üí∞ S·ªë ti·ªÅn: ${order.actualAmount.toLocaleString()} VND\n` +
                        `üè¶ Ng√¢n h√†ng: ${order.bankInfo.bankName}\n` +
                        `üí≥ S·ªë TK: ${order.bankInfo.accountNumber}\n` +
                        `üë§ Ch·ªß TK: ${order.bankInfo.accountName}\n\n` +
                        "üí° Ti·ªÅn s·∫Ω ƒë∆∞·ª£c chuy·ªÉn trong v√≤ng 1-2 gi·ªù t·ªõi\n" +
                        "üìû Li√™n h·ªá admin n·∫øu kh√¥ng nh·∫≠n ƒë∆∞·ª£c ti·ªÅn",
                        order.userId
                    );
                    
                    return api.sendMessage(
                        `‚úÖ ƒê√É DUY·ªÜT ƒê∆†N R√öT TI·ªÄN!\n\n` +
                        `üÜî M√£ ƒë∆°n: ${orderId}\n` +
                        `üë§ User: ${order.userName}\n` +
                        `üí∞ S·ªë ti·ªÅn: ${order.actualAmount.toLocaleString()} VND\n` +
                        `üè¶ ${order.bankInfo.bankName} - ${order.bankInfo.accountNumber}\n` +
                        `üë§ ${order.bankInfo.accountName}\n\n` +
                        `‚è∞ ƒê√£ th√¥ng b√°o cho user`,
                        threadID, messageID
                    );
                    break;
                }

                case "reject": {
                    const adminIds = ['100004870529456', '100066749404031']; // Thay b·∫±ng ID admin th·ª±c t·∫ø
                    
                    if (!adminIds.includes(senderID)) {
                        return api.sendMessage("‚ùå L·ªánh kh√¥ng t·ªìn t·∫°i!", threadID, messageID);
                    }
                    
                    const orderId = target[1];
                    const reason = target.slice(2).join(" ");
                    
                    if (!orderId || !reason) {
                        return api.sendMessage(
                            "‚ùå Thi·∫øu th√¥ng tin!\n\n" +
                            "üìù C√°ch s·ª≠ d·ª•ng:\n" +
                            ".mining reject [m√£ ƒë∆°n] [l√Ω do t·ª´ ch·ªëi]\n\n" +
                            "üí° V√≠ d·ª•:\n" +
                            ".mining reject WD1234567890ABC Th√¥ng tin ng√¢n h√†ng kh√¥ng ch√≠nh x√°c",
                            threadID, messageID
                        );
                    }
                    
                    const withdrawalFile = path.join(__dirname, './json/withdrawal_orders.json');
                    let withdrawalData = {};
                    
                    try {
                        withdrawalData = JSON.parse(fs.readFileSync(withdrawalFile, 'utf8'));
                    } catch (error) {
                        return api.sendMessage("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu ƒë∆°n r√∫t ti·ªÅn!", threadID, messageID);
                    }
                    
                    if (!withdrawalData[orderId]) {
                        return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n r√∫t ti·ªÅn v·ªõi m√£ n√†y!", threadID, messageID);
                    }
                    
                    const order = withdrawalData[orderId];
                    
                    if (order.status !== 'pending') {
                        return api.sendMessage(`‚ùå ƒê∆°n n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc ƒë√≥ (${order.status})!`, threadID, messageID);
                    }
                    
                    // Ho√†n l·∫°i ti·ªÅn cho user
                    updateMiningBalance(order.userId, order.amount);
                    
                    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n
                    order.status = 'rejected';
                    order.rejectedAt = Date.now();
                    order.rejectedBy = senderID;
                    order.rejectReason = reason;
                    
                    fs.writeFileSync(withdrawalFile, JSON.stringify(withdrawalData, null, 2));
                    
                    // Th√¥ng b√°o cho user
                    api.sendMessage(
                        "‚ùå ƒê∆†N R√öT TI·ªÄN B·ªä T·ª™ CH·ªêI!\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üÜî M√£ ƒë∆°n: ${orderId}\n` +
                        `üí∞ S·ªë ti·ªÅn: ${order.amount.toLocaleString()} coins\n\n` +
                        `üìù L√Ω do t·ª´ ch·ªëi: ${reason}\n\n` +
                        "üí° H∆Ø·ªöNG D·∫™N:\n" +
                        "‚Ä¢ S·ªë ti·ªÅn ƒë√£ ƒë∆∞·ª£c ho√†n l·∫°i v√†o t√†i kho·∫£n\n" +
                        "‚Ä¢ Ki·ªÉm tra l·∫°i th√¥ng tin ng√¢n h√†ng\n" +
                        "‚Ä¢ Li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£\n" +
                        "‚Ä¢ C√≥ th·ªÉ t·∫°o ƒë∆°n r√∫t ti·ªÅn m·ªõi sau khi kh·∫Øc ph·ª•c",
                        order.userId
                    );
                    
                    return api.sendMessage(
                        `‚ùå ƒê√É T·ª™ CH·ªêI ƒê∆†N R√öT TI·ªÄN!\n\n` +
                        `üÜî M√£ ƒë∆°n: ${orderId}\n` +
                        `üë§ User: ${order.userName}\n` +
                        `üí∞ ƒê√£ ho√†n: ${order.amount.toLocaleString()} coins\n` +
                        `üìù L√Ω do: ${reason}\n\n` +
                        `‚è∞ ƒê√£ th√¥ng b√°o cho user`,
                        threadID, messageID
                    );
                    break;
                }

                default: {
                    const accountAge = Date.now() - user.createdAt;
                    const daysOld = Math.floor(accountAge / (24 * 60 * 60 * 1000));
                    let newbieInfo = "";
                    
                    if (daysOld <= 10) {
                        newbieInfo = `\nüÜï NEWBIE BONUS (${10 - daysOld} ng√†y c√≤n l·∫°i):\nüî∏ x${MINING_CONFIG.NEWBIE_BONUS.FIRST_WEEK_MULTIPLIER} coins khi ƒë√†o!\nüî∏ Daily login: +${MINING_CONFIG.NEWBIE_BONUS.DAILY_LOGIN_BONUS} coins\n`;
                    }
                    
                    return api.sendMessage(
                        "‚õèÔ∏è MMO MINING GAME ‚õèÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "üéÆ L·ªÜNH C∆† B·∫¢N:\n" +
                        "‚Ä¢ .coin mine - ƒê√†o coin\n" +
                        "‚Ä¢ .coin r√∫t - R√∫t ti·ªÅn\n" +
                        "‚Ä¢ .coin stats - Xem th·ªëng k√™\n" +
                        "‚Ä¢ .coin help - H∆∞·ªõng d·∫´n chi ti·∫øt\n" +
                        "‚Ä¢ .coin quests - Nhi·ªám v·ª• h√†ng ng√†y\n" +
                        "‚Ä¢ .coin bank - Li√™n k·∫øt ng√¢n h√†ng\n" +
                        "‚Ä¢ .coin auto - Auto mining\n" +
                        "‚Ä¢ .coin team - H·ªá th·ªëng team\n" +
                        "‚Ä¢ .coin shop - C·ª≠a h√†ng\n" +
                        "‚Ä¢ .coin leaderboard - B·∫£ng x·∫øp h·∫°ng\n\n" +
                        "üéÅ H·ªÜ TH·ªêNG H·∫§P D·∫™N:\n" +
                        `üî∏ T·∫∑ng ngay: ${MINING_CONFIG.NEWBIE_BONUS.WELCOME_BONUS.toLocaleString()} coins\n` +
                        `üî∏ Mi·ªÖn ph√≠: ${MINING_CONFIG.DAILY_MINING.FREE_LIMIT} l∆∞·ª£t ƒë√†o/ng√†y\n` +
                        `üî∏ ƒê√†o th√™m: ${MINING_CONFIG.DAILY_MINING.EXTRA_COST} coins/l·∫ßn\n` +
                        `üî∏ Ph√≠ r√∫t ti·ªÅn: ${(MINING_CONFIG.FEES.WITHDRAWAL_FEE * 100)}%\n` +
                        `üî∏ R√∫t t·ªëi thi·ªÉu: ${MINING_CONFIG.WITHDRAWAL.MIN_AMOUNT.toLocaleString()} coins\n` +
                        `üî∏ Cooldown: ch·ªâ ${MINING_CONFIG.COOLDOWN/1000}s\n` +
                        newbieInfo +
                        "\nüëë VIP GOLD (49k/th√°ng):\n" +
                        `üéØ ${MINING_CONFIG.DAILY_MINING.VIP_LIMIT} l∆∞·ª£t ƒë√†o/ng√†y\n` +
                        "üéØ +80% mining bonus\n" +
                        "üéØ +100% gi·ªõi h·∫°n r√∫t ti·ªÅn\n" +
                        "üéØ Gi·∫£m ph√≠ auto mining\n\n" +
                        "üí∞ THU NH·∫¨P TH·ª∞C T·∫æ:\n" +
                        "üÜì Free: ~90 coins/ng√†y ‚Üí R√∫t sau 89 ng√†y\n" +
                        "üëë VIP: ~775 coins/ng√†y ‚Üí R√∫t sau 10 ng√†y\n\n" +
                        "‚≠ê H·ªá th·ªëng h·∫•p d·∫´n - ROI r√µ r√†ng!",
                        threadID, messageID
                    );
                }
            }
        } catch (error) {
            console.error('Mining error:', error);
            return api.sendMessage("‚ùå C√≥ l·ªói x·∫£y ra trong h·ªá th·ªëng mining!", threadID, messageID);
        }
    }
};
