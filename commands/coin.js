const fs = require('fs');
const path = require('path');
const { getBalance, updateBalance } = require('../utils/currencies');
const axios = require('axios');
const { createCanvas } = require('canvas');
const { Chart } = require('chart.js/auto');
const { registerables } = require('chart.js');

Chart.register(...registerables);

const MINING_DATA_FILE = path.join(__dirname, './json/mining_data.json');
const MARKET_DATA_FILE = path.join(__dirname, './json/market_data.json');

const CONFIG = {
    baseMiner: {
        power: 1,
        consumption: 0.8,
        durability: 100,
        maxDurability: 100,
        repairCost: 150000,
        miningEvents: {
            normal: ["‚õèÔ∏è ƒê√†o ƒë∆∞·ª£c m·∫°ch qu·∫∑ng th∆∞·ªùng!", "üíé T√¨m th·∫•y m·ªè nh·ªè!", "üî® Khai th√°c th√†nh c√¥ng!"],
            critical: ["üåü WOW! ƒê√†o tr√∫ng m·ªè l·ªõn!", "‚ö° SI√äU HI·∫æM! M·∫°ch qu·∫∑ng nguy√™n ch·∫•t!", "üéØ JACKPOT! Kho b√°u c·ªï ƒë·∫°i!"],
            fail: ["üí¢ M√°y ƒë√†o qu√° n√≥ng!", "üí® B·ª•i ƒë√° che khu·∫•t t·∫ßm nh√¨n!", "‚ö†Ô∏è ƒê·ªãa h√¨nh kh√¥ng ·ªïn ƒë·ªãnh!"]
        }
    },
    
    upgradeCosts: {
        power: [150000, 300000, 600000, 1200000, 2400000, 4800000, 9600000, 19200000, 38400000, 76800000],
        efficiency: [200000, 400000, 800000, 1600000, 3200000, 6400000, 12800000, 25600000, 51200000, 102400000],
        cooling: [250000, 500000, 1000000, 2000000, 4000000, 8000000, 16000000, 32000000, 64000000, 128000000]
    },

    miningSuccess: {
        base: 0.6,
        perPowerLevel: 0.02,
        perCoolingLevel: 0.015,
        criticalChance: 0.05,
        criticalMultiplier: 1.8
    },

    miningCooldown: 8 * 60 * 1000,
    
    market: {
        basePrice: 80,
        volatility: 0.25,
        updateInterval: 10 * 60 * 1000,
        maxPrice: 500,
        minPrice: 20,
        crashChance: 0.1
    },

    dailyQuests: {
        types: ['mine', 'upgrade', 'market'],
        rewards: {
            mine: 300,
            upgrade: 600,
            market: 450
        },
        maxDaily: 3
    }
};

function initializeData() {
    let miningData = {};
    let marketData = {
        price: CONFIG.market.basePrice,
        lastUpdate: Date.now(),
        history: []
    };

    if (fs.existsSync(MINING_DATA_FILE)) {
        miningData = JSON.parse(fs.readFileSync(MINING_DATA_FILE));
    }
    if (fs.existsSync(MARKET_DATA_FILE)) {
        marketData = JSON.parse(fs.readFileSync(MARKET_DATA_FILE));
    }

    return { miningData, marketData };
}

function saveData(miningData, marketData) {
    fs.writeFileSync(MINING_DATA_FILE, JSON.stringify(miningData, null, 2));
    fs.writeFileSync(MARKET_DATA_FILE, JSON.stringify(marketData, null, 2));
}

function initializePlayer(userId) {
    return {
        miner: { ...CONFIG.baseMiner },
        coins: 0,
        upgrades: {
            power: 0,
            efficiency: 0,
            cooling: 0
        },
        lastMining: 0,
        stats: {
            totalMined: 0,
            successfulMines: 0,
            failedMines: 0
        },
        quests: {
            daily: {
                type: null,
                progress: 0,
                target: 0,
                lastReset: 0
            }
        },
        settings: {
            autoSell: false
        }
    };
}

function updateMarketPrice(marketData) {
    const timePassed = Date.now() - marketData.lastUpdate;
    if (timePassed >= CONFIG.market.updateInterval) {
        let change = (Math.random() - 0.5) * 2 * CONFIG.market.volatility;
        
        if (Math.random() < CONFIG.market.crashChance) {
            change = -Math.random() * 0.5;
        }
        
        const newPrice = Math.max(
            CONFIG.market.minPrice,
            Math.min(
                CONFIG.market.maxPrice,
                marketData.price * (1 + change)
            )
        );
        
        marketData.history.push({
            price: marketData.price,
            timestamp: Date.now()
        });
        
        if (marketData.history.length > 48) {
            marketData.history.shift();
        }
        
        marketData.price = Math.round(newPrice);
        marketData.lastUpdate = Date.now();
    }
    return marketData;
}

function calculateMiningSuccess(player) {
    const base = CONFIG.miningSuccess.base;
    const powerBonus = player.upgrades.power * CONFIG.miningSuccess.perPowerLevel;
    const coolingBonus = player.upgrades.cooling * CONFIG.miningSuccess.perCoolingLevel;
    return Math.min(0.95, base + powerBonus + coolingBonus);
}

function calculateMiningReward(player, isCritical = false) {
    const basePower = CONFIG.baseMiner.power;
    const powerMultiplier = 1 + (player.upgrades.power * 0.15);
    const efficiencyMultiplier = 1 + (player.upgrades.efficiency * 0.1);
    
    let baseReward = Math.round(basePower * powerMultiplier * efficiencyMultiplier * 80);
    
    const luckFactor = 0.3 + Math.random() * 1.4;
    
    if (isCritical) {
        baseReward *= CONFIG.miningSuccess.criticalMultiplier;
    }
    
    const randomBonus = 1 + (Math.random() * 0.03);
    
    const finalReward = Math.round(baseReward * luckFactor * randomBonus);
    
    return Math.max(50, Math.min(2000, finalReward));
}

function checkAndUpdateQuests(player) {
    const now = Date.now();
    const daysPassed = Math.floor((now - player.quests.daily.lastReset) / (24 * 60 * 60 * 1000));
    
    if (daysPassed >= 1 || !player.quests.daily.type) {
        const questTypes = CONFIG.dailyQuests.types;
        const randomType = questTypes[Math.floor(Math.random() * questTypes.length)];
        player.quests.daily = {
            type: randomType,
            progress: 0,
            target: randomType === 'mine' ? 10 : 3,
            lastReset: now
        };
    }
    
    return player;
}

async function generatePriceChart(marketData, period = "24h") {
    try {
        let historyData = [...marketData.history];
        let dataPoints = 0;
        let timeLabel = "";
        
        switch(period) {
            case "1h": dataPoints = 4; timeLabel = "1 gi·ªù"; break;
            case "6h": dataPoints = 24; timeLabel = "6 gi·ªù"; break;
            case "12h": dataPoints = 48; timeLabel = "12 gi·ªù"; break;
            case "24h": default: dataPoints = historyData.length; timeLabel = "24 gi·ªù"; break;
        }
        
        const relevantHistory = historyData.slice(-dataPoints);
        if (relevantHistory.length < 2) {
            return { success: false, message: "Ch∆∞a ƒë·ªß d·ªØ li·ªáu l·ªãch s·ª≠ ƒë·ªÉ t·∫°o bi·ªÉu ƒë·ªì" };
        }
        
        relevantHistory.push({
            price: marketData.price,
            timestamp: Date.now()
        });

        const width = 1200;
        const height = 600;
        const canvas = createCanvas(width, height);
        const ctx = canvas.getContext('2d');

        const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
        bgGradient.addColorStop(0, '#0a1929');
        bgGradient.addColorStop(0.5, '#0d2137');
        bgGradient.addColorStop(1, '#0a1929');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < width; i += 50) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, height);
            ctx.stroke();
        }
        for (let i = 0; i < height; i += 50) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(width, i);
            ctx.stroke();
        }

        const timestamps = relevantHistory.map(item => {
            const date = new Date(item.timestamp);
            return date.toLocaleTimeString('vi-VN', {
                hour: '2-digit',
                minute: '2-digit'
            });
        });

        const prices = relevantHistory.map(item => item.price);
        const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;

        const ma20 = calculateMA(prices, 20);
        const ma50 = calculateMA(prices, 50);
        const volatility = calculateVolatility(prices);

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timestamps,
                datasets: [
                    {
                        label: 'Gi√° LCoin',
                        data: prices,
                        borderColor: priceChange >= 0 ? 'rgba(0, 255, 127, 1)' : 'rgba(255, 99, 132, 1)',
                        backgroundColor: function(context) {
                            const chart = context.chart;
                            const {ctx, chartArea} = chart;
                            if (!chartArea) return null;
                            
                            const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                            if (priceChange >= 0) {
                                gradient.addColorStop(0, 'rgba(0, 255, 127, 0.3)');
                                gradient.addColorStop(1, 'rgba(0, 255, 127, 0)');
                            } else {
                                gradient.addColorStop(0, 'rgba(255, 99, 132, 0.3)');
                                gradient.addColorStop(1, 'rgba(255, 99, 132, 0)');
                            }
                            return gradient;
                        },
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                    },
                    {
                        label: 'MA20',
                        data: ma20,
                        borderColor: 'rgba(255, 206, 86, 1)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    },
                    {
                        label: 'MA50',
                        data: ma50,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: false,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: [
                            'BI·ªÇU ƒê·ªí GI√Å LCOIN',
                            `${timeLabel} - Bi·∫øn ƒë·ªông: ${volatility.toFixed(2)}% - Thay ƒë·ªïi: ${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%`
                        ],
                        color: '#ffffff',
                        font: {
                            size: 16,
                            weight: 'bold',
                            family: 'Arial'
                        },
                        padding: 20
                    },
                    legend: {
                        display: true,
                        labels: {
                            color: '#ffffff',
                            font: {
                                family: 'Arial'
                            },
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: {
                            family: 'Arial'
                        },
                        bodyFont: {
                            family: 'Arial'
                        },
                        padding: 12,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toLocaleString()} $`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#ffffff',
                            maxRotation: 45,
                            font: {
                                family: 'Arial'
                            }
                        }
                    },
                    y: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#ffffff',
                            callback: function(value) {
                                return value.toLocaleString() + ' $';
                            },
                            font: {
                                family: 'Arial'
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                animations: {
                    tension: {
                        duration: 1000,
                        easing: 'linear'
                    }
                }
            }
        });

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText('Created by HNT', width - 10, height - 10);

        const buffer = canvas.toBuffer('image/png');
        const chartPath = './commands/cache/market_chart.png';
        fs.writeFileSync(chartPath, buffer);

        return {
            success: true,
            chartPath,
            priceChange,
            highPrice: Math.max(...prices),
            lowPrice: Math.min(...prices),
            volatility
        };
    } catch (error) {
        console.error('Error generating chart:', error);
        return { success: false, message: "L·ªói khi t·∫°o bi·ªÉu ƒë·ªì" };
    }
}

function calculateMA(data, period) {
    const result = [];
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            result.push(null);
            continue;
        }
        
        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
        result.push(sum / period);
    }
    return result;
}

function calculateVolatility(prices) {
    if (prices.length < 2) return 0;
    
    const returns = [];
    for (let i = 1; i < prices.length; i++) {
        returns.push((prices[i] - prices[i-1]) / prices[i-1]);
    }
    
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
    return Math.sqrt(variance) * 100;
}

module.exports = {
    name: "coin",
    dev: "HNT",
    category: "Games",
    info: "Tr√≤ ch∆°i ƒë√†o coin",
    usage: ".coin [mine/info/upgrade/market/sell/buy/quest]",
    onPrefix: true,
    cooldowns: 0,

    onLaunch: async function ({ api, event, target }) {
        const { threadID, messageID, senderID } = event;
        let { miningData, marketData } = initializeData();
        
        if (!miningData[senderID]) {
            miningData[senderID] = initializePlayer(senderID);
        }

        marketData = updateMarketPrice(marketData);

        const player = miningData[senderID];
        player.miner = player.miner || { ...CONFIG.baseMiner };
        
        miningData[senderID] = checkAndUpdateQuests(player);

        if (!target[0]) {
            return api.sendMessage(
                "üéÆ COIN MINING GAME üéÆ\n" +
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                "üìå L·ªánh c√≥ s·∫µn:\n" +
                "1. mine - ƒê√†o coin\n" +
                "2. info - Th√¥ng tin m√°y ƒë√†o\n" +
                "3. upgrade - N√¢ng c·∫•p m√°y ƒë√†o\n" +
                "4. market - Xem th·ªã tr∆∞·ªùng\n" +
                "5. sell [amount] - B√°n coin\n" +
                "6. buy [amount] - Mua coin\n" +
                "7. quest - Nhi·ªám v·ª• h√†ng ng√†y\n" +
                "8. autosell [on/off] - T·ª± ƒë·ªông b√°n coin\n\n" +
                `üí∞ S·ªë coin ƒë√£ ƒë√†o: ${player.coins}\n` +
                `üíé Gi√° coin hi·ªán t·∫°i: ${marketData.price} $`,
                threadID, messageID
            );
        }

        const command = target[0].toLowerCase();
        const amount = parseInt(target[1]);

        switch (command) {
            case "mine":
                const cooldownTime = CONFIG.miningCooldown - (Date.now() - player.lastMining);
                if (cooldownTime > 0) {
                    return api.sendMessage(
                        `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.ceil(cooldownTime / 1000)} gi√¢y n·ªØa!\n\n` +
                        "üí° M·∫πo: N√¢ng c·∫•p cooling ƒë·ªÉ gi·∫£m th·ªùi gian ch·ªù!",
                        threadID, messageID
                    );
                }

                if (player.miner.durability <= 0) {
                    const repairCost = Math.ceil(CONFIG.baseMiner.repairCost * (1 + player.upgrades.power * 0.2));
                    return api.sendMessage(
                        "üîß M√°y ƒë√†o c·ªßa b·∫°n ƒë√£ h·ªèng!\n" +
                        `üí∞ Chi ph√≠ s·ª≠a ch·ªØa: ${repairCost}$\n` +
                        "S·ª≠ d·ª•ng: .coin repair ƒë·ªÉ s·ª≠a m√°y",
                        threadID, messageID
                    );
                }

                const miningSuccess = Math.random() < calculateMiningSuccess(player);
                if (miningSuccess) {
                    const isCritical = Math.random() < CONFIG.miningSuccess.criticalChance;
                    const reward = calculateMiningReward(player, isCritical);
                    
                    player.coins += reward;
                    player.stats.totalMined += reward;
                    player.stats.successfulMines++;
                    
                    if (player.quests.daily.type === 'mine') {
                        player.quests.daily.progress++;
                    }

                    const eventMessages = isCritical ? CONFIG.baseMiner.miningEvents.critical : CONFIG.baseMiner.miningEvents.normal;
                    const eventMessage = eventMessages[Math.floor(Math.random() * eventMessages.length)];

                    let message = [
                        `${eventMessage}\n`,
                        isCritical ? "‚ú® CRITICAL HIT! x2 REWARDS ‚ú®" : "",
                        `üíé ƒê√†o ƒë∆∞·ª£c: ${reward} LCoin`,
                        `üí∞ Gi√° tr·ªã: ${Math.floor(reward * marketData.price)}$`,
                        `üíé T·ªïng coin: ${player.coins}`,
                        `üîã ƒê·ªô b·ªÅn m√°y: ${Math.round(player.miner.durability)}%`,
                        `‚ö° Hi·ªáu su·∫•t: ${Math.round(calculateMiningSuccess(player) * 100)}%`
                    ].filter(Boolean).join('\n');

                    player.miningStreak = (player.miningStreak || 0) + 1;
                    if (player.miningStreak >= 5) {
                        const streakBonus = Math.floor(reward * 0.1);
                        player.coins += streakBonus;
                        message += `\n\nüî• MINING STREAK x${player.miningStreak}!\n` +
                                  `‚ú® Bonus: +${streakBonus} LCoin`;
                    }

                    if (player.settings && player.settings.autoSell && reward > 0) {
                        const sellValue = Math.floor(reward * marketData.price);
                        player.coins -= reward;  
                        await updateBalance(senderID, sellValue);
                        
                        if (player.quests.daily.type === 'market') {
                            player.quests.daily.progress++;
                        }

                        message += "\n\n" + [
                            "üîÑ T·ª∞ ƒê·ªòNG B√ÅN COIN üîÑ",
                            `üì§ ƒê√£ b√°n: ${reward} LCoin`,
                            `üíµ Nh·∫≠n ƒë∆∞·ª£c: ${sellValue}$`,
                            `üíé LCoin c√≤n l·∫°i: ${player.coins}`
                        ].join('\n');
                    }

                    api.sendMessage(message, threadID, messageID);
                } else {
                    player.stats.failedMines++;
                    player.miningStreak = 0;
                    
                    const failMessage = CONFIG.baseMiner.miningEvents.fail[Math.floor(Math.random() * CONFIG.baseMiner.miningEvents.fail.length)];
                    
                    api.sendMessage(
                        `‚ùå ${failMessage}\n\n` +
                        "üìù Nguy√™n nh√¢n c√≥ th·ªÉ do:\n" +
                        "- M√°y ƒë√†o qu√° n√≥ng\n" +
                        "- Hi·ªáu su·∫•t th·∫•p\n" +
                        "- Thi·∫øu may m·∫Øn\n\n" +
                        "üí° M·∫πo: N√¢ng c·∫•p cooling ƒë·ªÉ tƒÉng t·ª∑ l·ªá th√†nh c√¥ng!",
                        threadID, messageID
                    );
                }

                const durabilityLoss = CONFIG.baseMiner.consumption * (1 - player.upgrades.cooling * 0.05);
                player.miner.durability = Math.max(0, player.miner.durability - durabilityLoss);
                player.lastMining = Date.now();
                break;

            case "repair":
                if (player.miner.durability >= CONFIG.baseMiner.maxDurability) {
                    return api.sendMessage("‚úÖ M√°y ƒë√†o c·ªßa b·∫°n v·∫´n c√≤n t·ªët!", threadID, messageID);
                }

                const repairCost = Math.ceil(CONFIG.baseMiner.repairCost * (1 + player.upgrades.power * 0.2));
                const balance = await getBalance(senderID);
                
                if (balance < repairCost) {
                    return api.sendMessage(
                        `‚ùå B·∫°n c·∫ßn ${repairCost} $ ƒë·ªÉ s·ª≠a m√°y!`,
                        threadID, messageID
                    );
                }

                await updateBalance(senderID, -repairCost);
                player.miner.durability = CONFIG.baseMiner.maxDurability;

                api.sendMessage(
                    "üîß S·ª≠a ch·ªØa m√°y th√†nh c√¥ng!\n" +
                    `üí∞ Chi ph√≠: ${repairCost} $\n` +
                    "‚úÖ ƒê√£ ph·ª•c h·ªìi ƒë·ªô b·ªÅn v·ªÅ 100%",
                    threadID, messageID
                );
                break;

            case "info":
                const efficiency = Math.round((1 + player.upgrades.efficiency * 0.15) * 100);
                const power = Math.round((1 + player.upgrades.power * 0.2) * 100);
                const cooling = Math.round((1 + player.upgrades.cooling * 0.1) * 100);
                const successRate = Math.round(calculateMiningSuccess(player) * 100);
                
                const nextPowerCost = CONFIG.upgradeCosts.power[player.upgrades.power] || "ƒê√£ t·ªëi ƒëa";
                const nextEfficiencyCost = CONFIG.upgradeCosts.efficiency[player.upgrades.efficiency] || "ƒê√£ t·ªëi ƒëa";
                const nextCoolingCost = CONFIG.upgradeCosts.cooling[player.upgrades.cooling] || "ƒê√£ t·ªëi ƒëa";
                
                const totalInvestment = Object.entries(player.upgrades).reduce((total, [type, level]) => {
                    return total + Array(level).fill().reduce((sum, _, i) => sum + CONFIG.upgradeCosts[type][i], 0);
                }, 0);
                
                const estimatedValue = Math.round(player.coins * marketData.price);
                
                api.sendMessage(
                    "üåü TH√îNG TIN M√ÅY ƒê√ÄO LCOIN üåü\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    "‚öôÔ∏è TH√îNG S·ªê M√ÅY ƒê√ÄO:\n" +
                    `‚ö° C√¥ng su·∫•t: ${power}% (C·∫•p ${player.upgrades.power}/10)\n` +
                    `üìä Hi·ªáu su·∫•t: ${efficiency}% (C·∫•p ${player.upgrades.efficiency}/10)\n` +
                    `‚ùÑÔ∏è L√†m m√°t: ${cooling}% (C·∫•p ${player.upgrades.cooling}/10)\n` +
                    `üéØ T·ª∑ l·ªá th√†nh c√¥ng: ${successRate}%\n` +
                    `üîã ƒê·ªô b·ªÅn: ${Math.round(player.miner.durability)}%\n\n` +
                    
                    "üí∞ TH√îNG TIN T√ÄI CH√çNH:\n" +
                    `üíé S·ªë LCoin: ${player.coins} (‚âà ${estimatedValue}$)\n` +
                    `üíµ T·ªïng ƒë·∫ßu t∆∞: ${totalInvestment}$\n\n` +
                    
                    "üìà TH·ªêNG K√ä ƒê√ÄO COIN:\n" +
                    `üíé T·ªïng ƒë√£ ƒë√†o: ${player.stats.totalMined}\n` +
                    `‚úÖ Th√†nh c√¥ng: ${player.stats.successfulMines}\n` +
                    `‚ùå Th·∫•t b·∫°i: ${player.stats.failedMines}\n` +
                    `‚öúÔ∏è T·ª∑ l·ªá: ${Math.round((player.stats.successfulMines / (player.stats.successfulMines + player.stats.failedMines || 1)) * 100)}%\n\n` +
                    
                    "üîÑ N√ÇNG C·∫§P TI·∫æP THEO:\n" +
                    `‚ö° Power: ${nextPowerCost}$\n` +
                    `üìä Efficiency: ${nextEfficiencyCost}$\n` +
                    `‚ùÑÔ∏è Cooling: ${nextCoolingCost}$\n\n` +
                    
                    "‚öôÔ∏è C√ÄI ƒê·∫∂T:\n" +
                    `üîÑ T·ª± ƒë·ªông b√°n: ${player.settings?.autoSell ? "B·∫≠t ‚úÖ" : "T·∫Øt ‚ùå"}\n` +
                    `üíé Gi√° LCoin hi·ªán t·∫°i: ${marketData.price}$\n\n` +
                    
                    "üí° M·∫πo: N√¢ng c·∫•p ƒë·ªìng b·ªô c√°c ch·ªâ s·ªë s·∫Ω mang l·∫°i hi·ªáu qu·∫£ t·ªët nh·∫•t!",
                    threadID, messageID
                );
                break;

            case "upgrade":
                if (!target[1]) {
                    return api.sendMessage(
                        "‚öôÔ∏è N√ÇNG C·∫§P M√ÅY ƒê√ÄO ‚öôÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "üìå C√°c lo·∫°i n√¢ng c·∫•p:\n" +
                        `1. power - TƒÉng s·ª©c m·∫°nh (${CONFIG.upgradeCosts.power[player.upgrades.power] || 'ƒê√£ t·ªëi ƒëa'} $)\n` +
                        `2. efficiency - TƒÉng hi·ªáu su·∫•t (${CONFIG.upgradeCosts.efficiency[player.upgrades.efficiency] || 'ƒê√£ t·ªëi ƒëa'} $)\n` +
                        `3. cooling - TƒÉng l√†m m√°t (${CONFIG.upgradeCosts.cooling[player.upgrades.cooling] || 'ƒê√£ t·ªëi ƒëa'} $)\n\n` +
                        "C·∫•p ƒë·ªô hi·ªán t·∫°i:\n" +
                        `‚ö° Power: ${player.upgrades.power}/10\n` +
                        `üìä Efficiency: ${player.upgrades.efficiency}/10\n` +
                        `‚ùÑÔ∏è Cooling: ${player.upgrades.cooling}/10\n\n` +
                        "üíé Th√¥ng tin n√¢ng c·∫•p:\n" +
                        "‚Ä¢ Power: +20% s·ª©c m·∫°nh ƒë√†o/c·∫•p\n" +
                        "‚Ä¢ Efficiency: +15% hi·ªáu su·∫•t/c·∫•p\n" +
                        "‚Ä¢ Cooling: +10% l√†m m√°t/c·∫•p\n\n" +
                        "S·ª≠ d·ª•ng: .coin upgrade [lo·∫°i]",
                        threadID, messageID
                    );
                }

                const upgradeType = target[1].toLowerCase();
                const validTypes = ['power', 'efficiency', 'cooling'];
                
                if (!validTypes.includes(upgradeType)) {
                    return api.sendMessage("‚ùå Lo·∫°i n√¢ng c·∫•p kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                }

                const currentLevel = player.upgrades[upgradeType];
                const upgradeCost = CONFIG.upgradeCosts[upgradeType][currentLevel];
                
                if (!upgradeCost) {
                    return api.sendMessage(
                        "‚ùå ƒê√£ ƒë·∫°t c·∫•p ƒë·ªô t·ªëi ƒëa!\n" +
                        `üìä ${upgradeType.charAt(0).toUpperCase() + upgradeType.slice(1)}: ${currentLevel}/10`,
                        threadID, messageID
                    );
                }

                const playerBalance = await getBalance(senderID);
                if (playerBalance < upgradeCost) {
                    return api.sendMessage(
                        `‚ùå Kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ n√¢ng c·∫•p!\n` +
                        `üí∞ S·ªë d∆∞: ${playerBalance} $\n` +
                        `üíµ C·∫ßn th√™m: ${upgradeCost - playerBalance} $`,
                        threadID, messageID
                    );
                }

                await updateBalance(senderID, -upgradeCost);
                player.upgrades[upgradeType]++;
                
                if (player.quests.daily.type === 'upgrade') {
                    player.quests.daily.progress++;
                }

                const upgradeEffects = {
                    power: "‚ö° TƒÉng s·ª©c m·∫°nh ƒë√†o +20%",
                    efficiency: "üìä TƒÉng hi·ªáu su·∫•t +15%",
                    cooling: "‚ùÑÔ∏è TƒÉng kh·∫£ nƒÉng l√†m m√°t +10%"
                };

                api.sendMessage(
                    "üî® N√¢ng c·∫•p th√†nh c√¥ng!\n" +
                    `üìà ${upgradeType.charAt(0).toUpperCase() + upgradeType.slice(1)}: ${currentLevel} ‚Üí ${currentLevel + 1}\n` +
                    `${upgradeEffects[upgradeType]}\n` +
                    `üí∞ S·ªë d∆∞ c√≤n l·∫°i: ${(await getBalance(senderID)).toLocaleString()} $`,
                    threadID, messageID
                );
                break;

            case "market":
                const priceChange = marketData.history.length > 0 
                    ? ((marketData.price - marketData.history[0].price) / marketData.history[0].price * 100).toFixed(2)
                    : "0.00";
                
                const trend = priceChange > 0 ? "‚ÜóÔ∏è" : priceChange < 0 ? "‚ÜòÔ∏è" : "‚û°Ô∏è";
                const sentiment = priceChange > 5 ? "R·∫•t t√≠ch c·ª±c üöÄ" : 
                                 priceChange > 2 ? "T√≠ch c·ª±c üìà" : 
                                 priceChange < -5 ? "R·∫•t ti√™u c·ª±c üìâ" : 
                                 priceChange < -2 ? "Ti√™u c·ª±c üîª" : 
                                 "·ªîn ƒë·ªãnh üìä";
                
                let highPrice = marketData.price;
                let lowPrice = marketData.price;
                if (marketData.history.length > 0) {
                    const last24h = marketData.history.slice(-24);
                    highPrice = Math.max(...last24h.map(h => h.price), marketData.price);
                    lowPrice = Math.min(...last24h.map(h => h.price), marketData.price);
                }
                
                const tradingTip = priceChange > 3 ? "N√™n xem x√©t b√°n ƒë·ªÉ l·∫•y l·ª£i nhu·∫≠n üí∞" : 
                                 priceChange < -3 ? "C√≥ th·ªÉ l√† th·ªùi ƒëi·ªÉm t·ªët ƒë·ªÉ mua v√†o üîç" : 
                                 "Th·ªã tr∆∞·ªùng ·ªïn ƒë·ªãnh, theo d√µi th√™m üëÄ";
                
                const marketMessage = 
                    "üìä TH·ªä TR∆Ø·ªúNG COIN üìä\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `üíé Gi√° hi·ªán t·∫°i: ${marketData.price} $ ${trend}\n` +
                    `üìà Thay ƒë·ªïi: ${priceChange}% (${sentiment})\n` +
                    `üî∫ Cao nh·∫•t: ${highPrice} $\n` +
                    `üîª Th·∫•p nh·∫•t: ${lowPrice} $\n\n` +
                    `üí° Nh·∫≠n ƒë·ªãnh: ${tradingTip}\n` +
                    `‚è∞ C·∫≠p nh·∫≠t sau: ${Math.ceil((CONFIG.market.updateInterval - (Date.now() - marketData.lastUpdate)) / 1000)}s\n\n` +
                    "üíº Giao d·ªãch:\n" +
                    "‚Ä¢ .coin sell [s·ªë l∆∞·ª£ng] - B√°n coin\n" +
                    "‚Ä¢ .coin buy [s·ªë l∆∞·ª£ng] - Mua coin\n" +
                    "‚Ä¢ .coin chart [1h/6h/12h] - Xem bi·ªÉu ƒë·ªì kh√°c";
                
                if (marketData.history.length < 2) {
                    return api.sendMessage(
                        marketMessage + "\n\n‚ö†Ô∏è Ch∆∞a ƒë·ªß d·ªØ li·ªáu l·ªãch s·ª≠ ƒë·ªÉ t·∫°o bi·ªÉu ƒë·ªì!",
                        threadID, messageID
                    );
                }
                
                const marketChartResult = await generatePriceChart(marketData, "24h");
                
                if (!marketChartResult.success) {
                    return api.sendMessage(marketMessage, threadID, messageID);
                }
                
                api.sendMessage(
                    {
                        body: marketMessage,
                        attachment: fs.createReadStream(marketChartResult.chartPath)
                    },
                    threadID, messageID
                );
                
                setTimeout(() => {
                    try {
                        if (fs.existsSync(marketChartResult.chartPath)) {
                            fs.unlinkSync(marketChartResult.chartPath);
                        }
                    } catch (err) {
                        console.error("Error deleting chart file:", err);
                    }
                }, 10000);
                break;

            case "chart":
                const period = target[1] || "24h";
                if (!["1h", "6h", "12h", "24h"].includes(period)) {
                    return api.sendMessage(
                        "‚ùå Kho·∫£ng th·ªùi gian kh√¥ng h·ª£p l·ªá!\n" +
                        "S·ª≠ d·ª•ng: .coin chart [1h/6h/12h/24h]",
                        threadID, messageID
                    );
                }
                
                if (marketData.history.length < 2) {
                    return api.sendMessage(
                        "‚ö†Ô∏è Ch∆∞a ƒë·ªß d·ªØ li·ªáu l·ªãch s·ª≠ ƒë·ªÉ t·∫°o bi·ªÉu ƒë·ªì!\n" +
                        "Vui l√≤ng ch·ªù m·ªôt th·ªùi gian ƒë·ªÉ h·ªá th·ªëng thu th·∫≠p d·ªØ li·ªáu.",
                        threadID, messageID
                    );
                }
                
                const chartResult = await generatePriceChart(marketData, period);
                if (!chartResult.success) {
                    return api.sendMessage(`‚ùå ${chartResult.message}`, threadID, messageID);
                }
                
                const changeEmoji = chartResult.priceChange >= 0 ? 'üìà' : 'üìâ';
                const chartMessage = 
                    "üìä BI·ªÇU ƒê·ªí GI√Å COIN üìä\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `${changeEmoji} Gi√° hi·ªán t·∫°i: ${marketData.price} $\n` +
                    `‚ÜïÔ∏è Bi·∫øn ƒë·ªông: ${chartResult.priceChange >= 0 ? '+' : ''}${chartResult.priceChange} $ (${chartResult.changePercent}%)\n` +
                    `üî∫ Cao nh·∫•t: ${chartResult.highPrice} $\n` +
                    `üîª Th·∫•p nh·∫•t: ${chartResult.lowPrice} $\n\n` +
                    `‚è∞ C·∫≠p nh·∫≠t: ${new Date().toLocaleString('vi-VN')}`;
                
                api.sendMessage(
                    {
                        body: chartMessage,
                        attachment: fs.createReadStream(chartResult.chartPath)
                    },
                    threadID, messageID
                );
                
                setTimeout(() => {
                    try {
                        if (fs.existsSync(chartResult.chartPath)) {
                            fs.unlinkSync(chartResult.chartPath);
                        }
                    } catch (err) {
                        console.error("Error deleting chart file:", err);
                    }
                }, 10000);
                break;

            case "market history":
                if (marketData.history.length === 0) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ gi√°!", threadID, messageID);
                }
                
                let historyMsg = "üìú L·ªäCH S·ª¨ GI√Å COIN üìú\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                const historyEntries = [...marketData.history.slice(-10), {price: marketData.price, timestamp: Date.now()}];
                
                historyEntries.forEach((entry, index) => {
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const prevPrice = index > 0 ? historyEntries[index - 1].price : entry.price;
                    const changeIcon = entry.price > prevPrice ? "üìà" : entry.price < prevPrice ? "üìâ" : "üìä";
                    
                    historyMsg += `${changeIcon} ${time}: ${entry.price} $\n`;
                });
                
                historyMsg += "\nüí° S·ª≠ d·ª•ng th√¥ng tin tr√™n ƒë·ªÉ ƒë∆∞a ra quy·∫øt ƒë·ªãnh giao d·ªãch kh√¥n ngoan!";
                api.sendMessage(historyMsg, threadID, messageID);
                break;

            case "sell":
                if (!target[1]) {
                    return api.sendMessage(
                        "‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng h·ª£p l·ªá!\n\n" +
                        "üí° C√°ch s·ª≠ d·ª•ng:\n" +
                        "‚Ä¢ .coin sell [s·ªë l∆∞·ª£ng] - B√°n s·ªë l∆∞·ª£ng c·ª• th·ªÉ\n" +
                        "‚Ä¢ .coin sell all - B√°n t·∫•t c·∫£\n" +
                        "‚Ä¢ .coin sell half - B√°n m·ªôt n·ª≠a",
                        threadID, messageID
                    );
                }

                let sellAmount;
                if (target[1].toLowerCase() === 'all') {
                    sellAmount = player.coins;
                } else if (target[1].toLowerCase() === 'half') {
                    sellAmount = Math.floor(player.coins / 2);
                } else {
                    sellAmount = parseInt(target[1]);
                    if (!sellAmount || sellAmount <= 0) {
                        return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng h·ª£p l·ªá!", threadID, messageID);
                    }
                }

                if (sellAmount > player.coins) {
                    return api.sendMessage(
                        "‚ùå B·∫°n kh√¥ng c√≥ ƒë·ªß LCoin!\n\n" +
                        `üíé S·ªë LCoin hi·ªán c√≥: ${player.coins}\n` +
                        `üí∞ Gi√° tr·ªã: ${Math.floor(player.coins * marketData.price)}$`,
                        threadID, messageID
                    );
                }

                const sellValue = Math.floor(sellAmount * marketData.price);
                const profitLoss = sellValue - (sellAmount * marketData.history[0]?.price || marketData.price);
                player.coins -= sellAmount;
                await updateBalance(senderID, sellValue);
                
                if (player.quests.daily.type === 'market') {
                    player.quests.daily.progress++;
                }

                api.sendMessage(
                    "üí∞ B√ÅN LCOIN TH√ÄNH C√îNG üí∞\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `üì§ S·ªë l∆∞·ª£ng: ${sellAmount} LCoin\n` +
                    `üíµ Nh·∫≠n ƒë∆∞·ª£c: ${sellValue}$\n` +
                    `${profitLoss >= 0 ? 'üìà' : 'üìâ'} L·ª£i nhu·∫≠n: ${profitLoss}$\n` +
                    `üíé LCoin c√≤n l·∫°i: ${player.coins}\n\n` +
                    `üí° Gi√° hi·ªán t·∫°i: ${marketData.price}$`,
                    threadID, messageID
                );
                break;

            case "buy":
                if (!target[1]) {
                    return api.sendMessage(
                        "‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng h·ª£p l·ªá!\n\n" +
                        "üí° C√°ch s·ª≠ d·ª•ng:\n" +
                        "‚Ä¢ .coin buy [s·ªë l∆∞·ª£ng] - Mua s·ªë l∆∞·ª£ng c·ª• th·ªÉ\n" +
                        "‚Ä¢ .coin buy max - Mua t·ªëi ƒëa c√≥ th·ªÉ\n" +
                        "‚Ä¢ .coin buy half - D√πng m·ªôt n·ª≠a s·ªë ti·ªÅn ƒë·ªÉ mua",
                        threadID, messageID
                    );
                }

                const userBalance = await getBalance(senderID);
                let buyAmount;
                let cost;

                if (target[1].toLowerCase() === 'max') {
                    buyAmount = Math.floor(userBalance / marketData.price);
                    cost = Math.ceil(buyAmount * marketData.price);
                } else if (target[1].toLowerCase() === 'half') {
                    buyAmount = Math.floor((userBalance / 2) / marketData.price);
                    cost = Math.ceil(buyAmount * marketData.price);
                } else {
                    buyAmount = parseInt(target[1]);
                    if (!buyAmount || buyAmount <= 0) {
                        return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng h·ª£p l·ªá!", threadID, messageID);
                    }
                    cost = Math.ceil(buyAmount * marketData.price);
                }

                if (cost > userBalance) {
                    return api.sendMessage(
                        "‚ùå Kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ mua!\n\n" +
                        `üíµ S·ªë d∆∞: ${userBalance}$\n` +
                        `üí∞ C·∫ßn th√™m: ${cost - userBalance}$\n` +
                        `üíé Gi√° hi·ªán t·∫°i: ${marketData.price}$/LCoin\n\n` +
                        "üí° G·ª£i √Ω: D√πng '.coin buy max' ƒë·ªÉ mua t·ªëi ƒëa c√≥ th·ªÉ!",
                        threadID, messageID
                    );
                }

                await updateBalance(senderID, -cost);
                player.coins += buyAmount;
                
                if (player.quests.daily.type === 'market') {
                    player.quests.daily.progress++;
                }

                const potentialValue = Math.round(buyAmount * (marketData.price * 1.1));
                api.sendMessage(
                    "üí∞ MUA LCOIN TH√ÄNH C√îNG üí∞\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `üì• S·ªë l∆∞·ª£ng: ${buyAmount} LCoin\n` +
                    `üíµ Chi ph√≠: ${cost}$\n` +
                    `üíé LCoin hi·ªán c√≥: ${player.coins}\n` +
                    `üí∞ Gi√° trung b√¨nh: ${(cost / buyAmount).toFixed(2)}$/LCoin\n\n` +
                    `üí° N·∫øu gi√° tƒÉng 10%, b·∫°n s·∫Ω l√£i: ${potentialValue - cost}$`,
                    threadID, messageID
                );
                break;

            case "quest":
                const quest = player.quests.daily;
                const questName = {
                    mine: "ƒê√†o coin",
                    upgrade: "N√¢ng c·∫•p m√°y",
                    market: "Giao d·ªãch th·ªã tr∆∞·ªùng"
                }[quest.type];

                const questCompleted = quest.progress >= quest.target;
                if (questCompleted && !quest.claimed) {
                    const reward = CONFIG.dailyQuests.rewards[quest.type];
                    await updateBalance(senderID, reward);
                    quest.claimed = true;

                    api.sendMessage(
                        "üéâ HO√ÄN TH√ÄNH NHI·ªÜM V·ª§ üéâ\n" +
                        `üí∞ Ph·∫ßn th∆∞·ªüng: ${reward} $\n` +
                        "üìù Nhi·ªám v·ª• m·ªõi s·∫Ω reset v√†o ng√†y mai!",
                        threadID, messageID
                    );
                } else {
                    api.sendMessage(
                        "üìã NHI·ªÜM V·ª§ H√ÄNG NG√ÄY üìã\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üìå Nhi·ªám v·ª•: ${questName}\n` +
                        `üìä Ti·∫øn ƒë·ªô: ${quest.progress}/${quest.target}\n` +
                        `üí∞ Ph·∫ßn th∆∞·ªüng: ${CONFIG.dailyQuests.rewards[quest.type]} $\n` +
                        (questCompleted ? "‚úÖ ƒê√£ ho√†n th√†nh!" : "‚è≥ ƒêang th·ª±c hi·ªán..."),
                        threadID, messageID
                    );
                }
                break;

            case "autosell":
                if (!target[1]) {
                    return api.sendMessage(
                        "‚öôÔ∏è C√ÄI ƒê·∫∂T T·ª∞ ƒê·ªòNG B√ÅN COIN ‚öôÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `Tr·∫°ng th√°i hi·ªán t·∫°i: ${player.settings?.autoSell ? "B·∫≠t ‚úÖ" : "T·∫Øt ‚ùå"}\n\n` +
                        "S·ª≠ d·ª•ng:\n" +
                        "‚Ä¢ .coin autosell on - B·∫≠t t·ª± ƒë·ªông b√°n\n" +
                        "‚Ä¢ .coin autosell off - T·∫Øt t·ª± ƒë·ªông b√°n\n\n" +
                        "üí° Khi b·∫≠t ch·∫ø ƒë·ªô n√†y, coin s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c b√°n ngay sau khi ƒë√†o th√†nh c√¥ng v·ªõi gi√° th·ªã tr∆∞·ªùng hi·ªán t·∫°i.",
                        threadID, messageID
                    );
                }

                const settingValue = target[1].toLowerCase();
                if (settingValue !== "on" && settingValue !== "off") {
                    return api.sendMessage("‚ùå Vui l√≤ng ch·ªçn 'on' ho·∫∑c 'off'!", threadID, messageID);
                }

                player.settings = player.settings || {};
                player.settings.autoSell = (settingValue === "on");

                api.sendMessage(
                    `‚úÖ ƒê√£ ${player.settings.autoSell ? "B·∫¨T" : "T·∫ÆT"} ch·∫ø ƒë·ªô t·ª± ƒë·ªông b√°n coin!\n\n` +
                    (player.settings.autoSell ? 
                        "Gi·ªù ƒë√¢y coin s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c b√°n sau m·ªói l·∫ßn ƒë√†o th√†nh c√¥ng." : 
                        "Coin s·∫Ω ƒë∆∞·ª£c l∆∞u tr·ªØ sau m·ªói l·∫ßn ƒë√†o.") +
                    `\n\nüíé Gi√° coin hi·ªán t·∫°i: ${marketData.price} $`,
                    threadID, messageID
                );
                break;

            default:
                api.sendMessage("‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                break;
        }

        saveData(miningData, marketData);
    }
};
