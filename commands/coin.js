const fs = require('fs');
const path = require('path');
const { getBalance, updateBalance } = require('../utils/currencies');

const MINING_CONFIG = {
    baseMiningRate: 0.001,
    baseElectricityRate: 0.0005,
    miningInterval: 5000, 
    maxDailyMining: 1000,
    marketUpdateInterval: 3600000, 
};

const EQUIPMENT_TIERS = {
    gpu: [
        { name: "GTX 1050", power: 1, cost: 500000, electricity: 1 },
        { name: "RTX 2060", power: 2, cost: 1500000, electricity: 1.5 },
        { name: "RTX 3070", power: 3, cost: 3000000, electricity: 2 },
        { name: "RTX 4080", power: 5, cost: 5000000, electricity: 3 },
        { name: "RTX 4090", power: 8, cost: 10000000, electricity: 4 },
        { name: "RTX 5090 Ti", power: 12, cost: 20000000, electricity: 5 },
        { name: "QUANTUM GPU", power: 20, cost: 50000000, electricity: 8 }
    ],
    cooler: [
        { name: "Basic Fan", power: 1, cost: 200000, efficiency: 1 },
        { name: "Water Cooling", power: 1.5, cost: 1000000, efficiency: 1.2 },
        { name: "Advanced Cooling", power: 2, cost: 2000000, efficiency: 1.5 },
        { name: "Nitrogen Cooling", power: 3, cost: 5000000, efficiency: 2 },
        { name: "Quantum Cooling", power: 5, cost: 10000000, efficiency: 3 }
    ],
    powerSupply: [
        { name: "500W PSU", power: 1, cost: 300000, stability: 1 },
        { name: "800W PSU", power: 1.2, cost: 800000, stability: 1.3 },
        { name: "1200W PSU", power: 1.5, cost: 1500000, stability: 1.5 },
        { name: "2000W PSU", power: 2, cost: 3000000, stability: 2 },
        { name: "Quantum PSU", power: 3, cost: 8000000, stability: 3 }
    ],
    motherboard: [
        { name: "Basic Board", power: 1, cost: 400000, bonus: 1 },
        { name: "Gaming Board", power: 1.3, cost: 1200000, bonus: 1.2 },
        { name: "Pro Board", power: 1.8, cost: 2500000, bonus: 1.5 },
        { name: "Server Board", power: 2.5, cost: 5000000, bonus: 2 },
        { name: "Quantum Board", power: 4, cost: 12000000, bonus: 3 }
    ],
    ram: [
        { name: "8GB RAM", power: 1, cost: 300000, speed: 1 },
        { name: "16GB RAM", power: 1.2, cost: 900000, speed: 1.3 },
        { name: "32GB RAM", power: 1.5, cost: 2000000, speed: 1.8 },
        { name: "64GB RAM", power: 2, cost: 4000000, speed: 2.5 },
        { name: "Quantum RAM", power: 3, cost: 9000000, speed: 4 }
    ]
};

const CRYPTO_TYPES = {
    BTC: { name: "Bitcoin", baseValue: 100000, volatility: 0.15 },
    ETH: { name: "Ethereum", baseValue: 50000, volatility: 0.12 },
    AKC: { name: "AkiCoin", baseValue: 10000, volatility: 0.08 }
};

function loadMiningData() {
    const filePath = path.join(__dirname, 'json', 'mining_data.json');
    try {

        if (!fs.existsSync(path.dirname(filePath))) {
            fs.mkdirSync(path.dirname(filePath), { recursive: true });
        }

        let data;
        if (fs.existsSync(filePath)) {
            data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        } else {
            data = {
                users: {},
                market: updateMarketPrices(),
                lastMarketUpdate: Date.now()
            };
            fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
        }

        if (!data.users) data.users = {};
        if (!data.market) {
            data.market = updateMarketPrices();
            data.lastMarketUpdate = Date.now();
        }

        return data;
    } catch (err) {
        console.error('Error loading mining data:', err);

        return {
            users: {},
            market: updateMarketPrices(),
            lastMarketUpdate: Date.now()
        };
    }
}

function saveMiningData(data) {
    const filePath = path.join(__dirname, 'json', 'mining_data.json');
    try {
        if (!fs.existsSync(path.dirname(filePath))) {
            fs.mkdirSync(path.dirname(filePath), { recursive: true });
        }
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    } catch (err) {
        console.error('Error saving mining data:', err);
    }
}

function updateMarketPrices() {
    const market = {};
    for (const [symbol, crypto] of Object.entries(CRYPTO_TYPES)) {
        const randomChange = (Math.random() - 0.5) * 2 * crypto.volatility;
        market[symbol] = {
            price: crypto.baseValue * (1 + randomChange),
            change: randomChange * 100
        };
    }
    return market;
}

function calculateMiningPower(equipment) {
    if (!equipment) return 1;
    
    const gpuPower = EQUIPMENT_TIERS.gpu[equipment.gpu || 0].power;
    const coolerEfficiency = EQUIPMENT_TIERS.cooler[equipment.cooler || 0].efficiency;
    const psuStability = EQUIPMENT_TIERS.powerSupply[equipment.psu || 0].stability;
    
    return gpuPower * coolerEfficiency * psuStability;
}

function calculateElectricityCost(equipment) {
    if (!equipment) return MINING_CONFIG.baseElectricityRate;
    
    const gpuPower = EQUIPMENT_TIERS.gpu[equipment.gpu || 0].electricity;
    return MINING_CONFIG.baseElectricityRate * gpuPower;
}

module.exports = {
    name: "coin",
    dev: "HNT",
    onPrefix: true,
    usages: "[mine/shop/upgrade/trade/market/wallet]",
    info: "H·ªá th·ªëng ƒë√†o coin crypto",
    cooldowns: 5,

    onLaunch: async function({ api, event, target = [] }) {
        try {
            const { threadID, messageID, senderID } = event;
            let miningData = loadMiningData();

            if (!miningData.users[senderID]) {
                miningData.users[senderID] = {
                    equipment: {
                        gpu: 0,
                        cooler: 0,
                        psu: 0,
                        motherboard: 0,
                        ram: 0
                    },
                    wallet: {
                        BTC: 0,
                        ETH: 0,
                        AKC: 0
                    },
                    stats: {
                        totalMined: 0,
                        dailyMining: 0,
                        lastMiningTime: 0,
                        lastDailyReset: Date.now()
                    }
                };
                saveMiningData(miningData);
            }

            const user = miningData.users[senderID];
            if (!user.equipment) user.equipment = { gpu: 0, cooler: 0, psu: 0, motherboard: 0, ram: 0 };
            if (!user.wallet) user.wallet = { BTC: 0, ETH: 0, AKC: 0 };
            if (!user.stats) user.stats = { totalMined: 0, dailyMining: 0, lastMiningTime: 0, lastDailyReset: Date.now() };

            if (!miningData.market || Date.now() - miningData.lastMarketUpdate > MINING_CONFIG.marketUpdateInterval) {
                miningData.market = updateMarketPrices();
                miningData.lastMarketUpdate = Date.now();
                saveMiningData(miningData);
            }

            const today = new Date().setHours(0, 0, 0, 0);
            if (user.stats.lastDailyReset < today) {
                user.stats.dailyMining = 0;
                user.stats.lastDailyReset = today;
                saveMiningData(miningData);
            }

            const command = target[0]?.toLowerCase();
            const param = target[1]?.toLowerCase();

            switch (command) {
                case "mine":
                    if (user.stats.dailyMining >= MINING_CONFIG.maxDailyMining) {
                        return api.sendMessage("‚ö†Ô∏è B·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n ƒë√†o coin h√¥m nay! H√£y quay l·∫°i v√†o ng√†y mai.", threadID, messageID);
                    }

                    const timeSinceLastMine = Date.now() - user.stats.lastMiningTime;
                    if (timeSinceLastMine < MINING_CONFIG.miningInterval) {
                        const waitTime = Math.ceil((MINING_CONFIG.miningInterval - timeSinceLastMine) / 1000);
                        return api.sendMessage(`‚è≥ Vui l√≤ng ƒë·ª£i ${waitTime} gi√¢y n·ªØa ƒë·ªÉ ti·∫øp t·ª•c ƒë√†o!`, threadID, messageID);
                    }

                    const miningPower = calculateMiningPower(user.equipment);
                    const electricityCost = calculateElectricityCost(user.equipment);
                    
                    const minedBTC = MINING_CONFIG.baseMiningRate * miningPower * (Math.random() * 0.5 + 0.75);
                    const minedETH = MINING_CONFIG.baseMiningRate * miningPower * 2 * (Math.random() * 0.5 + 0.75);
                    const minedAKC = MINING_CONFIG.baseMiningRate * miningPower * 5 * (Math.random() * 0.5 + 0.75);

                    user.wallet.BTC += minedBTC;
                    user.wallet.ETH += minedETH;
                    user.wallet.AKC += minedAKC;

                    const totalValue = (minedBTC * miningData.market.BTC.price +
                                    minedETH * miningData.market.ETH.price +
                                    minedAKC * miningData.market.AKC.price);

                    const electricityCostXu = Math.floor(totalValue * electricityCost);
                    await updateBalance(senderID, -electricityCostXu);

                    user.stats.totalMined++;
                    user.stats.dailyMining++;
                    user.stats.lastMiningTime = Date.now();
                    saveMiningData(miningData);

                    return api.sendMessage(
                        "‚õèÔ∏è K·∫æT QU·∫¢ ƒê√ÄO COIN ‚õèÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                        `üéØ Mining Power: x${miningPower.toFixed(2)}\n` +
                        `‚ö° Chi ph√≠ ƒëi·ªán: ${electricityCostXu.toLocaleString('vi-VN')} Xu\n\n` +
                        "üìä Coin ƒë√†o ƒë∆∞·ª£c:\n" +
                        `üî∏ BTC: +${minedBTC.toFixed(8)}\n` +
                        `üî∏ ETH: +${minedETH.toFixed(8)}\n` +
                        `üî∏ AKC: +${minedAKC.toFixed(8)}\n\n` +
                        `üí∞ T·ªïng gi√° tr·ªã: ${Math.floor(totalValue).toLocaleString('vi-VN')} Xu\n` +
                        `üìà L·∫ßn ƒë√†o th·ª© ${user.stats.dailyMining}/${MINING_CONFIG.maxDailyMining} h√¥m nay`,
                        threadID, messageID
                    );

                case "shop":
                    let shopMessage = "üè™ CRYPTO MINING SHOP üè™\n" +
                                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                    "1Ô∏è‚É£ GPU (Card ƒë·ªì h·ªça):\n";
                    
                    EQUIPMENT_TIERS.gpu.forEach((gpu, index) => {
                        shopMessage += `${index}. ${gpu.name}\n` +
                                    `   üí∞ Gi√°: ${gpu.cost.toLocaleString('vi-VN')} Xu\n` +
                                    `   ‚ö°Ô∏è Power: x${gpu.power}\n` +
                                    `   üîå ƒêi·ªán: x${gpu.electricity}\n`;
                    });
                    
                    shopMessage += "\n2Ô∏è‚É£ COOLING (T·∫£n nhi·ªát):\n";
                    EQUIPMENT_TIERS.cooler.forEach((cooler, index) => {
                        shopMessage += `${index}. ${cooler.name}\n` +
                                    `   üí∞ Gi√°: ${cooler.cost.toLocaleString('vi-VN')} Xu\n` +
                                    `   ‚ùÑÔ∏è Hi·ªáu su·∫•t: x${cooler.efficiency}\n`;
                    });
                    
                    shopMessage += "\n3Ô∏è‚É£ POWER SUPPLY (Ngu·ªìn):\n";
                    EQUIPMENT_TIERS.powerSupply.forEach((psu, index) => {
                        shopMessage += `${index}. ${psu.name}\n` +
                                    `   üí∞ Gi√°: ${psu.cost.toLocaleString('vi-VN')} Xu\n` +
                                    `   üîã ƒê·ªô ·ªïn ƒë·ªãnh: x${psu.stability}\n`;
                    });

                    shopMessage += "\n4Ô∏è‚É£ MOTHERBOARD (Bo m·∫°ch ch·ªß):\n";
                    EQUIPMENT_TIERS.motherboard.forEach((mb, index) => {
                        shopMessage += `${index}. ${mb.name}\n` +
                                    `   üí∞ Gi√°: ${mb.cost.toLocaleString('vi-VN')} Xu\n` +
                                    `   üí™ Power: x${mb.power}\n` +
                                    `   üéØ Bonus: x${mb.bonus}\n`;
                    });

                    shopMessage += "\n5Ô∏è‚É£ RAM (B·ªô nh·ªõ):\n";
                    EQUIPMENT_TIERS.ram.forEach((ram, index) => {
                        shopMessage += `${index}. ${ram.name}\n` +
                                    `   üí∞ Gi√°: ${ram.cost.toLocaleString('vi-VN')} Xu\n` +
                                    `   üí™ Power: x${ram.power}\n` +
                                    `   ‚ö° Speed: x${ram.speed}\n`;
                    });
                    
                    shopMessage += "\nüí° H∆Ø·ªöNG D·∫™N N√ÇNG C·∫§P:\n";
                    shopMessage += "‚Ä¢ C√∫ ph√°p: .coin upgrade [lo·∫°i] [s·ªë th·ª© t·ª±]\n";
                    shopMessage += "‚Ä¢ Lo·∫°i thi·∫øt b·ªã: gpu/cooler/psu/motherboard/ram\n";
                    shopMessage += "‚Ä¢ V√≠ d·ª•: .coin upgrade gpu 2\n\n";
                    shopMessage += "‚ö†Ô∏è L∆ØU √ù:\n";
                    shopMessage += "‚Ä¢ ∆Øu ti√™n n√¢ng c·∫•p GPU tr∆∞·ªõc\n";
                    shopMessage += "‚Ä¢ C·∫ßn ƒë·ªß t·∫£n nhi·ªát cho GPU cao c·∫•p\n";
                    shopMessage += "‚Ä¢ PSU ph·∫£i ƒë·ªß c√¥ng su·∫•t cho h·ªá th·ªëng\n";
                    shopMessage += "‚Ä¢ Mainboard v√† RAM h·ªó tr·ª£ tƒÉng t·ªëc ƒë·ªô ƒë√†o";
                    
                    return api.sendMessage(shopMessage, threadID, messageID);

                case "upgrade":
                    if (!param || !target[2]) {
                        return api.sendMessage(
                            "‚ùå Vui l√≤ng ch·ªçn lo·∫°i thi·∫øt b·ªã v√† c·∫•p ƒë·ªô n√¢ng c·∫•p!\n\n" +
                            "üìå C√∫ ph√°p: .coin upgrade [lo·∫°i] [c·∫•p]\n" +
                            "üìå Lo·∫°i thi·∫øt b·ªã: gpu/cooler/psu/motherboard/ram\n" +
                            "üìå V√≠ d·ª•: .coin upgrade gpu 2", 
                            threadID, messageID
                        );
                    }

                    const type = param;
                    const tier = parseInt(target[2]);
                    
                    if (!['gpu', 'cooler', 'psu', 'motherboard', 'ram'].includes(type)) {
                        return api.sendMessage(
                            "‚ùå Lo·∫°i thi·∫øt b·ªã kh√¥ng h·ª£p l·ªá!\n" +
                            "üìå Ch·ªçn m·ªôt trong c√°c lo·∫°i:\n" +
                            "‚Ä¢ gpu: Card ƒë·ªì h·ªça\n" +
                            "‚Ä¢ cooler: T·∫£n nhi·ªát\n" +
                            "‚Ä¢ psu: Ngu·ªìn ƒëi·ªán\n" +
                            "‚Ä¢ motherboard: Bo m·∫°ch ch·ªß\n" +
                            "‚Ä¢ ram: B·ªô nh·ªõ", 
                            threadID, messageID
                        );
                    }

                    const equipment = EQUIPMENT_TIERS[type];

                    if (isNaN(tier) || tier < 0 || tier >= equipment.length) {
                        return api.sendMessage("‚ùå C·∫•p ƒë·ªô n√¢ng c·∫•p kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    const upgradeCost = equipment[tier].cost;
                    const balance = await getBalance(senderID);

                    if (balance < upgradeCost) {
                        return api.sendMessage(
                            "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ n√¢ng c·∫•p!\n" +
                            `üí∞ Gi√°: ${upgradeCost.toLocaleString('vi-VN')} Xu\n` +
                            `üí≥ S·ªë d∆∞: ${balance.toLocaleString('vi-VN')} Xu`,
                            threadID, messageID
                        );
                    }

                    const oldTier = user.equipment[type === 'psu' ? 'psu' : type];
                    if (tier <= oldTier) {
                        return api.sendMessage("‚ùå Kh√¥ng th·ªÉ n√¢ng c·∫•p xu·ªëng c·∫•p ƒë·ªô th·∫•p h∆°n!", threadID, messageID);
                    }

                    await updateBalance(senderID, -upgradeCost);
                    user.equipment[type === 'psu' ? 'psu' : type] = tier;
                    saveMiningData(miningData);

                    return api.sendMessage(
                        "üîß N√ÇNG C·∫§P TH√ÄNH C√îNG üîß\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                        `üîÑ ƒê√£ n√¢ng c·∫•p ${type.toUpperCase()} l√™n ${equipment[tier].name}\n` +
                        `üí∞ Chi ph√≠: ${upgradeCost.toLocaleString('vi-VN')} Xu\n\n` +
                        "üìä Ch·ªâ s·ªë hi·ªán t·∫°i:\n" +
                        `‚ö° Mining Power: x${calculateMiningPower(user.equipment).toFixed(2)}\n` +
                        `üîå Chi ph√≠ ƒëi·ªán: x${calculateElectricityCost(user.equipment).toFixed(2)}`,
                        threadID, messageID
                    );

                case "market":
                    let marketMessage = "üìä CRYPTO MARKET üìä\n" + 
                                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                    
                    for (const [symbol, data] of Object.entries(miningData.market)) {
                        const crypto = CRYPTO_TYPES[symbol];
                        marketMessage += `${crypto.name} (${symbol})\n` +
                                    `üí∞ Gi√°: ${Math.floor(data.price).toLocaleString('vi-VN')} Xu\n` +
                                    `üìà Thay ƒë·ªïi: ${data.change >= 0 ? '+' : ''}${data.change.toFixed(2)}%\n\n`;
                    }
                    
                    return api.sendMessage(marketMessage, threadID, messageID);

                case "wallet":
                    const walletBalance = await getBalance(senderID);
                    let walletMessage = "üíº CRYPTO WALLET üíº\n" +
                                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                    `üí∞ Xu trong v√≠: ${walletBalance.toLocaleString('vi-VN')}\n\n` +
                                    "ü™ô t√†i s·∫£n Crypto:\n";
                    
                    for (const [symbol, amount] of Object.entries(user.wallet)) {
                        const value = Math.floor(amount * miningData.market[symbol].price);
                        walletMessage += `${symbol}: ${amount.toFixed(8)} (${value.toLocaleString('vi-VN')} Xu)\n`;
                    }
                    
                    return api.sendMessage(walletMessage, threadID, messageID);

                case "trade":
                    if (!param || !target[2] || !target[3]) {
                        return api.sendMessage(
                            "üìå C√°ch giao d·ªãch:\n" +
                            ".coin trade buy/sell [coin] [amount]\n" +
                            "V√≠ d·ª•: .coin trade buy btc 0.001",
                            threadID, messageID
                        );
                    }

                    const action = param;
                    const coin = target[2].toUpperCase();
                    const amount = parseFloat(target[3]);

                    if (!CRYPTO_TYPES[coin]) {
                        return api.sendMessage("‚ùå Lo·∫°i coin kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    if (isNaN(amount) || amount <= 0) {
                        return api.sendMessage("‚ùå S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    const price = miningData.market[coin].price;
                    const total = Math.floor(price * amount);
                    const fee = Math.floor(total * 0.01); 

                    if (action === "buy") {
                        const cost = total + fee;
                        const balance = await getBalance(senderID);
                        
                        if (balance < cost) {
                            return api.sendMessage(
                                "‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß!\n" +
                                `üí∞ C·∫ßn: ${cost.toLocaleString('vi-VN')} Xu\n` +
                                `üí≥ Hi·ªán c√≥: ${balance.toLocaleString('vi-VN')} Xu`,
                                threadID, messageID
                            );
                        }

                        await updateBalance(senderID, -cost);
                        user.wallet[coin] += amount;
                        saveMiningData(miningData);

                        return api.sendMessage(
                            "üõí MUA COIN TH√ÄNH C√îNG üõí\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                            `ü™ô Coin: ${coin}\n` +
                            `üìà S·ªë l∆∞·ª£ng: ${amount.toFixed(8)}\n` +
                            `üí∞ Gi√°: ${total.toLocaleString('vi-VN')} Xu\n` +
                            `üí∏ Ph√≠: ${fee.toLocaleString('vi-VN')} Xu\n` +
                            `üíµ T·ªïng: ${cost.toLocaleString('vi-VN')} Xu`,
                            threadID, messageID
                        );

                    } else if (action === "sell") {
                        if (user.wallet[coin] < amount) {
                            return api.sendMessage(
                                "‚ùå S·ªë d∆∞ coin kh√¥ng ƒë·ªß!\n" +
                                `ü™ô C·∫ßn: ${amount.toFixed(8)} ${coin}\n` +
                                `üí≥ Hi·ªán c√≥: ${user.wallet[coin].toFixed(8)} ${coin}`,
                                threadID, messageID
                            );
                        }

                        user.wallet[coin] -= amount;
                        const receive = total - fee;
                        await updateBalance(senderID, receive);
                        saveMiningData(miningData);

                        return api.sendMessage(
                            "üí± B√ÅN COIN TH√ÄNH C√îNG üí±\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                            `ü™ô Coin: ${coin}\n` +
                            `üìâ S·ªë l∆∞·ª£ng: ${amount.toFixed(8)}\n` +
                            `üí∞ Gi√°: ${total.toLocaleString('vi-VN')} Xu\n` +
                            `üí∏ Ph√≠: ${fee.toLocaleString('vi-VN')} Xu\n` +
                            `üíµ Nh·∫≠n: ${receive.toLocaleString('vi-VN')} Xu`,
                            threadID, messageID
                        );
                    }
                    break;

                default:
                    return api.sendMessage(
                        "üéÆ H∆Ø·ªöNG D·∫™N CHI TI·∫æT H·ªÜ TH·ªêNG ƒê√ÄO COIN üéÆ\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "1Ô∏è‚É£ C√ÅCH ƒê√ÄO COIN:\n" +
                        "‚Ä¢ L·ªánh: .coin mine\n" +
                        "‚Ä¢ Th·ªùi gian ch·ªù: 5 gi√¢y/l·∫ßn\n" +
                        "‚Ä¢ Gi·ªõi h·∫°n: 1000 l·∫ßn/ng√†y\n" +
                        "‚Ä¢ Thu nh·∫≠p ph·ª• thu·ªôc v√†o thi·∫øt b·ªã\n\n" +
                        "2Ô∏è‚É£ N√ÇNG C·∫§P THI·∫æT B·ªä:\n" +
                        "‚Ä¢ Xem shop: .coin shop\n" +
                        "‚Ä¢ N√¢ng c·∫•p: .coin upgrade [lo·∫°i] [c·∫•p]\n" +
                        "‚Ä¢ Lo·∫°i thi·∫øt b·ªã:\n" +
                        "  - gpu: Card ƒë·ªì h·ªça (quan tr·ªçng nh·∫•t)\n" +
                        "  - cooler: T·∫£n nhi·ªát (tƒÉng hi·ªáu su·∫•t)\n" +
                        "  - psu: Ngu·ªìn ƒëi·ªán (·ªïn ƒë·ªãnh h·ªá th·ªëng)\n" +
                        "  - motherboard: Bo m·∫°ch ch·ªß (tƒÉng t·ªïng th·ªÉ)\n" +
                        "  - ram: B·ªô nh·ªõ (tƒÉng t·ªëc ƒë·ªô ƒë√†o)\n\n" +
                        "3Ô∏è‚É£ GIAO D·ªäCH COIN:\n" +
                        "‚Ä¢ Xem gi√°: .coin market\n" +
                        "‚Ä¢ Mua coin: .coin trade buy [coin] [s·ªë l∆∞·ª£ng]\n" +
                        "‚Ä¢ B√°n coin: .coin trade sell [coin] [s·ªë l∆∞·ª£ng]\n" +
                        "‚Ä¢ Lo·∫°i coin: BTC, ETH, AKC\n" +
                        "‚Ä¢ Ph√≠ giao d·ªãch: 1%\n\n" +
                        "4Ô∏è‚É£ KI·ªÇM TRA T√ÄI S·∫¢N:\n" +
                        "‚Ä¢ Xem v√≠: .coin wallet\n" +
                        "‚Ä¢ Hi·ªÉn th·ªã:\n" +
                        "  - S·ªë d∆∞ Xu\n" +
                        "  - S·ªë coin ƒëang c√≥\n" +
                        "  - Gi√° tr·ªã quy ƒë·ªïi\n\n" +
                        "üí° M·∫∏O CH∆†I GAME:\n" +
                        "‚Ä¢ ∆Øu ti√™n n√¢ng c·∫•p GPU tr∆∞·ªõc\n" +
                        "‚Ä¢ C√¢n b·∫±ng gi·ªØa c√°c thi·∫øt b·ªã\n" +
                        "‚Ä¢ Theo d√µi gi√° coin ƒë·ªÉ giao d·ªãch\n" +
                        "‚Ä¢ T√≠ch l≈©y ƒë·ªÉ mua thi·∫øt b·ªã t·ªët\n" +
                        "‚Ä¢ Ch∆°i ƒë·ªÅu ƒë·∫∑n m·ªói ng√†y\n\n" +
                        "‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG:\n" +
                        "‚Ä¢ Chi ph√≠ ƒëi·ªán ƒë∆∞·ª£c tr·ª´ t·ª± ƒë·ªông\n" +
                        "‚Ä¢ M·ª©c ƒëi·ªán tƒÉng theo c·∫•p GPU\n" +
                        "‚Ä¢ Gi√° coin bi·∫øn ƒë·ªông th∆∞·ªùng xuy√™n\n" +
                        "‚Ä¢ N√¢ng c·∫•p thi·∫øt b·ªã ƒë√∫ng th·ª© t·ª±\n",
                        threadID, messageID
                    );
            }
        } catch (error) {
            console.error("Mining Error:", error);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói trong h·ªá th·ªëng mining!", threadID, messageID);
        }
    }
};
