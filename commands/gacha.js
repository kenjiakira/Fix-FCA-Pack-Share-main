const genshin = require("genshin");
const fs = require("fs");
const path = require("path");
const axios = require("axios");
const { getBalance, updateBalance } = require("../utils/currencies");
const { createPullResultImage, createStoneResultImage } = require("../canvas/gachaCanvas");

const GACHA_DATA_FILE = path.join(__dirname, "./json/gacha/gacha.json");
const PULL_COST = 1000;
const AUCTION_DURATION = 3600000;
const PULL_COOLDOWN = 15;

let gachaData = {};

const activePvpChallenges = new Map();
const PVP_CHALLENGE_DURATION = 300000;
const PVP_COOLDOWN = 60000; 
const PVP_REWARD_WIN = 2000;
const PVP_REWARD_LOSE = 500; 

const CHARACTERS_DB_FILE = path.join(__dirname, "./json/gacha/characters_db.json");

const ELEMENT_ADVANTAGES = {
  Pyro: ["Cryo", "Dendro"],
  Hydro: ["Pyro", "Geo"],
  Electro: ["Hydro", "Anemo"],
  Cryo: ["Hydro", "Electro"],
  Dendro: ["Hydro", "Geo"],
  Geo: ["Electro", "Anemo"],
  Anemo: ["Cryo", "Dendro"],
};
const CUSTOM_CHARACTER_IMAGES = {
  "Raiden Shogun": "https://imgur.com/2l5q6Ib.png",
  Noelle: "https://imgur.com/HvhzDne.png",
  Xinyan: "https://imgur.com/KBX3syb.png",
  Barbara: "https://imgur.com/4C9Dsl0.png",
  Rosaria: "https://imgur.com/OEt1mvT.png",
  Thoma: "https://imgur.com/wGUtE3a.png",
  Faruzan: "https://imgur.com/5rbs7lf.png",
  Gorou: "https://imgur.com/8WFB75F.png",
  Mika: "https://imgur.com/rkihX4u.png",
  Lisa: "https://imgur.com/WyX41nu.png",
  "Kuki Shinobu": "https://imgur.com/QB2OkkW.png",
  Freminet: "https://imgur.com/fh2TcW7.png",
  Tighnari: "https://imgur.com/xVR5BRG.png",
  Hutao: "https://imgur.com/9tuCA1v.png",
  Yelan: "https://imgur.com/oiNOdqD.png",
  Furina: "https://imgur.com/Ovo2GXz.png",
  "Yae Miko": "https://imgur.com/dWz5xym.png",
  Nahida: "https://imgur.com/uvEyzJy.png",
  Bennett: "https://imgur.com/D8uVCcI.png",
  Yanfei: "https://imgur.com/3UE1s1o.png",
  Sayu: "https://imgur.com/sThH2Zu.png",
  Dori: "https://imgur.com/JEmUtJP.png",
  Candace: "https://imgur.com/xEzeWbs.png",
  "Kujou Sara": "https://imgur.com/NglMvgC.png",
  Layla: "https://imgur.com/bG3ksud.png",
  Collei: "https://imgur.com/m7TsSPK.png",
  Diona: "https://imgur.com/iPKtes1.png",
  Dehya: "https://imgur.com/7tTNdEd.png",
  Ganyu: "https://imgur.com/UNUpMCd",
  Kaveh: "https://imgur.com/9rragrx.png",
  Eula: "https://imgur.com/MUErJTP.png",
  Shenhe: "https://imgur.com/Hxr7cpc.png",
  "Cyno": "https://imgur.com/mLPFGAL.png",
};

const CUSTOM_CHARACTER_DATA = {
  "Raiden Shogun": {
    weapon: "Polearm",
    element: "Electro",
    skills: ["Transcendence: Baleful Omen", "Secret Art: Musou Shinsetsu"],
    quote: "Inazuma Shines Eternal",
  },
  Freminet: {
    weapon: "Claymore",
    element: "Cryo",
    skills: ["Pressurized Floe", "Shadowhunter‚Äôs Ambush"],
    quote: "I will protect you.",
  },
  Noelle: {
    weapon: "Claymore",
    element: "Geo",
    skills: ["Breastplate", "Sweeping Time"],
    quote: "Leave it to me!",
  },
  Xinyan: {
    weapon: "Claymore",
    element: "Pyro",
    skills: ["Sweeping Fervor", "Riff Revolution"],
    quote: "Rock and roll!",
  },
  Barbara: {
    weapon: "Catalyst",
    element: "Hydro",
    skills: ["Let the Show Begin", "Shining Miracle"],
    quote: "Ready for your big entrance!",
  },
  Rosaria: {
    weapon: "Polearm",
    element: "Cryo",
    skills: ["Ravaging Confession", "Rites of Termination"],
    quote: "Judgment has come.",
  },
  Thoma: {
    weapon: "Polearm",
    element: "Pyro",
    skills: ["Blazing Blessing", "Crimson Ooyoroi"],
    quote: "I'll do my best.",
  },
  Faruzan: {
    weapon: "Bow",
    element: "Anemo",
    skills: ["Wind Realm of Nasamjnin", "The Wind‚Äôs Secret Ways"],
    quote: "I will protect you.",
  },
  Gorou: {
    weapon: "Bow",
    element: "Geo",
    skills: ["Inuzaka All-Round Defense", "Juuga: Forward Unto Victory"],
    quote: "I am here to serve.",
  },
  Mika: {
    weapon: "Polearm",
    element: "Cryo",
    skills: ["Starfrost Swirl", "Skyfeather Song"],
    quote: "I will fight for you.",
  },
  "Kuki Shinobu": {
    weapon: "Sword",
    element: "Electro",
    skills: ["Sanctifying Ring", "Goei Narukami Kariyama Rite"],
    quote: "I will protect my friends.",
  },
  Tighnari: {
    weapon: "Bow",
    element: "Dendro",
    skills: ["Vijnana-Phala Mine", "Fashioner‚Äôs Tanglevine Shaft"],
    quote: "I will protect you.",
  },
  Hutao: {
    weapon: "Polearm",
    element: "Pyro",
    skills: ["Guide to Afterlife", "Spirit Soother"],
    quote: "Life is but a fleeting dream.",
  },
  Yelan: {
    weapon: "Bow",
    element: "Hydro",
    skills: ["Lingering Lifeline", "Depth-Clarion Dice"],
    quote: "Truth is just a matter of perspective.",
  },
  Furina: {
    weapon: "Sword",
    element: "Hydro",
    skills: ["Salon Solitaire", "Let the People Rejoice"],
    quote: "All the world's a stage, and all the men and women merely players.",
  },
  "Yae Miko": {
    weapon: "Catalyst",
    element: "Electro",
    skills: [
      "Yakan Evocation: Sesshou Sakura",
      "Great Secret Art: Tenko Kenshin",
    ],
    quote: "The Kitsune Saiguu watches over us.",
  },
  Nahida: {
    weapon: "Catalyst",
    element: "Dendro",
    skills: ["All Schemes to Know", "Illusory Heart"],
    quote: "Let me show you the wisdom of Sumeru.",
  },
  Bennett: {
    weapon: "Sword",
    element: "Pyro",
    skills: ["Passion Overload", "Fantastic Voyage"],
    quote: "Leave it to me!",
  },
  Yanfei: {
    weapon: "Catalyst",
    element: "Pyro",
    skills: ["Signed Edict", "Done Deal"],
    quote: "I will protect you.",
  },
  Sayu: {
    weapon: "Claymore",
    element: "Anemo",
    skills: ["Yoohoo Art: Fuuin Dash", "Yoohoo Art: Mujina Flurry"],
    quote: "Nap time...",
  },
  Dori: {
    weapon: "Claymore",
    element: "Electro",
    skills: [
      "Spirit-Warding Lamp: Troubleshooter Cannon",
      "Alcazarzaray‚Äôs Exactitude",
    ],
    quote: "How may I be of service?",
  },
  Candace: {
    weapon: "Polearm",
    element: "Hydro",
    skills: ["Sacred Rite: Heron‚Äôs Sanctum", "Sacred Rite: Wagtail‚Äôs Tide"],
    quote: "We tread upon a land cloaked in shadow.",
  },
  "Kujou Sara": {
    weapon: "Bow",
    element: "Electro",
    skills: ["Tengu Stormcall", "Subjugation: Koukou Sendou"],
    quote: "The will of the Shogun guides us onward.",
  },
  Layla: {
    weapon: "Sword",
    element: "Cryo",
    skills: ["Nights of Formal Focus", "Dream of the Star-Stream Shaker"],
    quote: "Dreams are but waypoints in the night sky.",
  },
  Collei: {
    weapon: "Bow",
    element: "Dendro",
    skills: ["Floral Brush", "Trump-Card Kitty"],
    quote: "The forest will always be my home.",
  },
  Diona: {
    weapon: "Bow",
    element: "Cryo",
    skills: ["Icy Paws", "Signature Mix"],
    quote: "You better not spill that drink!",
  },
  Dehya: {
    weapon: "Claymore",
    element: "Pyro",
    skills: ["Molten Inferno", "The Lioness' Bite"],
    quote: "Survival of the fittest!",
  },
  Kaveh: {
    weapon: "Claymore",
    element: "Dendro",
    skills: ["Artistic Ingenuity", "Painted Dome"],
    quote: "True beauty lies in the details.",
  },
  Shenhe: {
    weapon: "Polearm",
    element: "Cryo",
    skills: ["Cleansing Brilliance", "Purity‚Äôs Radiance"],
    quote: "I will protect you.",
  },
  Ganyu: {
    weapon: "Bow",
    element: "Cryo",
    skills: ["Trail of the Qilin", "Celestial Shower"],
    quote: "I will protect you.",
  },
  Cyno: {
    weapon: "Polearm",
    element: "Hydro",
    skills: ["Secret Rite: Chasmic Soulfarer", "Sacred Rite: Wolf‚Äôs Swiftness"],
    quote: "I will protect you.",
  },
};

const RATES = {
  FIVE_STAR: 0.001,
  FOUR_STAR: 15,
  THREE_STAR: 84.999,
};

const CHARACTER_RATINGS = {
  FIVE_STAR: [
    "Cyno",
    "Diluc",
    "Jean",
    "Keqing",
    "Klee",
    "Mona",
    "Qiqi",
    "Shenhe",
    "Xiao",
    "Tighnari",
    "Hutao",
    "Yelan",
    "Furina",
    "Zhongli",
    "Eula",
    "Ganyu",
    "Ayaka",
    "Venti",
    "Raiden Shogun",
    "Yae Miko",
    "Nahida",
  ],
  FOUR_STAR: [
    "Beidou",
    "Bennett",
    "Candace",
    "Chongyun",
    "Layla",
    "Fischl",
    "Ningguang",
    "Razor",
    "Sucrose",
    "Yanfei",
    "Kujou Sara",
    "Rosaria",
    "Sayu",
    "Dori",
    "Thoma",
    "Xiangling",
    "Xingqiu",
    "Kuki Shinobu",
    "Freminet",
  ],
  THREE_STAR: [
    "Kaveh",
    "Dehya",
    "Diona",
    "Collei",
    "Amber",
    "Kaeya",
    "Lisa",
    "Xinyan",
    "Barbara",
    "Noelle",
    "Faruzan",
    "Gorou",
    "Mika",
  ],
};

const PREMIUM_FIVE_STARS = [
  "Zhongli",
  "Ganyu",
  "Ayaka",
  "Raiden Shogun",
  "Yae Miko",
];
const ELEMENTAL_STONES = {
  PYRO: {
    name: "Agnidus Agate",
    element: "Pyro",
    description: "Ascension stone for Pyro characters",
    emoji: "üî•",
    image: "https://imgur.com/J0J2lfG.png",
    value: 25000,
  },
  HYDRO: {
    name: "Varunada Lazurite",
    element: "Hydro",
    description: "Ascension stone for Hydro characters",
    emoji: "üíß",
    image: "https://imgur.com/Wr8Udzy.png",
    value: 25000,
  },
  ELECTRO: {
    name: "Vajrada Amethyst",
    element: "Electro",
    description: "Ascension stone for Electro characters",
    emoji: "‚ö°",
    image: "https://imgur.com/iJr7tkQ.png",
    value: 25000,
  },
  CRYO: {
    name: "Shivada Jade",
    element: "Cryo",
    description: "Ascension stone for Cryo characters",
    emoji: "‚ùÑÔ∏è",
    image: "https://imgur.com/k7PooZ5.png",
    value: 25000,
  },
  DENDRO: {
    name: "Nagadus Emerald",
    element: "Dendro",
    description: "Ascension stone for Dendro characters",
    emoji: "üåø",
    image: "https://imgur.com/YqWMMHO.png",
    value: 25000,
  },
  GEO: {
    name: "Prithiva Topaz",
    element: "Geo",
    description: "Ascension stone for Geo characters",
    emoji: "ü™®",
    image: "https://imgur.com/LCLoXOH.png",
    value: 25000,
  },
  ANEMO: {
    name: "Vayuda Turquoise",
    element: "Anemo",
    description: "Ascension stone for Anemo characters",
    emoji: "üå™Ô∏è",
    image: "https://imgur.com/puantrR.png",
    value: 25000,
  },
  UNIVERSAL: {
    name: "Brilliant Diamond",
    element: "Universal",
    description: "Universal ascension stone for any character",
    emoji: "üíé",
    image: "https://imgur.com/oy8zBkt.png",
    value: 500000,
  },
};

const ELEMENTAL_FRAGMENTS = {
  PYRO: {
    name: "Agnidus Agate Fragment",
    element: "Pyro",
    description: "Pyro evolution fragment",
    emoji: "üî•",
    image: "https://imgur.com/Ec9w0A3.png",
    value: 2500,
    isFragment: true
  },
  HYDRO: {
    name: "Varunada Lazurite Fragment",
    element: "Hydro",
    description: "Hydro evolution fragment",
    emoji: "üíß",
    image: "https://imgur.com/xUQZRMt.png",
    value: 2500,
    isFragment: true
  },
  ELECTRO: {
    name: "Vajrada Amethyst Fragment",
    element: "Electro",
    description: "Electro evolution fragment",
    emoji: "‚ö°",
    image: "https://imgur.com/JxRxK1i.png",
    value: 2500,
    isFragment: true
  },
  CRYO: {
    name: "Shivada Jade Fragment",
    element: "Cryo",
    description: "Cryo evolution fragment",
    emoji: "‚ùÑÔ∏è",
    image: "https://imgur.com/tU6KMBs.png",
    value: 2500,
    isFragment: true
  },
  DENDRO: {
    name: "Nagadus Emerald Fragment",
    element: "Dendro",
    description: "Dendro evolution fragment",
    emoji: "üåø",
    image: "https://imgur.com/uVp1eNU.png",
    value: 2500,
    isFragment: true
  },
  GEO: {
    name: "Prithiva Topaz Fragment",
    element: "Geo",
    description: "Geo evolution fragment",
    emoji: "ü™®",
    image: "https://imgur.com/vAfAFli.png",
    value: 2500,
    isFragment: true
  },
  ANEMO: {
    name: "Vayuda Turquoise Fragment",
    element: "Anemo",
    description: "Anemo evolution fragment",
    emoji: "üå™Ô∏è",
    image: "https://imgur.com/tl1G3g6.png",
    value: 2500,
    isFragment: true
  },
  UNIVERSAL: {
    name: "Brilliant Diamond Fragment",
    element: "Universal",
    description: "Universal evolution fragment",
    emoji: "üíé",
    image: "https://imgur.com/8BQY2FS.png",
    value: 50000,
    isFragment: true
  },
};


let CHARACTER_IDS = {};
let nextCharId = 1;

const activeAuctions = new Map();
const activeTrades = new Map();

const CHARACTER_LEVELS = {
  4: {
    baseStats: { atk: 1.2, def: 1.2, hp: 1.2 },
    maxLevel: 10,
  },
  5: {
    baseStats: { atk: 1.5, def: 1.5, hp: 1.5 },
    maxLevel: 12,
  },
};
function findCharacterInfo(gachaData, charId) {
  return null;
}
function generateStoneId(stoneType) {
  let stoneId;
  do {
    const randomId = Math.floor(100000000 + Math.random() * 900000000);
    stoneId = `STONE_${stoneType}_${randomId}`;
  } while (CHARACTER_IDS[stoneId]);
  return stoneId;
}

function createStone(stoneType) {
  const stoneId = generateStoneId(stoneType);
  CHARACTER_IDS[stoneId] = {
    type: "stone",
    stoneType: stoneType,
    name: ELEMENTAL_STONES[stoneType].name,
    element: ELEMENTAL_STONES[stoneType].element,
    emoji: ELEMENTAL_STONES[stoneType].emoji,
    description: ELEMENTAL_STONES[stoneType].description,
    image: ELEMENTAL_STONES[stoneType].image,
    obtainedAt: Date.now(),
    value: ELEMENTAL_STONES[stoneType].value,
  };
  saveCharacterDatabase();
  return stoneId;
}
function cleanupInventory(userData) {

  const originalCount = userData.inventory.length;
  const originalInventory = [...userData.inventory];
  
  console.log("üîç DEBUG: Checking inventory items...");

  originalInventory.forEach((charId) => {
    const char = CHARACTER_IDS[charId];
    if (!char) {
      console.log(`Warning: Character ${charId} info not found`);
      return;
    }

    if (CHARACTER_RATINGS.THREE_STAR.includes(char.name)) {
      console.log(`3‚òÖ character: ${char.name} (${charId})`);
    } else if (CHARACTER_RATINGS.FOUR_STAR.includes(char.name)) {
      console.log(`4‚òÖ character: ${char.name} (${charId})`);
    } else if (CHARACTER_RATINGS.FIVE_STAR.includes(char.name)) {
      console.log(`5‚òÖ character: ${char.name} (${charId})`);
    } else if (charId.startsWith("STONE_")) {
      console.log(`Stone: ${char.name} (${charId})`);
    }
  });

  return 0; 
}
function generateCharacterId(characterName) {
  let charId;
  do {
    const randomId = Math.floor(100000000 + Math.random() * 900000000);
    charId = `CHAR_${randomId}`;
  } while (CHARACTER_IDS[charId]);
  return charId;
}

function guessCharacterName(charId) {
  const allChars = [
    ...CHARACTER_RATINGS.FIVE_STAR,
    ...CHARACTER_RATINGS.FOUR_STAR,
    ...CHARACTER_RATINGS.THREE_STAR,
  ];

  const id = parseInt(charId.replace("CHAR", "")) % allChars.length;
  return allChars[id];
}
// H√†m t√≠nh s·ª©c m·∫°nh c·ªßa nh√¢n v·∫≠t
function calculateCharacterPower(charId) {
  const char = CHARACTER_IDS[charId];
  if (!char) return 0;
  
  // L·∫•y c√°c ch·ªâ s·ªë c∆° b·∫£n
  const stats = char.stats || { atk: 100, def: 100, hp: 500 };
  const level = char.level || 1;
  const stars = char.starLevel || (CHARACTER_RATINGS.FIVE_STAR.includes(char.name) ? 5 : 
                                   CHARACTER_RATINGS.FOUR_STAR.includes(char.name) ? 4 : 3);
  
  // T√≠nh s·ª©c m·∫°nh c∆° b·∫£n
  let power = (stats.atk * 2 + stats.def + stats.hp / 10) * (level / 5);
  
  // Th√™m h·ªá s·ªë sao
  power *= (1 + (stars - 3) * 0.5);
  
  // Nh√¢n v·∫≠t premium m·∫°nh h∆°n m·ªôt ch√∫t
  if (PREMIUM_FIVE_STARS.includes(char.name)) {
    power *= 1.2;
  }
  
  return Math.floor(power);
}

// H√†m t√≠nh s·ª©c m·∫°nh c·ªßa ƒë·ªôi
function calculateTeamPower(teamIds) {
  let totalPower = 0;
  for (const charId of teamIds) {
    totalPower += calculateCharacterPower(charId);
  }
  return totalPower;
}

// H√†m √°p d·ª•ng t∆∞∆°ng kh·∫Øc nguy√™n t·ªë
function applyElementalAdvantage(attackerTeam, defenderTeam) {
  let advantageMultiplier = 1.0;
  
  // T√¨m c√°c t∆∞∆°ng kh·∫Øc nguy√™n t·ªë
  for (const attackerId of attackerTeam) {
    const attacker = CHARACTER_IDS[attackerId];
    if (!attacker) continue;
    
    const attackerElement = CUSTOM_CHARACTER_DATA[attacker.name]?.element;
    if (!attackerElement) continue;
    
    for (const defenderId of defenderTeam) {
      const defender = CHARACTER_IDS[defenderId];
      if (!defender) continue;
      
      const defenderElement = CUSTOM_CHARACTER_DATA[defender.name]?.element;
      if (!defenderElement) continue;
      
      if (ELEMENT_ADVANTAGES[attackerElement]?.includes(defenderElement)) {
        // TƒÉng h·ªá s·ªë l·ª£i th·∫ø cho m·ªói t∆∞∆°ng kh·∫Øc t√¨m th·∫•y
        advantageMultiplier += 0.1;
      }
    }
  }
  
  return advantageMultiplier;
}

// H√†m t·∫°o th√°ch ƒë·∫•u PVP
function createPvpChallenge(challengerId, targetId, challengerTeam) {
  const challengeId = `PVP_${challengerId}_${targetId}_${Date.now()}`;
  
  activePvpChallenges.set(challengeId, {
    challenger: challengerId,
    target: targetId,
    challengerTeam: challengerTeam,
    timestamp: Date.now(),
    expiry: Date.now() + PVP_CHALLENGE_DURATION
  });
  
  return challengeId;
}

async function executePvpBattle(api, threadID, messageID, challengeData, targetTeam) {
  const challenger = challengeData.challenger;
  const target = challengeData.target;
  const challengerTeam = challengeData.challengerTeam;
  
  const challengerPower = calculateTeamPower(challengerTeam);
  const targetPower = calculateTeamPower(targetTeam);
  
  const challengerAdvantage = applyElementalAdvantage(challengerTeam, targetTeam);
  const targetAdvantage = applyElementalAdvantage(targetTeam, challengerTeam);
  
  const finalChallengerPower = challengerPower * challengerAdvantage;
  const finalTargetPower = targetPower * targetAdvantage;
  
  const totalPower = finalChallengerPower + finalTargetPower;
  const challengerWinRate = (finalChallengerPower / totalPower) * 100;
  
  const randomFactor = Math.random() * 30 - 15; 
  const adjustedWinRate = Math.max(5, Math.min(95, challengerWinRate + randomFactor)); // Gi·ªõi h·∫°n t·ª´ 5% ƒë·∫øn 95%
  
  const roll = Math.random() * 100;
  const challengerWins = roll < adjustedWinRate;
  
  const gachaData = loadGachaData();
  
  if (!gachaData[challenger].pvpStats) {
    gachaData[challenger].pvpStats = { wins: 0, losses: 0, lastBattle: 0 };
  }
  
  if (!gachaData[target].pvpStats) {
    gachaData[target].pvpStats = { wins: 0, losses: 0, lastBattle: 0 };
  }
  
  if (challengerWins) {
    gachaData[challenger].pvpStats.wins++;
    gachaData[target].pvpStats.losses++;
    await updateBalance(challenger, PVP_REWARD_WIN);
    await updateBalance(target, PVP_REWARD_LOSE);
  } else {
    gachaData[challenger].pvpStats.losses++;
    gachaData[target].pvpStats.wins++;
    await updateBalance(challenger, PVP_REWARD_LOSE);
    await updateBalance(target, PVP_REWARD_WIN);
  }
  
  gachaData[challenger].pvpStats.lastBattle = Date.now();
  gachaData[target].pvpStats.lastBattle = Date.now();
  
  saveGachaData(gachaData);
  
  const userDataPath = path.join(__dirname, "../events/cache/userData.json");
  let userData = {};
  
  try {
    userData = JSON.parse(fs.readFileSync(userDataPath));
  } catch (error) {
    console.error("Error reading userData:", error);
  }
  
  const challengerName = userData[challenger]?.name || "Ng∆∞·ªùi ch∆°i 1";
  const targetName = userData[target]?.name || "Ng∆∞·ªùi ch∆°i 2";
  
  // T·∫°o th√¥ng tin ƒë·ªôi h√¨nh
  const challengerTeamInfo = await formatTeamInfo(challengerTeam);
  const targetTeamInfo = await formatTeamInfo(targetTeam);
  
  // T·∫°o th√¥ng b√°o k·∫øt qu·∫£
  let resultMessage = `‚öîÔ∏è K·∫æT QU·∫¢ TR·∫¨N ƒê·∫§U PVP ‚öîÔ∏è\n`;
  resultMessage += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
  
  resultMessage += `üë§ ${challengerName}:\n`;
  resultMessage += `${challengerTeamInfo}\n`;
  resultMessage += `üí™ S·ª©c m·∫°nh: ${challengerPower} (x${challengerAdvantage.toFixed(1)} nguy√™n t·ªë)\n`;
  resultMessage += `‚öîÔ∏è S·ª©c m·∫°nh th·ª±c: ${Math.floor(finalChallengerPower)}\n\n`;
  
  resultMessage += `üë§ ${targetName}:\n`;
  resultMessage += `${targetTeamInfo}\n`;
  resultMessage += `üí™ S·ª©c m·∫°nh: ${targetPower} (x${targetAdvantage.toFixed(1)} nguy√™n t·ªë)\n`;
  resultMessage += `‚öîÔ∏è S·ª©c m·∫°nh th·ª±c: ${Math.floor(finalTargetPower)}\n\n`;
  
  resultMessage += `üé≤ T·ª∑ l·ªá th·∫Øng: ${adjustedWinRate.toFixed(1)}% vs ${(100 - adjustedWinRate).toFixed(1)}%\n`;
  resultMessage += `üéØ K·∫øt qu·∫£ roll: ${roll.toFixed(1)} (C·∫ßn < ${adjustedWinRate.toFixed(1)}% ƒë·ªÉ th·∫Øng)\n`;
  resultMessage += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
  
  if (challengerWins) {
    resultMessage += `üèÜ NG∆Ø·ªúI TH·∫ÆNG: ${challengerName}\n`;
    resultMessage += `üí∞ Ph·∫ßn th∆∞·ªüng: $${PVP_REWARD_WIN.toLocaleString()}\n`;
    resultMessage += `üí∞ ${targetName} nh·∫≠n: $${PVP_REWARD_LOSE.toLocaleString()} (an ·ªßi)`;
  } else {
    resultMessage += `üèÜ NG∆Ø·ªúI TH·∫ÆNG: ${targetName}\n`;
    resultMessage += `üí∞ Ph·∫ßn th∆∞·ªüng: $${PVP_REWARD_WIN.toLocaleString()}\n`;
    resultMessage += `üí∞ ${challengerName} nh·∫≠n: $${PVP_REWARD_LOSE.toLocaleString()} (an ·ªßi)`;
  }
  
  return api.sendMessage(resultMessage, threadID, messageID);
}

async function formatTeamInfo(teamIds) {
  let result = "";
  
  for (let i = 0; i < teamIds.length; i++) {
    const charId = teamIds[i];
    const char = CHARACTER_IDS[charId];
    if (!char) continue;
    
    const stars = char.starLevel || (CHARACTER_RATINGS.FIVE_STAR.includes(char.name) ? 5 : 
                                     CHARACTER_RATINGS.FOUR_STAR.includes(char.name) ? 4 : 3);
    
    const starsText = "‚≠ê".repeat(Math.min(5, stars)) + (stars > 5 ? ` [${stars}‚òÖ]` : "");
    const level = char.level || 1;
    const charInfo = CUSTOM_CHARACTER_DATA[char.name] || {};
    const element = charInfo.element || "Unknown";
    
    result += `${i+1}. ${char.name} ${starsText} Lv${level} (${element})\n`;
  }
  
  if (result === "") {
    result = "Kh√¥ng c√≥ nh√¢n v·∫≠t n√†o";
  }
  
  return result;
}
function initializeCharacterIds(gachaData) {
  try {
    nextCharId = 1;

    for (const userId in gachaData) {
      const userData = gachaData[userId];
      if (!userData?.inventory || !Array.isArray(userData.inventory)) continue;

      for (let i = 0; i < userData.inventory.length; i++) {
        const charId = userData.inventory[i];

        if (!charId) continue;

        if (typeof charId !== "string") {
          userData.inventory[i] = `CHAR${charId}`;
          continue;
        }
        if (!charId.startsWith("CHAR")) {
          userData.inventory[i] = `CHAR${charId}`;
        }

        const normalizedCharId = userData.inventory[i];
        if (!CHARACTER_IDS[normalizedCharId]) {
          const charInfo = findCharacterInfo(gachaData, normalizedCharId);

          if (charInfo) {
            CHARACTER_IDS[normalizedCharId] = charInfo;
          } else {
            const possibleName = guessCharacterName(normalizedCharId);
            CHARACTER_IDS[normalizedCharId] = {
              name:
                possibleName ||
                `Unknown Character ${normalizedCharId.replace("CHAR", "")}`,
              obtainedAt: Date.now(),
              value: 500,
            };
          }
        }

        // C·∫≠p nh·∫≠t nextCharId
        const numericId = parseInt(normalizedCharId.replace("CHAR", ""));
        if (!isNaN(numericId) && numericId >= nextCharId) {
          nextCharId = numericId + 1;
        }
      }
    }

    console.log(
      `Successfully initialized ${Object.keys(CHARACTER_IDS).length} characters`
    );
  } catch (error) {
    console.error("Error initializing character IDs:", error);
  }
}
function createStoneFragment(stoneType) {
  const fragmentId = generateFragmentId(stoneType);
  CHARACTER_IDS[fragmentId] = {
    type: "fragment",
    stoneType: stoneType,
    name: ELEMENTAL_FRAGMENTS[stoneType].name,
    element: ELEMENTAL_FRAGMENTS[stoneType].element,
    emoji: ELEMENTAL_FRAGMENTS[stoneType].emoji,
    description: ELEMENTAL_FRAGMENTS[stoneType].description,
    image: ELEMENTAL_FRAGMENTS[stoneType].image,
    obtainedAt: Date.now(),
    value: ELEMENTAL_FRAGMENTS[stoneType].value,
    isFragment: true
  };
  saveCharacterDatabase();
  return fragmentId;
}

// H√†m t·∫°o ID cho m·∫£nh ƒë√°
function generateFragmentId(stoneType) {
  let fragmentId;
  do {
    const randomId = Math.floor(100000000 + Math.random() * 900000000);
    fragmentId = `FRAGMENT_${stoneType}_${randomId}`;
  } while (CHARACTER_IDS[fragmentId]);
  return fragmentId;
}
function validateInventories(gachaData) {

  if (Object.keys(CHARACTER_IDS).length === 0) {
    console.log("WARNING: CHARACTER_IDS is empty, skipping validation");
    return 0; 
  }

  let totalFixed = 0;

  for (const userId in gachaData) {
    const userData = gachaData[userId];
    if (!userData?.inventory || !Array.isArray(userData.inventory)) continue;

    const beforeCount = userData.inventory.length;

    const invalidIds = userData.inventory.filter((id) => !CHARACTER_IDS[id]);
    if (invalidIds.length > 0) {

      userData.inventory = userData.inventory.filter((id) => CHARACTER_IDS[id]);
      totalFixed += invalidIds.length;
    }
  }

  if (totalFixed > 0) {
    console.log(`Fixed ${totalFixed} invalid character references`);
    saveGachaData(gachaData);
  }
  
  return totalFixed;
}
function loadGachaData() {
  try {
    loadCharacterDatabase();

    if (!fs.existsSync(GACHA_DATA_FILE)) {
      const dir = path.dirname(GACHA_DATA_FILE);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(GACHA_DATA_FILE, JSON.stringify({}));
      return {};
    }
    const data = JSON.parse(fs.readFileSync(GACHA_DATA_FILE));
    
    gachaData = data;
    
    return data;
  } catch (error) {
    console.error("Error loading gacha data:", error);
    return {};
  }
}
function verifyInventory(userId) {
  try {
    const fileData = JSON.parse(fs.readFileSync(GACHA_DATA_FILE));
    const fileInventory = fileData[userId]?.inventory || [];
    
    const memoryData = gachaData[userId]?.inventory || [];
    
    if (JSON.stringify(fileInventory) !== JSON.stringify(memoryData)) {
      console.log(`‚ö†Ô∏è Ph√°t hi·ªán d·ªØ li·ªáu kh√¥ng kh·ªõp cho ng∆∞·ªùi d√πng ${userId}:`);
      console.log(`- File: ${fileInventory.length} items`);
      console.log(`- Memory: ${memoryData.length} items`);
      
      if (memoryData.length > fileInventory.length) {
        fileData[userId].inventory = memoryData;
        fs.writeFileSync(GACHA_DATA_FILE, JSON.stringify(fileData, null, 2));
        console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t file v·ªõi d·ªØ li·ªáu trong b·ªô nh·ªõ`);
      }
      else if (fileInventory.length > memoryData.length) {
        gachaData[userId].inventory = fileInventory;
        console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t b·ªô nh·ªõ v·ªõi d·ªØ li·ªáu t·ª´ file`);
      }
    }
  } catch (error) {
    console.error("Error verifying inventory:", error);
  }
}
function saveGachaData(data) {
  try {
    const tempFile = `${GACHA_DATA_FILE}.tmp`;
    fs.writeFileSync(tempFile, JSON.stringify(data, null, 2));
    fs.renameSync(tempFile, GACHA_DATA_FILE);
    console.log(`ƒê√£ l∆∞u d·ªØ li·ªáu gacha th√†nh c√¥ng`);
  } catch (error) {
    console.error("Error saving gacha data:", error);
  }
}

function createTradeOffer(fromId, toId, offerChar, requestChar) {
  const tradeId = `${fromId}_${toId}_${Date.now()}`;
  activeTrades.set(tradeId, {
    from: fromId,
    to: toId,
    offer: offerChar,
    request: requestChar,
    timestamp: Date.now(),
  });
  return tradeId;
}

function createAuction(sellerId, character, startingBid) {
  const auctionId = `${sellerId}_${Date.now()}`;
  activeAuctions.set(auctionId, {
    seller: sellerId,
    character,
    startingBid,
    currentBid: startingBid,
    highestBidder: null,
    endTime: Date.now() + AUCTION_DURATION,
    bids: [],
  });
  return auctionId;
}

function placeBid(auctionId, bidderId, amount) {
  const auction = activeAuctions.get(auctionId);
  if (!auction) return false;
  if (amount <= auction.currentBid) return false;

  auction.currentBid = amount;
  auction.highestBidder = bidderId;
  auction.bids.push({ bidderId, amount, time: Date.now() });
  return true;
}

function getRandomCharacter(rarity) {
  const pool = CHARACTER_RATINGS[rarity];
  return pool[Math.floor(Math.random() * pool.length)];
}
async function showRanking(api, threadID, messageID, type = "value") {
  try {
    const gachaData = loadGachaData();
    const userDataPath = path.join(__dirname, "../events/cache/userData.json");
    let userData = {};

    try {
      userData = JSON.parse(fs.readFileSync(userDataPath));
    } catch (error) {
      console.error("Error reading userData:", error);
    }

    const playerStats = [];

    for (const [userId, data] of Object.entries(gachaData)) {
      if (!data.inventory || data.inventory.length === 0) continue;

      // T√≠nh to√°n c√°c ch·ªâ s·ªë
      let totalValue = 0;
      let fiveStarCount = 0;
      let fourStarCount = 0;
      let threeStarCount = 0;
      let highestLevel = 0;

      data.inventory.forEach((charId) => {
        const char = CHARACTER_IDS[charId];
        if (!char) return;

        totalValue += char.value || 0;

        if (CHARACTER_RATINGS.FIVE_STAR.includes(char.name)) {
          fiveStarCount++;
        } else if (CHARACTER_RATINGS.FOUR_STAR.includes(char.name)) {
          fourStarCount++;
        } else {
          threeStarCount++;
        }

        const charLevel = char.level || 1;
        if (charLevel > highestLevel) highestLevel = charLevel;
      });

      const userName = userData[userId]?.name || "Unknown";

      playerStats.push({
        userId,
        name: userName,
        totalValue,
        fiveStarCount,
        fourStarCount,
        threeStarCount,
        highestLevel,
        totalPulls: data.totalPulls || 0,
        cardCount: data.inventory.length,
      });
    }

    let sortKey;
    let rankTitle;

    // X√°c ƒë·ªãnh c√°ch s·∫Øp x·∫øp d·ª±a tr√™n lo·∫°i BXH
    switch (type) {
      case "5star":
      case "five":
        sortKey = "fiveStarCount";
        rankTitle = "TOP NG∆Ø·ªúI CH∆†I S·ªû H·ªÆU 5‚òÖ";
        break;
      case "pull":
      case "pulls":
        sortKey = "totalPulls";
        rankTitle = "TOP NG∆Ø·ªúI CH∆†I M·ªû TH·∫∫ NHI·ªÄU NH·∫§T";
        break;
      case "level":
        sortKey = "highestLevel";
        rankTitle = "TOP NG∆Ø·ªúI CH∆†I C√ì NH√ÇN V·∫¨T C·∫§P CAO";
        break;
      case "card":
      case "cards":
        sortKey = "cardCount";
        rankTitle = "TOP NG∆Ø·ªúI CH∆†I C√ì NHI·ªÄU TH·∫∫";
        break;
      case "value":
      default:
        sortKey = "totalValue";
        rankTitle = "TOP NG∆Ø·ªúI CH∆†I GI√ÄU NH·∫§T";
        break;
    }

    // S·∫Øp x·∫øp theo key ƒë√£ ch·ªçn
    playerStats.sort((a, b) => b[sortKey] - a[sortKey]);

    // Gi·ªõi h·∫°n ·ªü top 10
    const topPlayers = playerStats.slice(0, 10);

    // T·∫°o n·ªôi dung message
    let message = `üèÜ ${rankTitle} üèÜ\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;

    topPlayers.forEach((player, index) => {
      const medal =
        index === 0
          ? "ü•á"
          : index === 1
          ? "ü•à"
          : index === 2
          ? "ü•â"
          : `${index + 1}.`;

      let details = "";
      if (sortKey === "totalValue") {
        details = `üí∞ T·ªïng gi√° tr·ªã: $${player.totalValue.toLocaleString()}`;
      } else if (sortKey === "fiveStarCount") {
        details = `‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê: ${player.fiveStarCount} nh√¢n v·∫≠t`;
      } else if (sortKey === "totalPulls") {
        details = `üéÆ ƒê√£ m·ªü: ${player.totalPulls} l·∫ßn`;
      } else if (sortKey === "highestLevel") {
        details = `üëë C·∫•p cao nh·∫•t: ${player.highestLevel}`;
      } else if (sortKey === "cardCount") {
        details = `üÉè S·ªë th·∫ª: ${player.cardCount}`;
      }

      message += `${medal} ${player.name}\n${details}\n\n`;
    });

    message += `üí° Xem BXH kh√°c v·ªõi l·ªánh:\n.gacha bxh [value/5star/pull/level/card]`;

    return api.sendMessage(message, threadID, messageID);
  } catch (error) {
    console.error("Error showing ranking:", error);
    return api.sendMessage(
      "‚ùå ƒê√£ x·∫£y ra l·ªói khi hi·ªÉn th·ªã BXH!",
      threadID,
      messageID
    );
  }
}
async function getCharacterImage(character) {
  try {
    if (CUSTOM_CHARACTER_IMAGES[character]) {
      const cacheDir = path.join(__dirname, "./cache");
      if (!fs.existsSync(cacheDir)) {
        fs.mkdirSync(cacheDir, { recursive: true });
      }

      const imagePath = path.join(cacheDir, `${character.toLowerCase()}.png`);

      try {
        const response = await axios.get(CUSTOM_CHARACTER_IMAGES[character], {
          responseType: "arraybuffer",
          timeout: 5000,
          validateStatus: (status) => status === 200,
        });

        fs.writeFileSync(imagePath, response.data);
        return imagePath;
      } catch (error) {
        console.warn(
          `Failed to fetch custom image for ${character}, falling back to default`
        );
      }
    }

    const defaultImagePath = path.join(
      __dirname,
      "../assets/default_character.png"
    );

    const charInfo =
      CUSTOM_CHARACTER_DATA[character] ||
      (await genshin.characters(character.toLowerCase()).catch(() => null));

    if (!charInfo) {
      return defaultImagePath;
    }

    const cacheDir = path.join(__dirname, "./cache");
    if (!fs.existsSync(cacheDir)) {
      fs.mkdirSync(cacheDir, { recursive: true });
    }

    const imagePath = path.join(cacheDir, `${character.toLowerCase()}.png`);

    try {
      const response = await axios.get(charInfo.image, {
        responseType: "arraybuffer",
        timeout: 5000,
        validateStatus: (status) => status === 200,
      });

      fs.writeFileSync(imagePath, response.data);
      return imagePath;
    } catch (error) {
      console.warn(`Failed to fetch image for ${character}, using default`);
      return defaultImagePath;
    }
  } catch (error) {
    console.error(`Error getting image for ${character}:`, error);
    return null;
  }
}
function restoreFromBackup(date = null) {
  try {
    const backupDir = path.join(__dirname, "./json/backups");
    if (!fs.existsSync(backupDir)) {
      console.log("No backup directory found");
      return false;
    }

    const backups = fs.readdirSync(backupDir);
    if (backups.length === 0) {
      console.log("No backups found");
      return false;
    }

    let backupFile, charactersBackupFile;
    if (date) {
      backupFile = `.json/gacha/gacha_backup_${date}.json`;
      charactersBackupFile = `.json/gacha/characters_backup_${date}.json`;
    } else {
      const gachaBackups = backups.filter(f => f.startsWith('gacha_backup_'));
      const characterBackups = backups.filter(f => f.startsWith('characters_backup_'));
      
      if (gachaBackups.length === 0 || characterBackups.length === 0) {
        console.log("Missing required backup files");
        return false;
      }
      
      backupFile = gachaBackups.sort().reverse()[0];
      charactersBackupFile = characterBackups.sort().reverse()[0];
    }

    const backupPath = path.join(backupDir, backupFile);
    const charactersBackupPath = path.join(backupDir, charactersBackupFile);
    
    if (!fs.existsSync(backupPath) || !fs.existsSync(charactersBackupPath)) {
      console.log(`Backup files not found: ${backupFile}, ${charactersBackupFile}`);
      return false;
    }

    fs.copyFileSync(backupPath, GACHA_DATA_FILE);
    fs.copyFileSync(charactersBackupPath, CHARACTERS_DB_FILE);

    console.log(`Restored from backup: ${backupFile}, ${charactersBackupFile}`);
    
    loadCharacterDatabase();
    return true;
  } catch (error) {
    console.error("Error restoring from backup:", error);
    return false;
  }
}
function calculateDynamicRates(userData) {
  const pullsWithoutFiveStar = userData.pullsSinceLastFiveStar || 0;
  const pullsWithoutFourStar = userData.pullsSinceLastFourStar || 0;

  const fiveStarBoost = Math.min(5, Math.pow(pullsWithoutFiveStar * 0.1, 1.5));

  const fourStarBoost = Math.min(15, Math.pow(pullsWithoutFourStar * 0.2, 1.3));

  const totalPullsBoost = Math.min(1, (userData.totalPulls || 0) * 0.005);

  return {
    FIVE_STAR: RATES.FIVE_STAR + fiveStarBoost + totalPullsBoost,
    FOUR_STAR: RATES.FOUR_STAR + fourStarBoost,
    THREE_STAR:
      100 -
      (RATES.FIVE_STAR + fiveStarBoost + totalPullsBoost) -
      (RATES.FOUR_STAR + fourStarBoost),
  };
}
function saveCharacterDatabase() {
  try {
    fs.writeFileSync(
      CHARACTERS_DB_FILE,
      JSON.stringify(CHARACTER_IDS, null, 2)
    );
    console.log(
      `Saved ${Object.keys(CHARACTER_IDS).length} characters to database`
    );
  } catch (error) {
    console.error("Error saving character database:", error);
  }
}

function loadCharacterDatabase() {
  try {
    if (!fs.existsSync(CHARACTERS_DB_FILE)) {
      console.log("Character database file not found, creating new one");
      saveCharacterDatabase();
      return;
    }

    const data = JSON.parse(fs.readFileSync(CHARACTERS_DB_FILE));
    CHARACTER_IDS = data;
    
    console.log(`Loaded ${Object.keys(CHARACTER_IDS).length} characters from database`);
    
    const keys = Object.keys(CHARACTER_IDS);
    if (keys.length > 0) {
      const sample = keys.slice(0, Math.min(3, keys.length));
      sample.forEach(id => {
        console.log(`Sample character: ${id} - ${CHARACTER_IDS[id]?.name || 'Unknown'}`);
      });
    }
  } catch (error) {
    console.error("Error loading character database:", error);
    CHARACTER_IDS = {};
  }
}
function generateCardValue(rarity, characterName) {
  if (rarity === "FIVE_STAR") {
    if (PREMIUM_FIVE_STARS.includes(characterName)) {
      return Math.floor(Math.random() * 500000000) + 100000000;
    }
    return Math.floor(Math.random() * 2000000) + 1000000;
  }
  if (rarity === "FOUR_STAR") {
    return Math.floor(Math.random() * 40000) + 10000;
  }
  return Math.floor(Math.random() * 700) + 100;
}

function doPull(userData) {
  const currentRates = calculateDynamicRates(userData);
  const roll = Math.random() * 100;

  const stoneRoll = Math.random() * 100;
  if (stoneRoll < 10) {

    let stoneType;
    if (stoneRoll < 0.2) {
      stoneType = "UNIVERSAL";
    } else {
      const elements = ["PYRO", "HYDRO", "ELECTRO", "CRYO", "DENDRO", "GEO", "ANEMO"];
      stoneType = elements[Math.floor(Math.random() * elements.length)];
    }

    const fragmentRoll = Math.random() * 100;
    if (fragmentRoll < 90) {

      const fragmentId = createStoneFragment(stoneType);
      return {
        charId: fragmentId,
        isStone: true,
        isFragment: true
      };
    } else {
      const stoneId = createStone(stoneType);
      return {
        charId: stoneId,
        isStone: true,
        isFragment: false
      };
    }
  }
  // Ph·∫ßn c√≤n l·∫°i gi·ªØ nguy√™n (pull ra nh√¢n v·∫≠t)
  let character;
  let rarity;
  if (roll < currentRates.FIVE_STAR) {
    userData.pullsSinceLastFiveStar = 0;
    userData.pullsSinceLastFourStar = 0;

    const premiumRoll = Math.random() * 100;
    if (premiumRoll < 1) {
      character =
        PREMIUM_FIVE_STARS[
          Math.floor(Math.random() * PREMIUM_FIVE_STARS.length)
        ];
    } else {
      const regularPool = CHARACTER_RATINGS.FIVE_STAR.filter(
        (char) => !PREMIUM_FIVE_STARS.includes(char)
      );
      character = regularPool[Math.floor(Math.random() * regularPool.length)];
    }
    rarity = "FIVE_STAR";
  } else if (roll < currentRates.FIVE_STAR + currentRates.FOUR_STAR) {
    userData.pullsSinceLastFourStar = 0;
    userData.pullsSinceLastFiveStar++;
    character = getRandomCharacter("FOUR_STAR");
    rarity = "FOUR_STAR";
  } else {
    userData.pullsSinceLastFourStar++;
    userData.pullsSinceLastFiveStar++;
    character = getRandomCharacter("THREE_STAR");
    rarity = "THREE_STAR";
  }

  const charId = generateCharacterId(character);
  CHARACTER_IDS[charId] = {
    type: "character",
    name: character,
    obtainedAt: Date.now(),
    value: generateCardValue(rarity, character),
  };
  saveCharacterDatabase();
  return { charId, isStone: false };
}
function createBackup() {
  try {
    const backupDir = path.join(__dirname, "./json/backups");
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const date = new Date().toISOString().split("T")[0];
    const backupFilename = `gacha_backup_${date}.json`;
    const charactersBackupFilename = `characters_backup_${date}.json`;

    fs.copyFileSync(GACHA_DATA_FILE, path.join(backupDir, backupFilename));
    fs.copyFileSync(
      CHARACTERS_DB_FILE,
      path.join(backupDir, charactersBackupFilename)
    );

    console.log(`Created backup of gacha data: ${backupFilename}`);
  } catch (error) {
    console.error("Error creating backup:", error);
  }
}

function upgradeCharacter(charId1, charId2, userData, forceType = null) {
  const char1 = CHARACTER_IDS[charId1];
  const char2 = CHARACTER_IDS[charId2];

  if (!char1 || !char2)
    return { success: false, reason: "character_not_found" };
  if (char1.name !== char2.name)
    return { success: false, reason: "different_characters" };

  const rarity = CHARACTER_RATINGS.FIVE_STAR.includes(char1.name)
    ? "5"
    : CHARACTER_RATINGS.FOUR_STAR.includes(char1.name)
    ? "4"
    : "3";

  if (rarity === "3") return { success: false, reason: "cannot_upgrade_3star" };

  const currentStar = char1.starLevel || parseInt(rarity);
  const maxStar = currentStar === 5 ? 12 : currentStar === 4 ? 8 : 3;

  // X√°c ƒë·ªãnh level hi·ªán t·∫°i
  const level1 = char1.level || 1;
  const maxLevel = CHARACTER_LEVELS[rarity].maxLevel;

  // Quy·∫øt ƒë·ªãnh n√¢ng c·∫•p theo ki·ªÉu n√†o d·ª±a v√†o ƒëi·ªÅu ki·ªán
  let upgradeType = forceType;

  if (!upgradeType) {
    // N·∫øu ƒë√£ ƒë·∫°t level t·ªëi ƒëa, n√¢ng c·∫•p sao
    if (level1 >= maxLevel) {
      upgradeType = "star";
    }
    // N·∫øu ƒë√£ ƒë·∫°t sao t·ªëi ƒëa, n√¢ng c·∫•p level
    else if (currentStar >= maxStar) {
      upgradeType = "level";
    }
    // M·∫∑c ƒë·ªãnh: n√¢ng c·∫•p level tr∆∞·ªõc
    else {
      upgradeType = "level";
    }
  }

  // X·ª≠ l√Ω lo·∫°i b·ªè nh√¢n v·∫≠t kh·ªèi inventory
  userData.inventory = userData.inventory.filter(
    (id) => id !== charId1 && id !== charId2
  );

  // Th·ª±c hi·ªán n√¢ng c·∫•p theo lo·∫°i ƒë√£ ch·ªçn
  if (upgradeType === "star" && currentStar < maxStar) {
    // Ti·∫øn h√≥a (n√¢ng sao)
    const newCharId = generateCharacterId();
    const newStar = currentStar + 1;

    const baseStats = char1.stats || { atk: 100, def: 100, hp: 500 };
    const bonusMultiplier = 1 + (newStar - 4) * 0.5;

    CHARACTER_IDS[newCharId] = {
      name: char1.name,
      obtainedAt: Date.now(),
      starLevel: newStar,
      level: Math.max(char1.level || 1, char2.level || 1),
      value:
        (char1.value || (currentStar === 5 ? 1000000 : 10000)) *
        2 *
        bonusMultiplier,
      stats: {
        atk: Math.floor(
          ((char1.stats?.atk || 100) + (char2.stats?.atk || 100)) *
            bonusMultiplier
        ),
        def: Math.floor(
          ((char1.stats?.def || 100) + (char2.stats?.def || 100)) *
            bonusMultiplier
        ),
        hp: Math.floor(
          ((char1.stats?.hp || 500) + (char2.stats?.hp || 500)) *
            bonusMultiplier
        ),
      },
    };
    saveCharacterDatabase();
    return {
      success: true,
      type: "evolved",
      charId: newCharId,
      oldStar: currentStar,
      newStar: newStar,
    };
  } else if (upgradeType === "level" && level1 < maxLevel) {

    const newCharId = generateCharacterId();
    const level2 = char2.level || 1;

    const bonusLevel = Math.floor(level2 * 0.3);
    const newLevel = Math.min(maxLevel, level1 + 1 + bonusLevel);

    const statMultiplier = CHARACTER_LEVELS[rarity].baseStats;
    const baseStats = char1.stats || { atk: 100, def: 100, hp: 500 };
    const bonusStats =
      level2 > 1 ? { atk: 50, def: 30, hp: 100 } : { atk: 0, def: 0, hp: 0 };

    const valueFactor =
      rarity === "5" ? 1 + newLevel * 0.8 : 1 + newLevel * 0.5;

    CHARACTER_IDS[newCharId] = {
      name: char1.name,
      obtainedAt: Date.now(),
      starLevel: currentStar,
      level: newLevel,
      value: char1.value * valueFactor,
      stats: {
        atk: Math.floor(
          baseStats.atk * statMultiplier.atk * newLevel + bonusStats.atk
        ),
        def: Math.floor(
          baseStats.def * statMultiplier.def * newLevel + bonusStats.def
        ),
        hp: Math.floor(
          baseStats.hp * statMultiplier.hp * newLevel + bonusStats.hp
        ),
      },
      special: level1 > 5 && level2 > 5 ? true : false,
    };

    return {
      success: true,
      type: "fused",
      charId: newCharId,
      oldLevel: level1,
      newLevel: newLevel,
    };
  } else {
    userData.inventory.push(charId1);
    userData.inventory.push(charId2);

    if (currentStar >= maxStar && level1 >= maxLevel) {
      return { success: false, reason: "max_upgrade_reached" };
    } else if (currentStar >= maxStar) {
      return { success: false, reason: "max_star_reached" };
    } else {
      return { success: false, reason: "max_level_reached" };
    }
  }
}
function getDetailedHelp() {
  return {
    basic: `üéÆ H∆Ø·ªöNG D·∫™N GENSHIN GACHA üéÆ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üëâ L·ªánh c∆° b·∫£n:
.gacha pull - M·ªü th·∫ª nh√¢n v·∫≠t
.gacha info - Xem t·ªâ l·ªá ra nh√¢n v·∫≠t
.gacha card - Xem chi ti·∫øt nh√¢n v·∫≠t
.gacha inv - Xem nh√¢n v·∫≠t ƒëang c√≥
.gacha PVP - Th√°ch ƒë·∫•u PVP
.gacha bxh - Xem BXH ng∆∞·ªùi ch∆°i
.gacha upgrade <ID1> <ID2> - N√¢ng c·∫•p nh√¢n v·∫≠t
.gacha combine <ID1> <ID2> - K·∫øt h·ª£p m·∫£nh ƒë√° ti·∫øn h√≥a
üí∞ Gi√° m·ªü: ${PULL_COST}$ /l·∫ßn
‚≠ê T·ªâ l·ªá: 5‚òÖ (${RATES.FIVE_STAR}%) | 4‚òÖ (${RATES.FOUR_STAR}%) | 3‚òÖ (${RATES.THREE_STAR}%)
üî• TH√îNG TIN H·∫§P D·∫™N üî•
‚Ä¢ Nh√¢n v·∫≠t 5‚òÖ hi·∫øm c√≥ gi√° tr·ªã l√™n ƒë·∫øn 500 TRI·ªÜU $
‚Ä¢ Nh√¢n v·∫≠t 4‚òÖ c√≥ gi√° tr·ªã t·ª´ 10.000 - 40.000 $`,
    trading: `ü§ù H∆Ø·ªöNG D·∫™N TRAO ƒê·ªîI
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1Ô∏è‚É£ Xem ID nh√¢n v·∫≠t:
- D√πng l·ªánh .gacha inv ƒë·ªÉ xem ID (#1, #2,...)
- ID hi·ªÉn th·ªã b√™n c·∫°nh t√™n nh√¢n v·∫≠t

2Ô∏è‚É£ Trao ƒë·ªïi:
- Tag ng∆∞·ªùi mu·ªën trao ƒë·ªïi
- Ghi r√µ ID nh√¢n v·∫≠t mu·ªën ƒë·ªïi
C√∫ ph√°p: .gacha trade @t√™n #ID
VD: .gacha trade @MinhAnh #1

‚è∞ C√≥ 5 ph√∫t ƒë·ªÉ ch·∫•p nh·∫≠n trao ƒë·ªïi
‚ùó Ch·ªâ trao ƒë·ªïi nh√¢n v·∫≠t b·∫°n ƒëang c√≥`,

    auction: `üî® H∆Ø·ªöNG D·∫™N ƒê·∫§U GI√Å
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1Ô∏è‚É£ ƒêƒÉng b√°n:
.gacha auction #ID <gi√°_kh·ªüi_ƒëi·ªÉm>
VD: .gacha auction #1 10000

2Ô∏è‚É£ ƒê·∫∑t gi√°:
.gacha bid <ID_phi√™n> <s·ªë_ti·ªÅn>
VD: .gacha bid abc_123 15000

‚è∞ ƒê·∫•u gi√° k√©o d√†i 1 gi·ªù
üí∞ Gi√° kh·ªüi ƒëi·ªÉm t·ªëi thi·ªÉu: 1000$
‚ùó Gi√° m·ªõi ph·∫£i cao h∆°n gi√° hi·ªán t·∫°i`,

    upgrade: `üîÑ H∆Ø·ªöNG D·∫™N TI·∫æN H√ìA NH√ÇN V·∫¨T
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1Ô∏è‚É£ ƒêi·ªÅu ki·ªán:
- Hai nh√¢n v·∫≠t ph·∫£i c√πng lo·∫°i v√† c√πng s·ªë sao
- Ph·∫£i c√≥ ƒë√° ti·∫øn h√≥a ph√π h·ª£p nguy√™n t·ªë

2Ô∏è‚É£ C√°ch ti·∫øn h√≥a:
.gacha evolve <ID1> <ID2> <ID_ƒê√Å>
VD: .gacha evolve #1 #2 #3

3Ô∏è‚É£ ƒê√° ti·∫øn h√≥a:
- M·ªói nguy√™n t·ªë c·∫ßn ƒë√° t∆∞∆°ng ·ª©ng
- ƒê√° v·∫°n nƒÉng d√πng ƒë∆∞·ª£c cho m·ªçi nh√¢n v·∫≠t

üéØ Gi·ªõi h·∫°n sao:
- 4‚≠ê: Ti·∫øn h√≥a l√™n ƒë·∫øn 8‚òÖ
- 5‚≠ê: Ti·∫øn h√≥a l√™n ƒë·∫øn 12‚òÖ

‚ùó L∆∞u √Ω: Hai nh√¢n v·∫≠t v√† ƒë√° s·∫Ω m·∫•t sau khi ti·∫øn h√≥a`,
  };
}

module.exports = {
  name: "gacha",
  dev: "HNT",
  usedby: 0,
  onPrefix: true,
  category: "Games",
  usages: ".gacha [pull/trade/auction/info/help]",
  cooldowns: 5,
  onLoad: function () {
    createBackup();
    
    loadCharacterDatabase();
    
    console.log(`Initially loaded ${Object.keys(CHARACTER_IDS).length} characters`);
    
    gachaData = loadGachaData();
    console.log(`Loaded data for ${Object.keys(gachaData).length} users`);
  
    setInterval(createBackup, 24 * 60 * 60 * 1000);
  },

  onLaunch: async function ({ api, event, target }) {
    const { threadID, messageID, senderID } = event;
    const gachaData = loadGachaData();

    const userDataPath = path.join(__dirname, "../events/cache/userData.json");
    let userName = "Unknown";
    try {
      const userData = JSON.parse(fs.readFileSync(userDataPath));
      userName = userData[senderID]?.name || "Unknown";
    } catch (error) {
      console.error("Error reading userData:", error);
    }

    if (!gachaData[senderID] || !gachaData[senderID].inventory) {
      gachaData[senderID] = {
        inventory: [],
        pullsSinceLastFiveStar: 0,
        pullsSinceLastFourStar: 0,
        totalPulls: 0,
        lastPull: 0,
      };
      saveGachaData(gachaData);
    }

    const userData = gachaData[senderID];

    if (!target[0]) {
      const help = getDetailedHelp();
      return api.sendMessage(
        `${help.basic}\n\n` +
          "üí° G√µ c√°c l·ªánh sau ƒë·ªÉ xem h∆∞·ªõng d·∫´n chi ti·∫øt:\n" +
          ".gacha help trade - H∆∞·ªõng d·∫´n trao ƒë·ªïi\n" +
          ".gacha help auction - H∆∞·ªõng d·∫´n ƒë·∫•u gi√°\n" +
          ".gacha help upgrade - H∆∞·ªõng d·∫´n n√¢ng c·∫•p",
        threadID,
        messageID
      );
    }

    const cmd = target[0].toLowerCase();
    if (cmd === "help") {
      const type = target[1]?.toLowerCase();
      const help = getDetailedHelp();

      if (type === "trade") {
        return api.sendMessage(help.trading, threadID, messageID);
      } else if (type === "auction") {
        return api.sendMessage(help.auction, threadID, messageID);
      } else if (type === "fusion") {
        return api.sendMessage(help.fusion, threadID, messageID);
      } else if (type === "evolve") {
        return api.sendMessage(help.evolve, threadID, messageID);
      } else {
        return api.sendMessage(help.basic, threadID, messageID);
      }
    }

    const action =
      {
        m·ªü: "pull",
        mo: "pull",
        pull: "pull",
        trade: "trade",
        auction: "auction",
        dau: "auction",
        bid: "bid",
        info: "info",
        inv: "inventory",
        kho: "inventory",
        bxh: "rank",
        top: "rank",
        rank: "rank",
        ranking: "rank",
      }[cmd] || cmd;

    switch (action) {
      case "pull": {
        const balance = await getBalance(senderID);
        const lastPull = userData.lastPull || 0;
        const now = Date.now();
        const cooldownLeft = PULL_COOLDOWN * 1000 - (now - lastPull);
        if (cooldownLeft > 0) {
          return api.sendMessage(
            `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.ceil(cooldownLeft / 1000)} gi√¢y n·ªØa!`,
            threadID,
            messageID
          );
        }
    
        if (balance < PULL_COST) {
          return api.sendMessage(
            "‚ùå Kh√¥ng ƒë·ªß Ti·ªÅn!\n" +
              `üí∞ Gi√°: ${PULL_COST}\n` +
              `üíµ Hi·ªán c√≥: ${balance}`,
            threadID,
            messageID
          );
        }
        const pullResult = doPull(userData);
        const currentRates = calculateDynamicRates(userData);
        await updateBalance(senderID, -PULL_COST);
      
        userData.totalPulls++;
        userData.lastPull = now;
        saveGachaData(gachaData);
      
        if (pullResult.isStone) {
          userData.inventory.push(pullResult.charId);
          saveGachaData(gachaData);
          
          const stone = CHARACTER_IDS[pullResult.charId];
          
          try {
            // X√°c ƒë·ªãnh xem ƒë√¢y l√† ƒë√° hay m·∫£nh ƒë√°
            const isFragment = pullResult.isFragment || stone.isFragment;
            const stoneImage = await createStoneResultImage({
              userId: senderID,
              userName,
              stone: stone,
              stoneRarity: stone.stoneType === "UNIVERSAL" ? 5 : 4,
              isFragment: isFragment
            });
        
            return api.sendMessage(
              {
                body: `üéÆ K·∫æT QU·∫¢ GACHA üéÆ\n\n` +
                      `${stone.emoji} ${stone.name}\n` +
                      `üìù ${stone.description}\n` +
                      `üíé ${isFragment ? 'M·∫£nh ƒë√°' : 'ƒê√°'} ti·∫øn h√≥a nguy√™n t·ªë ${stone.element}\n` +
                      `${isFragment ? 'üß© C·∫ßn 10 m·∫£nh ƒë·ªÉ gh√©p th√†nh ƒë√° ho√†n ch·ªânh\n' : ''}` +
                      `üí∞ Gi√° tr·ªã: $${stone.value.toLocaleString()}\n\n` +
                      `üîÆ ID: #${pullResult.charId.replace(isFragment ? "FRAGMENT_" : "STONE_", "").slice(-4)}\n` +
                      `‚ùì D√πng .gacha inv ƒë·ªÉ xem c√°c ${isFragment ? 'm·∫£nh ƒë√°' : 'ƒë√°'} ti·∫øn h√≥a`,
                attachment: fs.createReadStream(stoneImage),
              },
              threadID,
              () => {
                fs.unlinkSync(stoneImage);
              },
              messageID
            );
          } catch (error) {
            console.error("Error displaying stone:", error);
            return api.sendMessage(
              `üéÆ K·∫æT QU·∫¢ GACHA üéÆ\n\n` +
              `${stone.emoji} ${stone.name}\n` +
              `üìù ${stone.description}\n` +
              `üíé ƒê√° ti·∫øn h√≥a nguy√™n t·ªë ${stone.element}\n` +
              `üí∞ Gi√° tr·ªã: $${stone.value.toLocaleString()}`,
              threadID,
              messageID
            );
          }
        }
        
        // N·∫øu kh√¥ng ph·∫£i ƒë√° (l√† nh√¢n v·∫≠t)
        const charId = pullResult.charId;
        const characterName = CHARACTER_IDS[charId].name;
        const is3Star = CHARACTER_RATINGS.THREE_STAR.includes(characterName);
        
        if (is3Star) {
          await updateBalance(senderID, 200);
        } else {
          console.log(`ƒêang th√™m nh√¢n v·∫≠t ${characterName} (${charId}) v√†o inventory c·ªßa ${senderID}`);
          console.log(`Inventory tr∆∞·ªõc khi th√™m: ${userData.inventory.length} items`);
          
          userData.inventory.push(charId);
          
          saveGachaData(gachaData);
          
          console.log(`ƒê√£ th√™m ${characterName} (${charId}) v√†o inventory c·ªßa ${senderID}`);
          console.log(`Inventory sau khi th√™m: ${userData.inventory.length} items`);
        }
      
        let rarity = "‚≠ê‚≠ê‚≠ê";
        if (CHARACTER_RATINGS.FIVE_STAR.includes(characterName))
          rarity = "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê";
        else if (CHARACTER_RATINGS.FOUR_STAR.includes(characterName))
          rarity = "‚≠ê‚≠ê‚≠ê‚≠ê";

        const charInfo =
          CUSTOM_CHARACTER_DATA[CHARACTER_IDS[charId].name] ||
          (await genshin.characters(CHARACTER_IDS[charId].name.toLowerCase()));
        const imagePath = await getCharacterImage(CHARACTER_IDS[charId].name);

        const charRarity = CHARACTER_RATINGS.FIVE_STAR.includes(
          CHARACTER_IDS[charId].name
        )
          ? "5"
          : CHARACTER_RATINGS.FOUR_STAR.includes(CHARACTER_IDS[charId].name)
          ? "4"
          : "3";

        const resultImage = await createPullResultImage({
          userId: senderID,
          userName,
          character: {
            name: CHARACTER_IDS[charId].name,
            image: imagePath,
            id: charId,
            isPremium: PREMIUM_FIVE_STARS.includes(CHARACTER_IDS[charId].name),
          },
          rarity: charRarity,
          stats: {
            element: charInfo?.element || "Unknown",
            weapon: charInfo?.weapon || "Unknown",
            quote: charInfo?.quote || "...",
            skills: charInfo?.skills || [],
          },
          currentRates,
          cardValue: CHARACTER_IDS[charId].value,
        });

        return api.sendMessage(
          {
            attachment: fs.createReadStream(resultImage),
          },
          threadID,
          () => {
            fs.unlinkSync(resultImage);
            if (imagePath) fs.unlinkSync(imagePath);
          },
          messageID
        );
      }

      case "info": {
        const currentRates = calculateDynamicRates(userData);
        return api.sendMessage(
          "üìä TH√îNG TIN T·ªà L·ªÜ GACHA üìä\n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
            `üí∞ Gi√°: ${PULL_COST} $/l·∫ßn m·ªü\n\n` +
            "üéØ T·ªâ l·ªá hi·ªán t·∫°i:\n" +
            `5‚≠ê: ${currentRates.FIVE_STAR.toFixed(2)}%\n` +
            `4‚≠ê: ${currentRates.FOUR_STAR.toFixed(2)}%\n` +
            `3‚≠ê: ${currentRates.THREE_STAR.toFixed(2)}%\n\n` +
            "üí´ H·ªá th·ªëng tƒÉng t·ªâ l·ªá:\n" +
            "‚Ä¢ T·ªâ l·ªá tƒÉng theo s·ªë l·∫ßn kh√¥ng ra item hi·∫øm\n" +
            "‚Ä¢ T·ªâ l·ªá tƒÉng theo t·ªïng s·ªë l·∫ßn m·ªü\n" +
            `‚Ä¢ ƒê√£ m·ªü: ${userData.totalPulls} l·∫ßn\n` +
            `‚Ä¢ S·ªë l·∫ßn ch∆∞a ra 5‚≠ê: ${userData.pullsSinceLastFiveStar} l·∫ßn\n` +
            `‚Ä¢ S·ªë l·∫ßn ch∆∞a ra 4‚≠ê: ${userData.pullsSinceLastFourStar} l·∫ßn`,
          threadID,
          messageID
        );
      }
      case "rank": {
        const rankType = target[1]?.toLowerCase() || "value";
        return showRanking(api, threadID, messageID, rankType);
      }
      case "pvp": {
        const pvpAction = target[1]?.toLowerCase();
        
        if (!pvpAction) {
          return api.sendMessage(
            "‚öîÔ∏è H∆Ø·ªöNG D·∫™N PVP ‚öîÔ∏è\n" +
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
            "1Ô∏è‚É£ Thi·∫øt l·∫≠p ƒë·ªôi h√¨nh:\n" +
            ".gacha pvp team #ID1 #ID2 #ID3\n\n" +
            "2Ô∏è‚É£ Th√°ch ƒë·∫•u ng∆∞·ªùi ch∆°i:\n" +
            ".gacha pvp challenge @t√™n\n\n" +
            "3Ô∏è‚É£ Ch·∫•p nh·∫≠n/t·ª´ ch·ªëi:\n" +
            ".gacha pvp accept #ID_TH√ÅCH_ƒê·∫§U\n" +
            ".gacha pvp decline #ID_TH√ÅCH_ƒê·∫§U\n\n" +
            "4Ô∏è‚É£ Xem th·ªëng k√™ PVP:\n" +
            ".gacha pvp stats",
            threadID,
            messageID
          );
        }
        
        switch (pvpAction) {
          case "team": {
            // X·ª≠ l√Ω thi·∫øt l·∫≠p ƒë·ªôi h√¨nh
            if (!target[2]) {
              return api.sendMessage(
                "‚ùå B·∫°n ph·∫£i ch·ªçn √≠t nh·∫•t 1 nh√¢n v·∫≠t cho ƒë·ªôi h√¨nh PVP!\n" +
                "C√°ch d√πng: .gacha pvp team #ID1 #ID2 #ID3",
                threadID,
                messageID
              );
            }
            
            // Thu th·∫≠p ID nh√¢n v·∫≠t
            const teamIds = [];
            for (let i = 2; i < Math.min(5, target.length); i++) {
              const inputId = target[i].replace(/[^\d]/g, "");
              
              let foundCharId = null;
              for (const charId of userData.inventory) {
                if (charId.startsWith("CHAR_") && (charId.endsWith(inputId) || charId.includes(inputId))) {
                  foundCharId = charId;
                  break;
                }
              }
              
              if (!foundCharId) {
                return api.sendMessage(
                  `‚ùå Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t v·ªõi ID #${inputId}!`,
                  threadID,
                  messageID
                );
              }
              
              teamIds.push(foundCharId);
            }
            
            // L∆∞u ƒë·ªôi h√¨nh PVP
            if (!userData.pvpTeam) {
              userData.pvpTeam = [];
            }
            
            userData.pvpTeam = teamIds;
            saveGachaData(gachaData);
            
            // Hi·ªÉn th·ªã th√¥ng tin ƒë·ªôi h√¨nh
            const teamPower = calculateTeamPower(teamIds);
            const teamInfo = await formatTeamInfo(teamIds);
            
            return api.sendMessage(
              "‚úÖ THI·∫æT L·∫¨P ƒê·ªòI H√åNH PVP TH√ÄNH C√îNG!\n\n" +
              "üë• ƒê·ªôi h√¨nh c·ªßa b·∫°n:\n" +
              teamInfo + "\n" +
              `üí™ T·ªïng s·ª©c m·∫°nh: ${teamPower.toLocaleString()}\n\n` +
              "S·ª≠ d·ª•ng '.gacha pvp challenge @t√™n' ƒë·ªÉ th√°ch ƒë·∫•u!",
              threadID,
              messageID
            );
          }
          
          case "challenge": {
            // Ki·ªÉm tra ƒë·ªôi h√¨nh
            if (!userData.pvpTeam || userData.pvpTeam.length === 0) {
              return api.sendMessage(
                "‚ùå B·∫°n ch∆∞a thi·∫øt l·∫≠p ƒë·ªôi h√¨nh PVP!\n" +
                "H√£y d√πng l·ªánh '.gacha pvp team' tr∆∞·ªõc.",
                threadID,
                messageID
              );
            }
            
            // Ki·ªÉm tra cooldown
            if (userData.pvpStats?.lastBattle) {
              const cooldownLeft = PVP_COOLDOWN - (Date.now() - userData.pvpStats.lastBattle);
              if (cooldownLeft > 0) {
                return api.sendMessage(
                  `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.ceil(cooldownLeft / 1000)} gi√¢y n·ªØa ƒë·ªÉ th√°ch ƒë·∫•u ti·∫øp!`,
                  threadID,
                  messageID
                );
              }
            }
            
            // Ki·ªÉm tra ng∆∞·ªùi ƒë∆∞·ª£c tag
            const mention = Object.keys(event.mentions)[0];
            if (!mention) {
              return api.sendMessage(
                "‚ùå B·∫°n ph·∫£i tag ng∆∞·ªùi mu·ªën th√°ch ƒë·∫•u!\n" +
                "C√°ch d√πng: .gacha pvp challenge @t√™n",
                threadID,
                messageID
              );
            }
            
            // Ki·ªÉm tra kh√¥ng th·ªÉ t·ª± th√°ch ƒë·∫•u ch√≠nh m√¨nh
            if (mention === senderID) {
              return api.sendMessage(
                "‚ùå B·∫°n kh√¥ng th·ªÉ th√°ch ƒë·∫•u ch√≠nh m√¨nh!",
                threadID,
                messageID
              );
            }
            
            // T·∫°o th√°ch ƒë·∫•u
            const challengeId = createPvpChallenge(senderID, mention, userData.pvpTeam);
            
            const mentionName = event.mentions[mention].replace('@', '');
            
            return api.sendMessage(
              `‚öîÔ∏è TH√ÅCH ƒê·∫§U PVP ‚öîÔ∏è\n\n` +
              `üë§ ${userName} ƒë√£ th√°ch ƒë·∫•u ${mentionName}!\n` +
              `üí™ S·ª©c m·∫°nh ƒë·ªôi h√¨nh: ${calculateTeamPower(userData.pvpTeam)}\n\n` +
              `‚è∞ Th·ªùi h·∫°n ch·∫•p nh·∫≠n: 5 ph√∫t\n` +
              `üîñ ID th√°ch ƒë·∫•u: ${challengeId.slice(-8)}\n\n` +
              `ƒê·ªÉ ch·∫•p nh·∫≠n, h√£y thi·∫øt l·∫≠p ƒë·ªôi h√¨nh v√† g√µ:\n` +
              `.gacha pvp accept ${challengeId.slice(-8)}`,
              threadID,
              messageID
            );
          }
          
          case "accept": {
            // Ki·ªÉm tra ID th√°ch ƒë·∫•u
            if (!target[2]) {
              return api.sendMessage(
                "‚ùå B·∫°n ph·∫£i cung c·∫•p ID th√°ch ƒë·∫•u!\n" +
                "C√°ch d√πng: .gacha pvp accept ID_TH√ÅCH_ƒê·∫§U",
                threadID,
                messageID
              );
            }
            
            // T√¨m th√°ch ƒë·∫•u
            const challengeId = [...activePvpChallenges.keys()].find(id => id.endsWith(target[2]));
            if (!challengeId) {
              return api.sendMessage(
                "‚ùå Kh√¥ng t√¨m th·∫•y th√°ch ƒë·∫•u v·ªõi ID n√†y ho·∫∑c th√°ch ƒë·∫•u ƒë√£ h·∫øt h·∫°n!",
                threadID,
                messageID
              );
            }
            
            const challengeData = activePvpChallenges.get(challengeId);
            
            // Ki·ªÉm tra xem ng∆∞·ªùi ch·∫•p nh·∫≠n c√≥ ph·∫£i l√† ng∆∞·ªùi ƒë∆∞·ª£c th√°ch ƒë·∫•u
            if (challengeData.target !== senderID) {
              return api.sendMessage(
                "‚ùå B·∫°n kh√¥ng ph·∫£i l√† ng∆∞·ªùi ƒë∆∞·ª£c th√°ch ƒë·∫•u!",
                threadID,
                messageID
              );
            }
            
            // Ki·ªÉm tra th·ªùi h·∫°n
            if (challengeData.expiry < Date.now()) {
              activePvpChallenges.delete(challengeId);
              return api.sendMessage(
                "‚ùå Th√°ch ƒë·∫•u ƒë√£ h·∫øt h·∫°n!",
                threadID,
                messageID
              );
            }
            
            // Ki·ªÉm tra ƒë·ªôi h√¨nh ng∆∞·ªùi ch·∫•p nh·∫≠n
            if (!userData.pvpTeam || userData.pvpTeam.length === 0) {
              return api.sendMessage(
                "‚ùå B·∫°n ch∆∞a thi·∫øt l·∫≠p ƒë·ªôi h√¨nh PVP!\n" +
                "H√£y d√πng l·ªánh '.gacha pvp team' tr∆∞·ªõc khi ch·∫•p nh·∫≠n th√°ch ƒë·∫•u.",
                threadID,
                messageID
              );
            }
            
            // B·∫Øt ƒë·∫ßu tr·∫≠n ƒë·∫•u
            api.sendMessage(
              "‚öîÔ∏è TR·∫¨N ƒê·∫§U PVP B·∫ÆT ƒê·∫¶U! ‚öîÔ∏è\n" +
              "ƒêang t√≠nh to√°n k·∫øt qu·∫£...",
              threadID,
              messageID
            );
            
            // X√≥a th√°ch ƒë·∫•u
            activePvpChallenges.delete(challengeId);
            
            // Ti·∫øn h√†nh tr·∫≠n ƒë·∫•u v√† hi·ªÉn th·ªã k·∫øt qu·∫£
            return executePvpBattle(api, threadID, messageID, challengeData, userData.pvpTeam);
          }
          
          case "decline": {
            // Ki·ªÉm tra ID th√°ch ƒë·∫•u
            if (!target[2]) {
              return api.sendMessage(
                "‚ùå B·∫°n ph·∫£i cung c·∫•p ID th√°ch ƒë·∫•u!\n" +
                "C√°ch d√πng: .gacha pvp decline ID_TH√ÅCH_ƒê·∫§U",
                threadID,
                messageID
              );
            }
            
            // T√¨m th√°ch ƒë·∫•u
            const challengeId = [...activePvpChallenges.keys()].find(id => id.endsWith(target[2]));
            if (!challengeId) {
              return api.sendMessage(
                "‚ùå Kh√¥ng t√¨m th·∫•y th√°ch ƒë·∫•u v·ªõi ID n√†y ho·∫∑c th√°ch ƒë·∫•u ƒë√£ h·∫øt h·∫°n!",
                threadID,
                messageID
              );
            }
            
            const challengeData = activePvpChallenges.get(challengeId);
            
            // Ki·ªÉm tra xem ng∆∞·ªùi t·ª´ ch·ªëi c√≥ ph·∫£i l√† ng∆∞·ªùi ƒë∆∞·ª£c th√°ch ƒë·∫•u
            if (challengeData.target !== senderID) {
              return api.sendMessage(
                "‚ùå B·∫°n kh√¥ng ph·∫£i l√† ng∆∞·ªùi ƒë∆∞·ª£c th√°ch ƒë·∫•u!",
                threadID,
                messageID
              );
            }
            
            // X√≥a th√°ch ƒë·∫•u
            activePvpChallenges.delete(challengeId);
            
            return api.sendMessage(
              "üö´ B·∫°n ƒë√£ t·ª´ ch·ªëi th√°ch ƒë·∫•u PVP!",
              threadID,
              messageID
            );
          }
          
          case "stats": {
            // Hi·ªÉn th·ªã th·ªëng k√™ PVP
            if (!userData.pvpStats) {
              return api.sendMessage(
                "üìä TH·ªêNG K√ä PVP üìä\n\n" +
                "B·∫°n ch∆∞a tham gia tr·∫≠n ƒë·∫•u PVP n√†o!",
                threadID,
                messageID
              );
            }
            
            const wins = userData.pvpStats.wins || 0;
            const losses = userData.pvpStats.losses || 0;
            const total = wins + losses;
            const winRate = total > 0 ? (wins / total * 100).toFixed(1) : 0;
            
            // T√≠nh h·∫°ng PVP
            let pvpRank = "T√¢n binh";
            if (wins >= 100) pvpRank = "Huy·ªÅn tho·∫°i";
            else if (wins >= 50) pvpRank = "B·∫≠c th·∫ßy";
            else if (wins >= 20) pvpRank = "Chuy√™n gia";
            else if (wins >= 10) pvpRank = "Chi·∫øn binh";
            else if (wins >= 5) pvpRank = "Kinh nghi·ªám";
            
            // T√≠nh s·ª©c m·∫°nh ƒë·ªôi h√¨nh
            const teamPower = userData.pvpTeam ? calculateTeamPower(userData.pvpTeam) : 0;
            
            return api.sendMessage(
              "üìä TH·ªêNG K√ä PVP üìä\n" +
              "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
              `üë§ ${userName}\n` +
              `üèÜ H·∫°ng: ${pvpRank}\n` +
              `üí™ S·ª©c m·∫°nh ƒë·ªôi h√¨nh: ${teamPower.toLocaleString()}\n\n` +
              `‚úÖ Th·∫Øng: ${wins} tr·∫≠n\n` +
              `‚ùå Thua: ${losses} tr·∫≠n\n` +
              `üìà T·ªâ l·ªá th·∫Øng: ${winRate}%\n\n` +
              `üí° S·ª≠ d·ª•ng '.gacha pvp team' ƒë·ªÉ thi·∫øt l·∫≠p ƒë·ªôi h√¨nh m·∫°nh h∆°n!`,
              threadID,
              messageID
            );
          }
          
          default: {
            return api.sendMessage(
              "‚ùå L·ªánh PVP kh√¥ng h·ª£p l·ªá!\n" +
              "S·ª≠ d·ª•ng '.gacha pvp' ƒë·ªÉ xem h∆∞·ªõng d·∫´n.",
              threadID,
              messageID
            );
          }
        }
      }
      case "bag":
      case "inventory": {
        verifyInventory(senderID);
        if (
          target[1]?.toLowerCase() === "del" ||
          target[1]?.toLowerCase() === "delete"
        ) {
          if (!target[2]) {
            return api.sendMessage(
              "‚ùå Thi·∫øu ID v·∫≠t ph·∫©m!\n\n" +
                "C√°ch d√πng: .gacha inv del #ID\n" +
                "VD: .gacha inv del #1234\n\n" +
                "‚ö†Ô∏è L∆∞u √Ω: B·∫°n s·∫Ω nh·∫≠n l·∫°i 30% gi√° tr·ªã v·∫≠t ph·∫©m",
              threadID,
              messageID
            );
          }

          const inputId = target[2].replace(/[^\d]/g, "");

          let foundItemId = null;
          for (const itemId of userData.inventory) {
            if (itemId.endsWith(inputId) || itemId.includes(inputId)) {
              foundItemId = itemId;
              break;
            }
          }

          if (!foundItemId) {
            return api.sendMessage(
              `‚ùå Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m v·ªõi ID #${inputId}!`,
              threadID,
              messageID
            );
          }

          const item = CHARACTER_IDS[foundItemId];
          if (!item) {
            return api.sendMessage(
              "‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·∫≠t ph·∫©m!",
              threadID,
              messageID
            );
          }

          const isStone = foundItemId.startsWith("STONE_");

          let itemName, itemType, itemRarity;

          if (isStone) {
            itemName = item.name;
            itemType = "ƒê√° ti·∫øn h√≥a";
            itemRarity = "4‚òÖ";
            if (item.stoneType === "UNIVERSAL") itemRarity = "5‚òÖ";
          } else {
            itemName = item.name;
            itemType = "Nh√¢n v·∫≠t";
            itemRarity = CHARACTER_RATINGS.FIVE_STAR.includes(item.name)
              ? "5‚òÖ"
              : CHARACTER_RATINGS.FOUR_STAR.includes(item.name)
              ? "4‚òÖ"
              : "3‚òÖ";
          }

          const refundAmount = Math.floor((item.value || 0) * 0.3);

          userData.inventory = userData.inventory.filter(
            (id) => id !== foundItemId
          );

          await updateBalance(senderID, refundAmount);

          saveGachaData(gachaData);

          return api.sendMessage(
            "üóëÔ∏è ƒê√É X√ìA V·∫¨T PH·∫®M TH√ÄNH C√îNG!\n" +
              `${itemType}: ${itemName} (${itemRarity})\n` +
              `ID: #${inputId}\n` +
              `üí∞ Nh·∫≠n l·∫°i: $${refundAmount.toLocaleString()} (30% gi√° tr·ªã)\n\n` +
              `S·ªë v·∫≠t ph·∫©m c√≤n l·∫°i: ${userData.inventory.length}`,
            threadID,
            messageID
          );
        }

        const characters = [];
        const stones = [];
        const fragments = [];
        let totalValue = 0;
        
        // Sort inventory items into respective arrays with detailed info
        userData.inventory.forEach((id) => {
          const item = CHARACTER_IDS[id];
          if (!item) return;
          
          totalValue += item.value || 0;
          
          if (id.startsWith("CHAR_")) {
            // For character items
            const rarity = CHARACTER_RATINGS.FIVE_STAR.includes(item.name)
              ? 5
              : CHARACTER_RATINGS.FOUR_STAR.includes(item.name)
                ? 4
                : 3;
            
            const charInfo = CUSTOM_CHARACTER_DATA[item.name] || {};
            
            characters.push({
              type: "character",
              name: item.name,
              id: id.slice(-4),
              rarity,
              value: item.value || 0,
              level: item.level || 1,
              starLevel: item.starLevel || rarity,
              element: charInfo.element || "Unknown",
              emoji: "üë§",
              isPremium: PREMIUM_FIVE_STARS.includes(item.name)
            });
          } else if (id.startsWith("STONE_")) {
            // For stone items
            stones.push({
              type: "stone",
              name: item.name,
              id: id.slice(-4),
              element: item.element,
              emoji: item.emoji,
              value: item.value || 0,
              stoneType: item.stoneType
            });
          } else if (id.startsWith("FRAGMENT_")) {
            // For fragment items
            fragments.push({
              type: "fragment",
              name: item.name,
              id: id.slice(-4),
              element: item.element,
              emoji: item.emoji,
              value: item.value || 0,
              isFragment: true,
              stoneType: item.stoneType
            });
          }
        });
        
        // Count characters by rarity
        const characterCounts = {
          5: characters.filter(c => c.rarity === 5).length,
          4: characters.filter(c => c.rarity === 4).length,
          3: characters.filter(c => c.rarity === 3).length
        };
        
        const { createInventoryImage } = require("../canvas/gachaCanvas");
        
        const imagePath = await createInventoryImage({
          userId: senderID,
          userName,
          totalValue,
          characters,
          stones,
          fragments,
          characterCounts,
          totalItems: userData.inventory.length
        });
        
        return api.sendMessage(
          {
            body: `üì¶ KHO ƒê·ªí GENSHIN IMPACT üì¶\nüë§ ${userName}\nüí∞ T·ªïng gi√° tr·ªã: $${totalValue.toLocaleString()}\nüß© T·ªïng v·∫≠t ph·∫©m: ${userData.inventory.length}`,
            attachment: fs.createReadStream(imagePath)
          },
          threadID,
          () => fs.unlinkSync(imagePath),
          messageID
        );
      } 
      
function calculateInventoryValue(inventory) {
  return inventory.reduce((total, itemId) => {
    const item = CHARACTER_IDS[itemId];
    if (!item) return total;
    return total + (item.value || 0);
  }, 0);
}

case "combine": {
  if (!target[1]) {
    return api.sendMessage(
      "‚ùå Thi·∫øu th√¥ng tin m·∫£nh ƒë√°!\n\n" +
      "C√°ch d√πng: .gacha combine #ID1 #ID2 ... #ID10\n" +
      "VD: .gacha combine #1234 #5678 ... (t·ªïng 10 ID)\n\n" +
      "‚ö†Ô∏è L∆∞u √Ω:\n" +
      "- C·∫ßn 10 m·∫£nh ƒë√° c√πng lo·∫°i ƒë·ªÉ gh√©p\n" +
      "- C√°c m·∫£nh ƒë√° s·∫Ω b·ªã m·∫•t sau khi gh√©p",
      threadID,
      messageID
    );
  }

  // Thu th·∫≠p ID m·∫£nh ƒë√°
  const fragmentIds = [];
  for (let i = 1; i < target.length; i++) {
    const inputId = target[i].replace(/[^\d]/g, "");
    
    let foundFragmentId = null;
    for (const fragId of userData.inventory) {
      if (fragId.startsWith("FRAGMENT_") && (fragId.endsWith(inputId) || fragId.includes(inputId))) {
        foundFragmentId = fragId;
        break;
      }
    }
    
    if (foundFragmentId) {
      fragmentIds.push(foundFragmentId);
    }
  }

  if (fragmentIds.length < 10) {
    return api.sendMessage(
      `‚ùå Kh√¥ng ƒë·ªß m·∫£nh ƒë√° ƒë·ªÉ gh√©p (c·∫ßn 10, ƒëang c√≥ ${fragmentIds.length})!`,
      threadID,
      messageID
    );
  }

  // Ki·ªÉm tra xem t·∫•t c·∫£ c√°c m·∫£nh ƒë√° ƒë·ªÅu c√πng lo·∫°i
  const firstFragment = CHARACTER_IDS[fragmentIds[0]];
  if (!firstFragment || !firstFragment.isFragment) {
    return api.sendMessage(
      "‚ùå ID kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng ph·∫£i m·∫£nh ƒë√°!",
      threadID,
      messageID
    );
  }

  const stoneType = firstFragment.stoneType;
  const sameType = fragmentIds.every(id => {
    const fragment = CHARACTER_IDS[id];
    return fragment && fragment.isFragment && fragment.stoneType === stoneType;
  });

  if (!sameType) {
    return api.sendMessage(
      "‚ùå T·∫•t c·∫£ m·∫£nh ƒë√° ph·∫£i c√πng lo·∫°i ƒë·ªÉ gh√©p!",
      threadID,
      messageID
    );
  }

  // X√≥a 10 m·∫£nh ƒë√° t·ª´ inventory
  userData.inventory = userData.inventory.filter(id => !fragmentIds.includes(id));

  // T·∫°o ƒë√° ho√†n ch·ªânh
  const stoneId = createStone(stoneType);
  userData.inventory.push(stoneId);

  // L∆∞u thay ƒë·ªïi
  saveGachaData(gachaData);

  const stone = CHARACTER_IDS[stoneId];
  return api.sendMessage(
    "‚úÖ GH√âP M·∫¢NH ƒê√Å TH√ÄNH C√îNG!\n\n" +
    `${stone.emoji} ${stone.name}\n` +
    `üìù ${stone.description}\n` +
    `üíé ƒê√° ti·∫øn h√≥a nguy√™n t·ªë ${stone.element}\n` +
    `üí∞ Gi√° tr·ªã: $${stone.value.toLocaleString()}\n\n` +
    `üß© ƒê√£ s·ª≠ d·ª•ng: 10 m·∫£nh ƒë√° ${ELEMENTAL_FRAGMENTS[stoneType].name}`,
    threadID,
    messageID
  );
}
      case "card":
      case "view": {
        if (!target[1]) {
          return api.sendMessage(
            "‚ùå Thi·∫øu ID nh√¢n v·∫≠t!\n\n" +
              "C√°ch d√πng: .gacha card #ID\n" +
              "VD: .gacha card #1234",
            threadID,
            messageID
          );
        }

        const inputId = target[1].replace(/[^\d]/g, "");

        let foundCharId = null;
        for (const charId of userData.inventory) {
          if (charId.endsWith(inputId) || charId.includes(inputId)) {
            foundCharId = charId;
            break;
          }
        }

        if (!foundCharId) {
          return api.sendMessage(
            `‚ùå Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t v·ªõi ID #${inputId}!`,
            threadID,
            messageID
          );
        }

        const char = CHARACTER_IDS[foundCharId];
        if (!char) {
          return api.sendMessage(
            "‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n v·∫≠t!",
            threadID,
            messageID
          );
        }

        const rarity = CHARACTER_RATINGS.FIVE_STAR.includes(char.name)
          ? "5"
          : CHARACTER_RATINGS.FOUR_STAR.includes(char.name)
          ? "4"
          : "3";

        const charInfo =
          CUSTOM_CHARACTER_DATA[char.name] ||
          (await genshin.characters(char.name.toLowerCase()).catch(() => null));

        const imagePath = await getCharacterImage(char.name);

        const cardImage = await createPullResultImage({
          userId: senderID,
          userName: userName,
          character: {
            name: char.name,
            image: imagePath,
            id: foundCharId,
            isPremium: PREMIUM_FIVE_STARS.includes(char.name),
          },
          rarity: rarity,
          stats: {
            element: charInfo?.element || "Unknown",
            weapon: charInfo?.weapon || "Unknown",
            quote: charInfo?.quote || "...",
            skills: charInfo?.skills || [],
          },
          cardValue: char.value,
          level: char.level || 1,
          starLevel: char.starLevel || parseInt(rarity),
          attributes: char.stats || {
            atk:
              char.stats?.atk ||
              (rarity === "5" ? 500 : rarity === "4" ? 300 : 100),
            def:
              char.stats?.def ||
              (rarity === "5" ? 500 : rarity === "4" ? 300 : 100),
            hp:
              char.stats?.hp ||
              (rarity === "5" ? 2000 : rarity === "4" ? 1000 : 500),
          },
        });

        return api.sendMessage(
          {
            body:
              `üìä TH√îNG TIN NH√ÇN V·∫¨T üìä\n\n` +
              `üë§ ${char.name} (ID: ${target[1]})\n` +
              `‚≠ê ƒê·ªô hi·∫øm: ${char.starLevel || rarity}‚òÖ\n` +
              `üìà C·∫•p ƒë·ªô: ${char.level || 1}\n` +
              (char.special ? "‚ú® ƒê·∫∑c bi·ªát: C√≥\n" : "") +
              `üí∞ Gi√° tr·ªã: $${char.value?.toLocaleString()}`,
            attachment: fs.createReadStream(cardImage),
          },
          threadID,
          () => {
            fs.unlinkSync(cardImage);
            if (imagePath) fs.unlinkSync(imagePath);
          },
          messageID
        );
      }
      case "trade": {
        const mention = Object.keys(event.mentions)[0];
        if (!mention || !target[2]) {
          return api.sendMessage(
            "‚ùå Thi·∫øu th√¥ng tin trao ƒë·ªïi!\n\n" +
              "C√°ch d√πng ƒë√∫ng:\n" +
              ".gacha trade @t√™n #ID\n" +
              "(.gacha help trade ƒë·ªÉ xem h∆∞·ªõng d·∫´n)",
            threadID,
            messageID
          );
        }

        const offerCharId = target[2];
        if (!userData.inventory.includes(offerCharId)) {
          return api.sendMessage(
            "‚ùå Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t!\n" +
              "üí° D√πng .g inv ƒë·ªÉ xem ID nh√¢n v·∫≠t",
            threadID,
            messageID
          );
        }

        const tradeId = createTradeOffer(
          senderID,
          mention,
          offerCharId,
          target[3]
        );
        return api.sendMessage(
          `ü§ù ƒê·ªÅ ngh·ªã trao ƒë·ªïi:\n` +
            `üë§ T·ª´: ${userName}\n` +
            `üí´ ƒê·ªïi: ${offerCharId}\n` +
            `üí´ L·∫•y: ${target[3]}\n` +
            `üîñ ID: ${tradeId}\n\n` +
            `Ng∆∞·ªùi ƒë∆∞·ª£c tag c√≥ 5 ph√∫t ƒë·ªÉ d√πng l·ªánh:\n` +
            `.gacha accept ${tradeId}`,
          threadID,
          messageID
        );
      }
      case "upgrade":
      case "up": {
        if (!target[1] || !target[2] || !target[3]) {
          return api.sendMessage(
            "‚ùå Thi·∫øu th√¥ng tin nh√¢n v·∫≠t ho·∫∑c ƒë√° ti·∫øn h√≥a!\n\n" +
              "C√°ch d√πng: .gacha evolve #ID1 #ID2 #ID_DA\n" +
              "VD: .gacha evolve #1234 #5678 #9012\n\n" +
              "‚ö†Ô∏è L∆∞u √Ω:\n" +
              "- Hai nh√¢n v·∫≠t ph·∫£i c√πng lo·∫°i v√† c√πng s·ªë sao\n" +
              "- ƒê√° ti·∫øn h√≥a ph·∫£i ph√π h·ª£p v·ªõi nguy√™n t·ªë nh√¢n v·∫≠t\n" +
              "- Nh√¢n v·∫≠t 4‚òÖ: Max 8 sao\n" +
              "- Nh√¢n v·∫≠t 5‚òÖ: Max 12 sao\n" +
              "- Hai nh√¢n v·∫≠t v√† ƒë√° s·∫Ω b·ªã m·∫•t sau khi ti·∫øn h√≥a",
            threadID,
            messageID
          );
        }

        const inputId1 = target[1].replace(/[^\d]/g, "");
        let foundCharId1 = null;
        for (const charId of userData.inventory) {
          if (
            charId.startsWith("CHAR_") &&
            (charId.endsWith(inputId1) || charId.includes(inputId1))
          ) {
            foundCharId1 = charId;
            break;
          }
        }

        const inputId2 = target[2].replace(/[^\d]/g, "");
        let foundCharId2 = null;
        for (const charId of userData.inventory) {
          if (
            charId.startsWith("CHAR_") &&
            (charId.endsWith(inputId2) || charId.includes(inputId2))
          ) {
            foundCharId2 = charId;
            break;
          }
        }

        const stoneInputId = target[3].replace(/[^\d]/g, "");
        let foundStoneId = null;
        for (const id of userData.inventory) {
          if (
            id.startsWith("STONE_") &&
            (id.endsWith(stoneInputId) || id.includes(stoneInputId))
          ) {
            foundStoneId = id;
            break;
          }
        }

        if (!foundCharId1) {
          return api.sendMessage(
            `‚ùå Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t v·ªõi ID #${inputId1}!`,
            threadID,
            messageID
          );
        }
        if (!foundCharId2) {
          return api.sendMessage(
            `‚ùå Kh√¥ng t√¨m th·∫•y nh√¢n v·∫≠t v·ªõi ID #${inputId2}!`,
            threadID,
            messageID
          );
        }
        if (!foundStoneId) {
          return api.sendMessage(
            `‚ùå Kh√¥ng t√¨m th·∫•y ƒë√° ti·∫øn h√≥a v·ªõi ID #${stoneInputId}!`,
            threadID,
            messageID
          );
        }

        const char1 = CHARACTER_IDS[foundCharId1];
        const char2 = CHARACTER_IDS[foundCharId2];
        const stone = CHARACTER_IDS[foundStoneId];

        if (!char1 || !char2 || !stone) {
          return api.sendMessage(
            "‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n v·∫≠t ho·∫∑c ƒë√°!",
            threadID,
            messageID
          );
        }

        if (char1.name !== char2.name) {
          return api.sendMessage(
            "‚ùå Hai nh√¢n v·∫≠t ph·∫£i c√πng lo·∫°i!",
            threadID,
            messageID
          );
        }

        const star1 =
          char1.starLevel ||
          (CHARACTER_RATINGS.FIVE_STAR.includes(char1.name) ? 5 : 4);
        const star2 =
          char2.starLevel ||
          (CHARACTER_RATINGS.FIVE_STAR.includes(char2.name) ? 5 : 4);

        if (star1 !== star2) {
          return api.sendMessage(
            "‚ùå Hai nh√¢n v·∫≠t ph·∫£i c√πng s·ªë sao ƒë·ªÉ ti·∫øn h√≥a!",
            threadID,
            messageID
          );
        }

        const charInfo = CUSTOM_CHARACTER_DATA[char1.name];
        const charElement = charInfo?.element?.toUpperCase() || "UNKNOWN";

        const stoneElement = stone.stoneType;
        if (stoneElement !== "UNIVERSAL" && stoneElement !== charElement) {
          return api.sendMessage(
            `‚ùå ƒê√° ti·∫øn h√≥a ${stone.name} kh√¥ng ph√π h·ª£p v·ªõi nh√¢n v·∫≠t ${charElement}!\n` +
              `Nh√¢n v·∫≠t ${char1.name} c·∫ßn ƒë√° ${
                ELEMENTAL_STONES[charElement]?.name || "ph√π h·ª£p"
              } ho·∫∑c Brilliant Diamond`,
            threadID,
            messageID
          );
        }

        const rarity = CHARACTER_RATINGS.FIVE_STAR.includes(char1.name) ? 5 : 4;
        const maxStar = rarity === 5 ? 12 : 8;

        if (star1 >= maxStar) {
          return api.sendMessage(
            "‚ùå Nh√¢n v·∫≠t ƒë√£ ƒë·∫°t c·∫•p sao t·ªëi ƒëa!",
            threadID,
            messageID
          );
        }

        // T·∫°o nh√¢n v·∫≠t m·ªõi ƒë√£ ti·∫øn h√≥a
        const newCharId = generateCharacterId();
        const newStar = star1 + 1;

        const baseStats = char1.stats || { atk: 100, def: 100, hp: 500 };
        const bonusMultiplier = 1 + (newStar - rarity) * 0.5;

        CHARACTER_IDS[newCharId] = {
          type: "character",
          name: char1.name,
          obtainedAt: Date.now(),
          starLevel: newStar,
          level: Math.max(char1.level || 1, char2.level || 1),
          value:
            (char1.value || (rarity === 5 ? 1000000 : 10000)) *
            2 *
            bonusMultiplier,
          stats: {
            atk: Math.floor(
              ((char1.stats?.atk || 100) + (char2.stats?.atk || 100)) *
                bonusMultiplier
            ),
            def: Math.floor(
              ((char1.stats?.def || 100) + (char2.stats?.def || 100)) *
                bonusMultiplier
            ),
            hp: Math.floor(
              ((char1.stats?.hp || 500) + (char2.stats?.hp || 500)) *
                bonusMultiplier
            ),
          },
        };

        // X√≥a nh√¢n v·∫≠t c≈© v√† ƒë√° kh·ªèi inventory
        userData.inventory = userData.inventory.filter(
          (id) =>
            id !== foundCharId1 && id !== foundCharId2 && id !== foundStoneId
        );

        // Th√™m nh√¢n v·∫≠t m·ªõi
        userData.inventory.push(newCharId);

        // L∆∞u thay ƒë·ªïi
        saveCharacterDatabase();
        saveGachaData(gachaData);

        return api.sendMessage(
          "üåü TI·∫æN H√ìA TH√ÄNH C√îNG! üåü\n" +
            `Nh√¢n v·∫≠t: ${char1.name}\n` +
            `‚≠ê Sao: ${star1}‚òÖ ‚Üí ${newStar}‚òÖ\n` +
            `üí™ ATK: ${CHARACTER_IDS[newCharId].stats.atk}\n` +
            `üõ°Ô∏è DEF: ${CHARACTER_IDS[newCharId].stats.def}\n` +
            `‚ù§Ô∏è HP: ${CHARACTER_IDS[newCharId].stats.hp}\n` +
            `üí∞ Gi√° tr·ªã: $${CHARACTER_IDS[
              newCharId
            ].value.toLocaleString()}\n\n` +
            `${stone.emoji} ƒê√£ s·ª≠ d·ª•ng: 1 ${stone.name}`,
          threadID,
          messageID
        );
      }
      case "restore": {
        if (senderID !== "61573427362389") { 
          return api.sendMessage("‚ùå Ch·ªâ admin m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!", threadID, messageID);
        }
        
        const date = target[1]; 
        const success = restoreFromBackup(date);
        
        if (success) {
          return api.sendMessage(
            "‚úÖ ƒê√£ ph·ª•c h·ªìi d·ªØ li·ªáu t·ª´ b·∫£n backup th√†nh c√¥ng!" +
            (date ? `\nNg√†y: ${date}` : "\nPhi√™n b·∫£n: M·ªõi nh·∫•t"), 
            threadID, messageID
          );
        } else {
          return api.sendMessage(
            "‚ùå Kh√¥ng th·ªÉ ph·ª•c h·ªìi d·ªØ li·ªáu t·ª´ backup!" +
            "\nKi·ªÉm tra l·∫°i t√™n file ho·∫∑c th·ª≠ ph·ª•c h·ªìi phi√™n b·∫£n kh√°c.",
            threadID, messageID
          );
        }
      }
      case "auction": {
        if (!target[1] || !target[2]) {
          return api.sendMessage(
            "‚ùå Thi·∫øu th√¥ng tin ƒë·∫•u gi√°!\n\n" +
              "C√°ch d√πng ƒë√∫ng:\n" +
              ".gacha auction #ID <gi√°>\n" +
              "(.gacha help auction ƒë·ªÉ xem h∆∞·ªõng d·∫´n)",
            threadID,
            messageID
          );
        }

        const character = target[1];
        const startingBid = parseInt(target[2]);

        if (!userData.inventory.includes(character)) {
          return api.sendMessage(
            "‚ùå B·∫°n kh√¥ng s·ªü h·ªØu nh√¢n v·∫≠t n√†y!",
            threadID,
            messageID
          );
        }

        if (isNaN(startingBid) || startingBid < 1000) {
          return api.sendMessage(
            "‚ùå Gi√° kh·ªüi ƒëi·ªÉm kh√¥ng h·ª£p l·ªá (t·ªëi thi·ªÉu 1000$)!",
            threadID,
            messageID
          );
        }

        const auctionId = createAuction(senderID, character, startingBid);
        return api.sendMessage(
          `üî® ƒê·∫•u gi√° b·∫Øt ƒë·∫ßu!\n` +
            `üë§ Ng∆∞·ªùi b√°n: ${userName}\n` +
            `üí´ Nh√¢n v·∫≠t: ${character}\n` +
            `üí∞ Gi√° kh·ªüi ƒëi·ªÉm: ${startingBid}$\n` +
            `üîñ ID: ${auctionId}\n\n` +
            `ƒê·∫•u gi√° k√©o d√†i 1 gi·ªù\n` +
            `ƒê·ªÉ ƒë·∫∑t gi√° d√πng l·ªánh:\n` +
            `.gacha bid ${auctionId} <s·ªë_ti·ªÅn>`,
          threadID,
          messageID
        );
      }

      case "bid": {
        if (!target[1] || !target[2]) {
          return api.sendMessage(
            "‚ö†Ô∏è Vui l√≤ng ghi r√µ ID ƒë·∫•u gi√° v√† s·ªë ti·ªÅn!",
            threadID,
            messageID
          );
        }

        const auctionId = target[1];
        const bidAmount = parseInt(target[2]);
        const auction = activeAuctions.get(auctionId);

        if (!auction) {
          return api.sendMessage(
            "‚ùå Kh√¥ng t√¨m th·∫•y phi√™n ƒë·∫•u gi√°!",
            threadID,
            messageID
          );
        }

        if (auction.seller === senderID) {
          return api.sendMessage(
            "‚ùå B·∫°n kh√¥ng th·ªÉ ƒë·∫•u gi√° v·∫≠t ph·∫©m c·ªßa ch√≠nh m√¨nh!",
            threadID,
            messageID
          );
        }

        const balance = await getBalance(senderID);
        if (balance < bidAmount) {
          return api.sendMessage(
            "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ ƒë·∫∑t gi√°!",
            threadID,
            messageID
          );
        }

        if (placeBid(auctionId, senderID, bidAmount)) {
          return api.sendMessage(
            `‚úÖ ƒê·∫∑t gi√° th√†nh c√¥ng!\n` +
              `üí´ Nh√¢n v·∫≠t: ${auction.character}\n` +
              `üí∞ Gi√° hi·ªán t·∫°i: ${bidAmount}$\n` +
              `‚è∞ K·∫øt th√∫c sau: ${Math.ceil(
                (auction.endTime - Date.now()) / 60000
              )} ph√∫t`,
            threadID,
            messageID
          );
        } else {
          return api.sendMessage(
            "‚ùå Gi√° c·ªßa b·∫°n ph·∫£i cao h∆°n gi√° hi·ªán t·∫°i!",
            threadID,
            messageID
          );
        }
      }
    }
  },
};
