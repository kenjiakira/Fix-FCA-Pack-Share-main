const fs = require('fs');
const path = require('path');
const axios = require('axios');
const pokeSystem = require('../poke/pokemonSystem');
const currencies = require('../utils/currencies');

module.exports = {
    name: "poke",
    dev: "HNT",
    usedby: 2,
    info: "sƒÉn Pokemon",
    onPrefix: true,
    usages: ".poke [catch/bag/select/battle/info]",
    cooldowns: 2,

    async handleEvolution(api, threadID, evolution) {
        if (!evolution || evolution === true) return;

        const { oldPokemon, newPokemon } = evolution;
        
        const oldResponse = await axios.get(oldPokemon.image, { responseType: 'arraybuffer' });
        const oldImagePath = path.join(__dirname, 'cache', 'pokemon_old.png');
        await fs.promises.writeFile(oldImagePath, oldResponse.data);

        const newResponse = await axios.get(newPokemon.image, { responseType: 'arraybuffer' });
        const newImagePath = path.join(__dirname, 'cache', 'pokemon_new.png');
        await fs.promises.writeFile(newImagePath, newResponse.data);

        await api.sendMessage(
            {
                body: "‚ú® POKEMON TI·∫æN H√ìA ‚ú®\n" +
                      "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                      `${oldPokemon.name.toUpperCase()} ƒë√£ ti·∫øn h√≥a th√†nh ${newPokemon.name.toUpperCase()}!\n\n` +
                      "üìä CH·ªà S·ªê M·ªöI:\n" +
                      `‚ù§Ô∏è HP: ${oldPokemon.hp} ‚Üí ${newPokemon.hp}\n` +
                      `‚öîÔ∏è ATK: ${oldPokemon.attack} ‚Üí ${newPokemon.attack}\n` +
                      `üõ°Ô∏è DEF: ${oldPokemon.defense} ‚Üí ${newPokemon.defense}\n` +
                      `üé≠ H·ªá: ${newPokemon.types.map(t => 
                          `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                      ).join(' | ')}`,
                attachment: [
                    fs.createReadStream(oldImagePath),
                    fs.createReadStream(newImagePath)
                ]
            },
            threadID
        );
    },

    onLaunch: async function({ api, event, target }) {
        const { threadID, messageID, senderID } = event;
        await pokeSystem.init();

        const command = target[0]?.toLowerCase();
        const param = target[1];
        try {
            switch (command) {
                case "catch":
                    const catchData = await pokeSystem.generatePokemon();
                    const response = await axios.get(catchData.image, { responseType: 'arraybuffer' });
                    const imagePath = path.join(__dirname, 'cache', 'pokemon_catch.png');
                    await fs.promises.writeFile(imagePath, response.data);

                    const bestBall = await pokeSystem.getBestAvailableBall(senderID);
                    if (!bestBall) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ƒë√£ h·∫øt b√≥ng trong kho!\n" +
                            "D√πng .poke buy ƒë·ªÉ mua th√™m b√≥ng.",
                            threadID,
                            messageID
                        );
                    }

                    const catchResult = await pokeSystem.catch(senderID, catchData, bestBall.type);
                    if (catchResult?.error === "catchCooldown") {
                        const timeLeft = Math.ceil(catchResult.timeLeft / 1000);
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        return api.sendMessage(
                            `‚è≥ B·∫°n c·∫ßn ƒë·ª£i ${minutes}:${seconds < 10 ? '0' : ''}${seconds} ph√∫t n·ªØa ƒë·ªÉ b·∫Øt ti·∫øp!\n` +
                            "‚Üí Th·ª≠ l√†m nhi·ªám v·ª• kh√°c trong l√∫c ch·ªù nh√©!",
                            threadID,
                            messageID
                        );
                    }

                    const catchMsg = await api.sendMessage({
                        body: `üéØ B·∫°n ƒë√£ g·∫∑p ${catchData.name} (C·∫•p ${catchData.level})!\n` +
                             `üí™ Ch·ªâ s·ªë:\n` +
                             `‚ù§Ô∏è HP: ${catchData.hp}\n` +
                             `‚öîÔ∏è T·∫•n c√¥ng: ${catchData.attack}\n` +
                             `üõ°Ô∏è Ph√≤ng th·ªß: ${catchData.defense}\n` +
                             `üé≠ H·ªá: ${catchData.types.map(t => 
                                 `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                             ).join(' | ')}\n\n` +
                             `${bestBall.ball.emoji} S·∫Ω d√πng ${bestBall.ball.name} ƒë·ªÉ b·∫Øt (c√≤n ${bestBall.count} b√≥ng)\n\n` +
                             "Reply 'yes' ƒë·ªÉ b·∫Øt, 'no' ƒë·ªÉ b·ªè qua.",
                        attachment: fs.createReadStream(imagePath)
                    }, threadID);

                    global.client.onReply.push({
                        name: this.name,
                        messageID: catchMsg.messageID,
                        author: senderID,
                        type: "catch",
                        pokemon: catchData,
                        bestBall: bestBall.type
                    });
                    return;

                case "list":
                case "bag":
                    const page = parseInt(param) || 1;
                    const bagData = await pokeSystem.getBag(senderID, page);
                    
                    if (!bagData) {
                        return api.sendMessage("B·∫°n ch∆∞a c√≥ Pokemon n√†o! D√πng .poke catch ƒë·ªÉ b·∫Øt Pokemon.", threadID, messageID);
                    }

                    let msg = "üéí BAG POKEMON C·ª¶A B·∫†N üéí\n" + 
                             `Trang ${bagData.pagination.current}/${bagData.pagination.total}\n` +
                             "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                    
                    bagData.pokemons.forEach((p, idx) => {
                        const actualIndex = bagData.pagination.start + idx;
                        const isActive = actualIndex === bagData.player.activePokemon;
                        const types = p.types.map(type => 
                            `${pokeSystem.getTypeEmoji(type)} ${pokeSystem.getTypeName(type)}`
                        ).join(' | ');
                        const power = pokeSystem.calculatePower(p);
                        
                        msg += `${isActive ? "üëâ " : ""}${actualIndex + 1}. ${p.name.toUpperCase()}\n`;
                        msg += `   Lv.${p.level} | üé≠ H·ªá: ${types}\n`;
                        msg += `   ‚ù§Ô∏è HP:${p.hp} | ‚öîÔ∏è ATK:${p.attack} | üõ°Ô∏è DEF:${p.defense}\n`;
                        msg += `   üí™ S·ª©c m·∫°nh: ${pokeSystem.getPowerBar(power)} ${power}\n`;
                        if (isActive) msg += `   üéØ Pokemon ƒëang ƒë∆∞·ª£c ch·ªçn\n`;
                        msg += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n";
                    });

                    msg += `\nüìë Trang ${bagData.pagination.current}/${bagData.pagination.total}\n`;
                    msg += `T·ªïng s·ªë Pokemon: ${bagData.pagination.totalItems}\n\n`;
                    msg += "H∆∞·ªõng d·∫´n:\n";
                    msg += "‚Ä¢ Xem trang: .poke bag [s·ªë trang]\n";
                    msg += "‚Ä¢ Ch·ªçn Pokemon: .poke select [s·ªë th·ª© t·ª±]\n";
                    msg += "‚Ä¢ T√¨m theo t√™n: .poke find [t√™n]\n";

                    return api.sendMessage(msg, threadID, messageID);

                case "find":
                case "search":
                    if (!param) {
                        return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p t√™n Pokemon c·∫ßn t√¨m!", threadID, messageID);
                    }

                    const foundPokemons = await pokeSystem.search(senderID, param);
                    if (!foundPokemons || foundPokemons.length === 0) {
                        return api.sendMessage(`‚ùå Kh√¥ng t√¨m th·∫•y Pokemon n√†o c√≥ t√™n "${param}"!`, threadID, messageID);
                    }

                    let searchMsg = `üîç T√åM TH·∫§Y ${foundPokemons.length} POKEMON:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                    foundPokemons.forEach((p, idx) => {
                        const types = p.types.map(type => pokeSystem.getTypeEmoji(type)).join(' ');
                        const power = pokeSystem.calculatePower(p);
                        searchMsg += `${idx + 1}. ${p.name.toUpperCase()} ${types}\n`;
                        searchMsg += `   Lv.${p.level} | HP:${p.hp} | ATK:${p.attack} | DEF:${p.defense}\n`;
                        searchMsg += `   üí™ Power: ${pokeSystem.getPowerBar(power)} ${power}\n`;
                        searchMsg += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n";
                    });

                    return api.sendMessage(searchMsg, threadID, messageID);

                case "select":
                    const index = parseInt(param) - 1;
                    if (isNaN(index)) {
                        return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p s·ªë th·ª© t·ª± Pokemon!", threadID, messageID);
                    }

                    const success = await pokeSystem.selectPokemon(senderID, index);
                    if (!success) {
                        return api.sendMessage("‚ùå Pokemon kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                    }

                    const selectedPokemon = await pokeSystem.getSelectedPokemon(senderID);
                    return api.sendMessage(
                        `‚úÖ ƒê√£ ch·ªçn ${selectedPokemon.name.toUpperCase()} l√†m Pokemon thi ƒë·∫•u!`,
                        threadID,
                        messageID
                    );

                case "battle":
                    const mentionedId = Object.keys(event.mentions)[0];
                    if (!mentionedId) {
                        return api.sendMessage(
                            "‚ùå Vui l√≤ng tag ng∆∞·ªùi b·∫°n mu·ªën th√°ch ƒë·∫•u!\n" +
                            "üí° C√°ch d√πng: .poke battle @t√™n_ng∆∞·ªùi_ch∆°i",
                            threadID, 
                            messageID
                        );
                    }

                    const player1Pokemon = await pokeSystem.getSelectedPokemon(senderID);
                    const player2Pokemon = await pokeSystem.getSelectedPokemon(mentionedId);

                    if (!player1Pokemon) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ch∆∞a c√≥ Pokemon n√†o ƒë∆∞·ª£c ch·ªçn!\n" +
                            "1Ô∏è‚É£ D√πng .poke catch ƒë·ªÉ b·∫Øt Pokemon\n" +
                            "2Ô∏è‚É£ D√πng .poke select [s·ªë] ƒë·ªÉ ch·ªçn Pokemon",
                            threadID,
                            messageID
                        );
                    }

                    if (!player2Pokemon) {
                        return api.sendMessage(
                            "‚ùå ƒê·ªëi th·ªß ch∆∞a c√≥ Pokemon n√†o ƒë∆∞·ª£c ch·ªçn!\n" +
                            "‚Üí H√£y nh·∫Øc ƒë·ªëi th·ªß b·∫Øt v√† ch·ªçn Pokemon tr∆∞·ªõc khi th√°ch ƒë·∫•u",
                            threadID,
                            messageID
                        );
                    }

                    const battleResult = await pokeSystem.battle(senderID, mentionedId, threadID);
                    const player = await pokeSystem.getPlayer(senderID);

                    await api.sendMessage(
                        "‚öîÔ∏è BATTLE POKEMON ‚öîÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üëä ${player1Pokemon.name.toUpperCase()} (Lv.${player1Pokemon.level})\n` +
                        `üé≠ H·ªá: ${player1Pokemon.types.map(t => 
                            `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                        ).join(' | ')}\n` +
                        `   ‚ù§Ô∏è HP: ${player1Pokemon.hp}\n` +
                        `   ‚öîÔ∏è ATK: ${player1Pokemon.attack}\n` +
                        `   üõ°Ô∏è DEF: ${player1Pokemon.defense}\n\n` +
                        `‚öîÔ∏è VS ‚öîÔ∏è\n\n` +
                        `üëä ${player2Pokemon.name.toUpperCase()} (Lv.${player2Pokemon.level})\n` +
                        `üé≠ H·ªá: ${player2Pokemon.types.map(t => 
                            `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                        ).join(' | ')}\n` +
                        `   ‚ù§Ô∏è HP: ${player2Pokemon.hp}\n` +
                        `   ‚öîÔ∏è ATK: ${player2Pokemon.attack}\n` +
                        `   üõ°Ô∏è DEF: ${player2Pokemon.defense}\n\n` +
                        "üéØ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu trong 20 gi√¢y...",
                        threadID
                    );

                    await new Promise(resolve => setTimeout(resolve, 20000));

                    const battleFinalMsg = "üèÜ K·∫æT QU·∫¢ CU·ªêI C√ôNG üèÜ\n" +
                                   "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                   `üëë Ng∆∞·ªùi th·∫Øng: ${battleResult.winner.name.toUpperCase()}\n` +
                                   `‚ù§Ô∏è HP c√≤n l·∫°i: ${battleResult.winner.remainingHp}\n` +
                                   `‚ú® EXP nh·∫≠n ƒë∆∞·ª£c: ${battleResult.expGained || 0}\n\n` +
                                   `üíÄ Ng∆∞·ªùi thua: ${battleResult.loser.name.toUpperCase()}\n` +
                                   `‚ù§Ô∏è HP c√≤n l·∫°i: ${battleResult.loser.remainingHp}\n\n` +
                                   `üí° D√πng .poke info ƒë·ªÉ xem th·ªëng k√™ tr·∫≠n ƒë·∫•u`;

                    await api.sendMessage(battleFinalMsg, threadID, messageID);

                    if (battleResult.winner.id === senderID && player) { 
                        const levelUp = await pokeSystem.checkLevelUp(senderID, player.activePokemon);
                        if (levelUp && levelUp !== true) {
                            await this.handleEvolution(api, threadID, levelUp);
                        }
                    }

                    return;

                case "wild":
                case "pve":
                    const playerPokemon = await pokeSystem.getSelectedPokemon(senderID);
                    if (!playerPokemon) {
                        return api.sendMessage(
                            "‚ùå B·∫°n ch∆∞a c√≥ Pokemon n√†o ƒë∆∞·ª£c ch·ªçn!\n" +
                            "1Ô∏è‚É£ D√πng .poke catch ƒë·ªÉ b·∫Øt Pokemon\n" +
                            "2Ô∏è‚É£ D√πng .poke select [s·ªë] ƒë·ªÉ ch·ªçn Pokemon",
                            threadID,
                            messageID
                        );
                    }

                    const pveResult = await pokeSystem.pve(senderID);
                    const pvePlayer = await pokeSystem.getPlayer(senderID); 
                    
                    if (pveResult?.error === "cooldown") {
                        const timeLeft = Math.ceil(pveResult.timeLeft / 1000);
                        return api.sendMessage(
                            `‚ùå B·∫°n c·∫ßn ƒë·ª£i ${timeLeft} gi√¢y n·ªØa ƒë·ªÉ ti·∫øp t·ª•c ƒë√°nh wild Pokemon!`,
                            threadID,
                            messageID
                        );
                    }

                    const wildPokemon = pveResult.winner === playerPokemon ? pveResult.loser : pveResult.winner;
                    
                    await api.sendMessage(
                        "‚öîÔ∏è WILD POKEMON BATTLE ‚öîÔ∏è\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üëä ${playerPokemon.name.toUpperCase()} (Lv.${playerPokemon.level})\n` +
                        `üé≠ H·ªá: ${playerPokemon.types.map(t => 
                            `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                        ).join(' | ')}\n` +
                        `   ‚ù§Ô∏è HP: ${playerPokemon.hp}\n` +
                        `   ‚öîÔ∏è ATK: ${playerPokemon.attack}\n` +
                        `   üõ°Ô∏è DEF: ${playerPokemon.defense}\n\n` +
                        `üÜö VS üÜö\n\n` +
                        `üëä ${wildPokemon.name.toUpperCase()} (Lv.${wildPokemon.level})\n` +
                        `üé≠ H·ªá: ${wildPokemon.types.map(t => 
                            `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                        ).join(' | ')}\n` +
                        `   ‚ù§Ô∏è HP: ${wildPokemon.hp}\n` +
                        `   ‚öîÔ∏è ATK: ${wildPokemon.attack}\n` +
                        `   üõ°Ô∏è DEF: ${wildPokemon.defense}\n\n` +
                        "üéØ Tr·∫≠n ƒë·∫•u b·∫Øt ƒë·∫ßu trong 15 gi√¢y...",
                        threadID
                    );

                    await new Promise(resolve => setTimeout(resolve, 15000));

                    const finalMsg = "üèÜ K·∫æT QU·∫¢ TR·∫¨N ƒê·∫§U üèÜ\n" +
                                   "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                   `${pveResult.winner === playerPokemon ? "üéâ B·∫°n ƒë√£ chi·∫øn th·∫Øng!" : "üíÄ B·∫°n ƒë√£ thua!"}\n\n` +
                                   `üëä ${playerPokemon.name.toUpperCase()}\n` +
                                   `‚ù§Ô∏è HP c√≤n l·∫°i: ${pveResult.finalHP.player}\n` +
                                   (pveResult.winner === playerPokemon ? 
                                    `‚ú® EXP nh·∫≠n ƒë∆∞·ª£c: ${pveResult.expGained}\n` +
                                    `üí∞ Coins nh·∫≠n ƒë∆∞·ª£c: ${pveResult.rewardCoins.toLocaleString()} xu\n` : "") +
                                   `\nüÜö ${wildPokemon.name.toUpperCase()}\n` +
                                   `‚ù§Ô∏è HP c√≤n l·∫°i: ${pveResult.finalHP.wild}`;

                    await api.sendMessage(finalMsg, threadID, messageID);

                    if (pveResult.winner === playerPokemon && pvePlayer) { 
                        const levelUp = await pokeSystem.checkLevelUp(senderID, pvePlayer.activePokemon);
                        if (levelUp && levelUp !== true) {
                            await this.handleEvolution(api, threadID, levelUp);
                        }
                    }

                    return;

                case "balls":
                case "inventory":
                    if (!player) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a c√≥ d·ªØ li·ªáu Pokemon!", threadID, messageID);
                    }

                    const userBalance = currencies.getBalance(senderID);
                    const inv = player.inventory;
                    const ballList = Object.entries(pokeSystem.POKEBALLS)
                        .map(([key, ball]) => 
                            `${ball.emoji} ${ball.name}: ${inv[key] || 0} (${ball.price.toLocaleString()}ƒë)`
                        ).join('\n');

                    return api.sendMessage(
                        "üéí KHO POK√âBALL üéí\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                        ballList + "\n\n" +
                        `üí∞ S·ªë d∆∞: ${userBalance.toLocaleString()} xu\n` +
                        "Mua b√≥ng: .poke buy <lo·∫°i> <s·ªë l∆∞·ª£ng>\n" +
                        "V√≠ d·ª•: .poke buy ultraball 5",
                        threadID,
                        messageID
                    );

                case "buy":
                    if (!param) {
                        const priceList = Object.entries(pokeSystem.POKEBALLS)
                            .map(([key, ball]) => 
                                `${ball.emoji} ${ball.name}: ${ball.price.toLocaleString()} xu`
                            ).join('\n');
                            
                        return api.sendMessage(
                            "üìç B·∫¢NG GI√Å POK√âBALL üìç\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                            priceList + "\n\n" +
                            "C√°ch d√πng: .poke buy <lo·∫°i> <s·ªë l∆∞·ª£ng>\n" +
                            "V√≠ d·ª•: .poke buy ultraball 5",
                            threadID,
                            messageID
                        );
                    }

                    const [ballType, amount] = param.split(" ");
                    const quantity = parseInt(amount) || 1;

                    const purchase = await pokeSystem.buyBall(senderID, ballType, quantity);
                    
                    if (purchase.error) {
                        const errors = {
                            noPlayer: "‚ùå B·∫°n ch∆∞a c√≥ d·ªØ li·ªáu Pokemon!",
                            invalidBall: "‚ùå Lo·∫°i b√≥ng kh√¥ng h·ª£p l·ªá!",
                            insufficientCoins: `‚ùå Kh√¥ng ƒë·ªß ti·ªÅn!\nüí∞ Gi√°: ${purchase.required.toLocaleString()} xu\nüíµ S·ªë d∆∞: ${purchase.balance.toLocaleString()} xu`
                        };
                        return api.sendMessage(errors[purchase.error], threadID, messageID);
                    }

                    const ball = pokeSystem.POKEBALLS[ballType];
                    const ballImage = await axios.get(ball.image, { responseType: 'arraybuffer' });
                    const tempPath = path.join(__dirname, 'cache', `pokeball_${ballType}.png`);
                    await fs.promises.writeFile(tempPath, ballImage.data);

                    return api.sendMessage(
                        {
                            body: `‚úÖ ƒê√£ mua ${quantity} ${purchase.ballType}\n` +
                                `üí∞ T·ªïng gi√°: ${purchase.cost.toLocaleString()} xu\n` +
                                `üíµ S·ªë d∆∞ c√≤n l·∫°i: ${purchase.remaining.toLocaleString()} xu`,
                            attachment: fs.createReadStream(tempPath)
                        },
                        threadID,
                        messageID
                    );

                case "info": {
                    const playerStats = await pokeSystem.getPlayerStats(senderID);
                    if (!playerStats) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a c√≥ d·ªØ li·ªáu Pokemon!", threadID, messageID);
                    }

                    const activePokemon = await pokeSystem.getSelectedPokemon(senderID);
                    const userBalance = currencies.getBalance(senderID);

                    let msg = "üìä TH·ªêNG K√ä POKEMON üìä\n" +
                             "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                             `üí∞ S·ªë d∆∞: ${userBalance.toLocaleString()}xu\n` +
                             `üì¶ T·ªïng s·ªë Pokemon: ${playerStats.totalPokemon}\n` +
                             `‚öîÔ∏è S·ªë tr·∫≠n ƒë·∫•u: ${playerStats.battles}\n` +
                             `üèÜ S·ªë tr·∫≠n th·∫Øng: ${playerStats.wins}\n` +
                             `üìà T·ª∑ l·ªá th·∫Øng: ${playerStats.winRate}%\n\n`;

                    if (activePokemon) {
                        msg += "üéØ POKEMON ƒêANG CH·ªåN:\n" +
                              `üëä ${activePokemon.name.toUpperCase()} (Lv.${activePokemon.level})\n` +
                              `üé≠ H·ªá: ${activePokemon.types.map(t => 
                                  `${pokeSystem.getTypeEmoji(t)} ${pokeSystem.getTypeName(t)}`
                              ).join(' | ')}\n` +
                              `‚ù§Ô∏è HP: ${activePokemon.hp}/${activePokemon.maxHp}\n` +
                              `‚öîÔ∏è T·∫•n c√¥ng: ${activePokemon.attack}\n` +
                              `üõ°Ô∏è Ph√≤ng th·ªß: ${activePokemon.defense}\n` +
                              `‚ú® EXP: ${activePokemon.exp}/${activePokemon.expNeeded}\n` +
                              `üéØ S·ªë tr·∫≠n: ${activePokemon.battles || 0}\n` +
                              `üèÜ S·ªë th·∫Øng: ${activePokemon.wins || 0}\n`;
                    }

                    if (playerStats.strongestPokemon) {
                        msg += "\nüí™ POKEMON M·∫†NH NH·∫§T:\n" +
                              `üëä ${playerStats.strongestPokemon.name.toUpperCase()}\n` +
                              `üéñÔ∏è Level: ${playerStats.strongestPokemon.level}\n` +
                              `üí™ S·ª©c m·∫°nh: ${pokeSystem.getPowerBar(playerStats.strongestPokemon.power)} ${playerStats.strongestPokemon.power}`;
                    }

                    return api.sendMessage(msg, threadID, messageID);
                }

                default:
                    return api.sendMessage(
                        "üìå H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG:\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "1. .poke catch - B·∫Øt Pokemon m·ªõi\n" +
                        "2. .poke bag [trang] - Xem t√∫i Pokemon\n" +
                        "3. .poke select [s·ªë] - Ch·ªçn Pokemon\n" +
                        "4. .poke battle [@tag] - ƒê·∫•u Pokemon\n" +
                        "5. .poke wild - ƒê√°nh Pokemon hoang d√£\n" +
                        "6. .poke info - Xem th·ªëng k√™\n" +
                        "7. .poke find [t√™n] - T√¨m Pokemon\n" +
                        "8. .poke balls - Xem kho b√≥ng\n" +
                        "9. .poke buy [lo·∫°i] [s·ªë l∆∞·ª£ng] - Mua b√≥ng\n" +
                        "üìå L∆ØU √ù:\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                        "‚Ä¢ M·ªói ng∆∞·ªùi ch∆°i ch·ªâ c√≥ th·ªÉ ch·ªçn 1 Pokemon ƒë·ªÉ tham gia tr·∫≠n ƒë·∫•u\n",    
                        threadID,
                        messageID
                    );
            }
        } catch (error) {
            console.error(error);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói!", threadID, messageID);
        }
    },

    onReply: async function({ api, event }) {
        const { threadID, messageID, senderID, body } = event;
        const reply = global.client.onReply.find(r => r.messageID === event.messageReply.messageID && r.author === senderID);
        if (!reply) return;

        global.client.onReply = global.client.onReply.filter(r => r.messageID !== reply.messageID);

        switch (reply.type) {
            case "catch": {
                const answer = body.toLowerCase();
                if (answer === "no") {
                    return api.sendMessage("‚ùå ƒê√£ b·ªè qua Pokemon n√†y.", threadID);
                }

                if (answer !== "yes") {
                    return api.sendMessage(
                        "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!\n" +
                        "Reply 'yes' ƒë·ªÉ b·∫Øt ho·∫∑c 'no' ƒë·ªÉ b·ªè qua.",
                        threadID
                    );
                }

                const result = await pokeSystem.catch(senderID, reply.pokemon, reply.bestBall);
                
                if (result.error === "noBall") {
                    const ballList = Object.entries(result.inventory)
                        .map(([key, count]) => 
                            `${pokeSystem.POKEBALLS[key].emoji} ${pokeSystem.POKEBALLS[key].name}: ${count}`
                        ).join('\n');

                    return api.sendMessage(
                        "‚ùå ƒê√£ h·∫øt b√≥ng trong kho!\n\n" +
                        "üéí Kho b√≥ng hi·ªán t·∫°i:\n" +
                        ballList + "\n\n" +
                        "‚Üí D√πng .poke buy ƒë·ªÉ mua th√™m",
                        threadID
                    );
                }

                if (result.error === "failed") {
                    const ballList = Object.entries(result.inventory)
                        .map(([key, count]) => 
                            `${pokeSystem.POKEBALLS[key].emoji} ${pokeSystem.POKEBALLS[key].name}: ${count}`
                        ).join('\n');

                    return api.sendMessage(
                        `üí¢ Ti·∫øc qu√°! ${reply.pokemon.name} ƒë√£ tho√°t kh·ªèi ${result.ballUsed}!\n` +
                        `C√≤n l·∫°i ${result.ballsLeft} ${result.ballUsed}\n\n` +
                        "üéí Kho b√≥ng hi·ªán t·∫°i:\n" +
                        ballList,
                        threadID
                    );
                }

                return api.sendMessage(
                    `üéâ Thu ph·ª•c th√†nh c√¥ng ${result.pokemon.name} b·∫±ng ${result.ballUsed}!\n` +
                    `üìä ƒê√£ th√™m v√†o b·ªô s∆∞u t·∫≠p c·ªßa b·∫°n.`,
                    threadID
                );
            }
        }
    }
};
