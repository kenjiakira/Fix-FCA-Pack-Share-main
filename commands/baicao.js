const { getBalance, updateBalance, updateQuestProgress } = require('../utils/currencies');
const path = require('path');
const fs = require('fs');

function formatNumber(number) {
    if (number === undefined || number === null) return '0';
    return number.toLocaleString('vi-VN');  
}

module.exports = {
    name: "baicao",
    dev: "HNT",
    usedby: 0,
    info: "Ch∆°i b√†i c√†o nhi·ªÅu ng∆∞·ªùi",
    onPrefix: true,
    usages: "baicao create/join/start/leave/bet",
    cooldowns: 0,

    gameRooms: new Map(),
    autoCloseTimers: new Map(),
    playerStats: new Map(), // L∆∞u th·ªëng k√™ ng∆∞·ªùi ch∆°i

    RANKINGS: {
        SAP: 7,    
        LIENG: 6, 
        ANH: 5,  
        DONGCHAT: 4, 
        THUONG: 0 
    },

    onLaunch: async function({ api, event, target = [] }) {
        try {
            const { threadID, messageID, senderID } = event;
            
            const getUserName = (uid) => {
                try {
                    const userDataFile = path.join(__dirname, '../events/cache/userData.json');
                    const userData = JSON.parse(fs.readFileSync(userDataFile, 'utf8'));
                    return userData[uid]?.name || uid.toString();
                } catch (err) {
                    console.error(`Error getting username for ${uid}:`, err);
                    return uid.toString();
                }
            };

            if (!target[0]) {
                return api.sendMessage(
                    "üé¥ B√ÄI C√ÄO (Li√™ng)\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    "üéØ H∆∞·ªõng d·∫´n:\n" +
                    ".baicao create: T·∫°o b√†n (m·∫∑c ƒë·ªãnh 10,000 Xu)\n" +
                    ".baicao join: Tham gia\n" +
                    ".baicao start: B·∫Øt ƒë·∫ßu v√°n\n" +
                    ".baicao out: R·ªùi b√†n trong khi ch∆°i (m·∫•t ti·ªÅn c∆∞·ª£c)\n" +
                    ".baicao up [s·ªë ti·ªÅn]: TƒÉng ti·ªÅn c∆∞·ª£c c·ªßa b·∫£n th√¢n\n" +
                    ".baicao kick [@tag]: Kick ng∆∞·ªùi ch∆°i (ch·ªß b√†n)\n" +
                    ".baicao stop: D·ª´ng v√°n ƒë·∫•u (ch·ªß b√†n)\n" +
                    "üìù Th·ª© t·ª± c√°c lo·∫°i b√†i:\n" +
                    "1. S√°p: Ba l√° b√†i gi·ªëng nhau (VD: 666)\n" +
                    "2. Li√™ng: D√¢y li√™n ti·∫øp 123\n" +
                    "3. ·∫¢nh: Ba l√° b√†i ƒë·∫ßu ng∆∞·ªùi J,Q,K (VD: JJQ, KKK, JQK)\n" + 
                    "4. ƒê·ªìng ch·∫•t: 3 l√° c√πng ch·∫•t (VD: ‚ô†Ô∏è‚ô†Ô∏è‚ô†Ô∏è)\n" +
                    "5. T√≠nh ƒëi·ªÉm: T·ªïng 3 l√° chia l·∫•y d∆∞ cho 10\n\n" +
                    "üíé Gi√° tr·ªã:\n" +
                    "- A = 1 ƒëi·ªÉm\n" +
                    "- 2-9 = 2-9 ƒëi·ªÉm\n" +
                    "- 10, J, Q, K = 10 ƒëi·ªÉm\n" +
                    "- Ch·∫•t b√†i: ‚ô†Ô∏è > ‚ô£Ô∏è > ‚ô¶Ô∏è > ‚ô•Ô∏è\n\n" +
                    "‚ö°Ô∏è L∆∞u √Ω:\n" +
                    "- M·ªói b√†n t·ªëi ƒëa 8 ng∆∞·ªùi\n" +
                    "- C∆∞·ª£c kh·ªüi ƒëi·ªÉm 10,000 xu/ng∆∞·ªùi\n" +
                    "- V√°n m·ªõi t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu sau 2 ph√∫t\n" +
                    "- Ph√≠ th·∫Øng game 5%", 
                    threadID
                );
            }

            const command = target[0].toLowerCase();
            const room = this.gameRooms.get(threadID);

            if (this.autoCloseTimers.has(threadID)) {
                clearTimeout(this.autoCloseTimers.get(threadID));
                this.autoCloseTimers.delete(threadID);
            }

            switch (command) {
                case "create":
                    try {
                        if (room) {
                            if (room.status === "playing") {
                                return api.sendMessage("‚ùå ƒêang c√≥ v√°n ƒëang di·ªÖn ra!", threadID);
                            }
                            return api.sendMessage("‚ùå ƒê√£ c√≥ b√†n ƒë∆∞·ª£c t·∫°o! H√£y tham gia ho·∫∑c ƒë·ª£i v√°n k·∫øt th√∫c.", threadID);
                        }

                        const hostBalance = getBalance(senderID);
                        if (hostBalance < 10000) {
                            return api.sendMessage(`B·∫°n kh√¥ng ƒë·ªß 10,000 Xu ƒë·ªÉ t·∫°o b√†n!`, threadID);
                        }

                        const hostName = getUserName(senderID);
                        this.gameRooms.set(threadID, {
                            host: senderID,
                            hostName: hostName,
                            players: [{id: senderID, name: hostName, cards: [], total: 0, ready: false, betAmount: 10000}],
                            status: "waiting",
                            deck: null,
                            betAmount: 10000,  // Add default bet amount here
                            allowPlayerUp: false // Th√™m thu·ªôc t√≠nh m·ªõi - m·∫∑c ƒë·ªãnh ch·ªâ host up ƒë∆∞·ª£c
                        });

                        // Kh·ªüi t·∫°o th·ªëng k√™ cho host
                        if (!this.playerStats.has(senderID)) {
                            this.playerStats.set(senderID, {
                                gamesPlayed: 0,
                                gamesWon: 0,
                                totalEarnings: 0,
                                lastGameTime: Date.now()
                            });
                        }

                        this.autoCloseTimers.set(threadID, setTimeout(() => {
                            if (this.gameRooms.has(threadID) && this.gameRooms.get(threadID).status === "waiting") {
                                api.sendMessage("‚åõ B√†n ƒë√£ t·ª± ƒë·ªông ƒë√≥ng do kh√¥ng c√≥ ng∆∞·ªùi ch∆°i trong 2 ph√∫t!", threadID);
                                this.gameRooms.delete(threadID);
                                this.autoCloseTimers.delete(threadID);
                            }
                        }, 120000));

                        return api.sendMessage(
                            `üé¥ ${hostName} ƒë√£ t·∫°o b√†n!\n` +
                            `üí∞ Ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu: 10,000 Xu\n` +
                            `‚è≥ B√†n s·∫Ω t·ª± ƒë·ªông ƒë√≥ng sau 2 ph√∫t n·∫øu kh√¥ng b·∫Øt ƒë·∫ßu!`, 
                            threadID
                        );
                    } catch (err) {
                        console.error("Error creating room:", err);
                        return api.sendMessage("C√≥ l·ªói x·∫£y ra khi t·∫°o b√†n!", threadID);
                    }

                case "join":
                    try {
                        if (!room) return api.sendMessage("Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID);
                        if (room.status !== "waiting") return api.sendMessage("V√°n ƒëang di·ªÖn ra!", threadID);
                        if (room.players.find(p => p.id === senderID)) return api.sendMessage("B·∫°n ƒë√£ ·ªü trong b√†n!", threadID);
                        if (room.players.length >= 8) return api.sendMessage("B√†n ƒë√£ ƒë·∫ßy!", threadID);

                        const defaultBet = room.betAmount || 10000; // Fallback to 10000 if undefined
                        const balance = getBalance(senderID);
                        if (balance < defaultBet) {
                            return api.sendMessage(
                                `‚ùå B·∫°n kh√¥ng ƒë·ªß ${formatNumber(defaultBet)} Xu ƒë·ªÉ tham gia b√†n n√†y!`, 
                                threadID
                            );
                        }

                        // Ki·ªÉm tra l·ªãch s·ª≠ th·∫Øng thua
                        const playerStat = this.playerStats.get(senderID) || {
                            gamesPlayed: 0,
                            gamesWon: 0,
                            totalEarnings: 0,
                            lastGameTime: 0
                        };
                        
                        // N·∫øu ng∆∞·ªùi ch∆°i th·∫Øng nhi·ªÅu v√† r·ªùi b√†n qu√° nhanh
                        const timeSinceLastGame = Date.now() - playerStat.lastGameTime;
                        if (playerStat.totalEarnings > 1000000 && timeSinceLastGame < 300000) { // 5 ph√∫t
                            return api.sendMessage(
                                "‚ùå B·∫°n c·∫ßn ƒë·ª£i th√™m m·ªôt l√∫c ƒë·ªÉ v√†o ch∆°i ti·∫øp!\n" +
                                "‚è≥ Th·ªùi gian c√≤n l·∫°i: " + Math.ceil((300000 - timeSinceLastGame)/60000) + " ph√∫t",
                                threadID
                            );
                        }
                        
                        const playerName = getUserName(senderID);
                        room.players.push({
                            id: senderID, 
                            name: playerName, 
                            cards: [], 
                            total: 0, 
                            ready: false,
                            betAmount: defaultBet
                        });
                        const playerList = room.players.map(p => p.name).join(", ");
                        return api.sendMessage(
                            `üë§ ${playerName} ƒë√£ tham gia!\n` +
                            `Ng∆∞·ªùi ch∆°i (${room.players.length}/8): ${playerList}\n` +
                            `üí∞ Ti·ªÅn c∆∞·ª£c: ${formatNumber(defaultBet)} Xu`,
                            threadID
                        );
                    } catch (err) {
                        console.error("Error joining game:", err);
                        return api.sendMessage("C√≥ l·ªói x·∫£y ra khi tham gia!", threadID);
                    }

                case "ready":
                    if (!room) return api.sendMessage("Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID);
                    if (!room.players.find(p => p.id === senderID)) return api.sendMessage("B·∫°n kh√¥ng trong b√†n!", threadID);
                    if (room.status !== "waiting_ready") return api.sendMessage("Ch∆∞a t·ªõi l√∫c ready!", threadID);
                    
                    const player = room.players.find(p => p.id === senderID);
                    if (player.ready) return api.sendMessage("B·∫°n ƒë√£ s·∫µn s√†ng r·ªìi!", threadID);
                    
                    player.ready = true;
                    const readyPlayers = room.players.filter(p => p.ready).length;
                    api.sendMessage(`üë§ ${player.name} ƒë√£ s·∫µn s√†ng! (${readyPlayers}/${room.players.length})`, threadID);

                    if (readyPlayers === room.players.length) {
                        room.status = "waiting";
                        api.sendMessage("üéÆ T·∫•t c·∫£ ƒë√£ s·∫µn s√†ng! Ch·ªß ph√≤ng c√≥ th·ªÉ b·∫Øt ƒë·∫ßu v√°n m·ªõi.", threadID);
                    }
                    break;

                case "start":
                    try {
                        if (!room) return api.sendMessage("Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID);
                        if (room.host !== senderID) return api.sendMessage("Ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu!", threadID);
                        if (room.players.length < 2) return api.sendMessage("C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ƒë·ªÉ ch∆°i!", threadID);
                        if (room.status !== "waiting") return api.sendMessage("Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu l√∫c n√†y!", threadID);

                        // Ki·ªÉm tra l·∫°i s·ªë d∆∞ c·ªßa t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
                        const insufficientPlayers = [];
                        for (let player of room.players) {
                            const pBalance = getBalance(player.id);
                            if (pBalance < room.betAmount) {
                                insufficientPlayers.push(player.name);
                            }
                        }

                        if (insufficientPlayers.length > 0) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√¨ c√°c ng∆∞·ªùi ch∆°i sau kh√¥ng ƒë·ªß ${formatNumber(room.betAmount)} Xu:\n` +
                                insufficientPlayers.join(", "),
                                threadID
                            );
                        }

                        // Tr·ª´ ti·ªÅn t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
                        for (let player of room.players) {
                            updateBalance(player.id, -room.betAmount);
                        }

                        room.status = "confirming";
                        await api.sendMessage(
                            `üé¥ B·∫Øt ƒë·∫ßu v√°n!\n` +
                            `üí∞ Ti·ªÅn c∆∞·ª£c: ${formatNumber(room.betAmount)} Xu/ng∆∞·ªùi\n` +
                            `üë• S·ªë ng∆∞·ªùi ch∆°i: ${room.players.length}\n` +
                            `üíµ T·ªïng ti·ªÅn: ${formatNumber(room.betAmount * room.players.length)} Xu\n` +
                            `ƒêang chia b√†i...`,
                            threadID
                        );
                        this.startGame(api, threadID);
                    } catch (err) {
                        console.error("Error starting game:", err);
                        return api.sendMessage("C√≥ l·ªói x·∫£y ra khi b·∫Øt ƒë·∫ßu v√°n!", threadID);
                    }
                    break;

                case "kick":
                    if (!room) return api.sendMessage("Kh√¥ng c√≥ b√†n n√†o!", threadID);
                    if (room.host !== senderID) return api.sendMessage("Ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c kick!", threadID);
                    const mentionId = Object.keys(event.mentions)[0];
                    if (!mentionId) return api.sendMessage("Vui l√≤ng tag ng∆∞·ªùi c·∫ßn kick!", threadID);
                    
                    const kickedPlayer = room.players.find(p => p.id === mentionId);
                    if (!kickedPlayer) return api.sendMessage("Ng∆∞·ªùi n√†y kh√¥ng c√≥ trong b√†n!", threadID);
                    
                    room.players = room.players.filter(p => p.id !== mentionId);
                    if (room.players.length < 2 && room.status === "playing") {
                        api.sendMessage("‚ùå S·ªë ng∆∞·ªùi ch∆°i kh√¥ng ƒë·ªß, v√°n ƒë·∫•u k·∫øt th√∫c!", threadID);
                        this.gameRooms.delete(threadID);
                        return;
                    }
                    
                    return api.sendMessage(`üë¢ ƒê√£ kick ${kickedPlayer.name} kh·ªèi b√†n!`, threadID);

                case "stop":
                    if (!room) return api.sendMessage("Kh√¥ng c√≥ b√†n n√†o!", threadID);
                    if (room.host !== senderID) return api.sendMessage("Ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c d·ª´ng!", threadID);
                    
                    api.sendMessage("üõë Ch·ªß b√†n ƒë√£ d·ª´ng v√°n ƒë·∫•u!", threadID);
                    this.gameRooms.delete(threadID);
                    return;

                case "out":
                    if (!room) return api.sendMessage("Kh√¥ng c√≥ b√†n n√†o!", threadID);
                    if (!room.players.find(p => p.id === senderID)) return api.sendMessage("B·∫°n kh√¥ng trong b√†n!", threadID);
                    if (room.status !== "playing") return api.sendMessage("Ch·ªâ c√≥ th·ªÉ out khi ƒëang ch∆°i!", threadID);
                    
                    const outPlayer = room.players.find(p => p.id === senderID);
                    room.players = room.players.filter(p => p.id !== senderID);

                    if (room.players.length < 2) {
                        api.sendMessage(
                            `üë§ ${outPlayer.name} ƒë√£ r·ªùi b√†n (m·∫•t ${formatNumber(room.betAmount)} Xu)\n` +
                            "‚ùå Kh√¥ng ƒë·ªß ng∆∞·ªùi ch∆°i, v√°n ƒë·∫•u k·∫øt th√∫c!", 
                            threadID
                        );
                        this.gameRooms.delete(threadID);
                        return;
                    }

                    if (room.host === senderID) {
                        room.host = room.players[0].id;
                        room.hostName = room.players[0].name;
                        api.sendMessage(
                            `üë§ ${outPlayer.name} ƒë√£ r·ªùi b√†n (m·∫•t ${formatNumber(room.betAmount)} Xu)\n` +
                            `üëë ${room.hostName} l√† ch·ªß b√†n m·ªõi!`,
                            threadID
                        );
                    } else {
                        api.sendMessage(
                            `üë§ ${outPlayer.name} ƒë√£ r·ªùi b√†n (m·∫•t ${formatNumber(room.betAmount)} Xu)`,
                            threadID
                        );
                    }
                    break;

                case "mode":
                    if (!room) return api.sendMessage("Kh√¥ng c√≥ b√†n n√†o!", threadID);
                    if (room.host !== senderID) return api.sendMessage("Ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c ƒë·ªïi ch·∫ø ƒë·ªô!", threadID);
                    if (room.status !== "waiting") return api.sendMessage("Ch·ªâ c√≥ th·ªÉ ƒë·ªïi ch·∫ø ƒë·ªô khi ch∆∞a b·∫Øt ƒë·∫ßu!", threadID);
                    
                    room.allowPlayerUp = !room.allowPlayerUp;
                    return api.sendMessage(
                        `üîÑ ƒê√£ ${room.allowPlayerUp ? "b·∫≠t" : "t·∫Øt"} ch·∫ø ƒë·ªô cho ph√©p ng∆∞·ªùi ch∆°i t·ª± ƒë·∫∑t c∆∞·ª£c\n` +
                        `‚ö°Ô∏è Hi·ªán t·∫°i: ${room.allowPlayerUp ? "Ai c≈©ng c√≥ th·ªÉ tƒÉng ti·ªÅn c∆∞·ª£c" : "Ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c tƒÉng ti·ªÅn c∆∞·ª£c"}`,
                        threadID
                    );

                case "up":
                    if (!room) return api.sendMessage("Kh√¥ng c√≥ b√†n n√†o!", threadID);
                    if (room.status !== "waiting") return api.sendMessage("Ch·ªâ c√≥ th·ªÉ tƒÉng ti·ªÅn khi ch∆∞a b·∫Øt ƒë·∫ßu!", threadID);
                    
                    if (!room.allowPlayerUp && senderID !== room.host) {
                        return api.sendMessage("‚ùå Hi·ªán t·∫°i ch·ªâ ch·ªß b√†n m·ªõi ƒë∆∞·ª£c tƒÉng ti·ªÅn c∆∞·ª£c!", threadID);
                    }
                    
                    const playerUp = room.players.find(p => p.id === senderID);
                    if (!playerUp) return api.sendMessage("B·∫°n kh√¥ng trong b√†n!", threadID);
                    
                    const upAmount = parseInt(target[1]);
                    if (!upAmount || upAmount <= playerUp.betAmount) {
                        return api.sendMessage(
                            `Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn cao h∆°n m·ª©c hi·ªán t·∫°i c·ªßa b·∫°n (${formatNumber(playerUp.betAmount)} Xu)`,
                            threadID
                        );
                    }

                    // N·∫øu kh√¥ng ph·∫£i host th√¨ ch·ªâ ƒë∆∞·ª£c up ti·ªÅn c·ªßa m√¨nh
                    if (senderID !== room.host) {
                        const balance = getBalance(senderID);
                        if (balance < upAmount) {
                            return api.sendMessage(
                                `‚ùå B·∫°n kh√¥ng ƒë·ªß ${formatNumber(upAmount)} Xu ƒë·ªÉ tƒÉng ti·ªÅn c∆∞·ª£c!`,
                                threadID
                            );
                        }
                        playerUp.betAmount = upAmount;
                        return api.sendMessage(
                            `üí∞ ${playerUp.name} ƒë√£ t·ª± ƒë·∫∑t m·ª©c c∆∞·ª£c ${formatNumber(upAmount)} Xu`,
                            threadID
                        );
                    }

                    // Ph·∫ßn code cho host up ti·ªÅn (gi·ªØ nguy√™n logic c≈©)
                    // Ki·ªÉm tra s·ªë d∆∞ c·ªßa t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
                    for (let p of room.players) {
                        const pBalance = getBalance(p.id);
                        if (pBalance < upAmount) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng th·ªÉ tƒÉng l√™n ${formatNumber(upAmount)} Xu v√¨ ng∆∞·ªùi ch∆°i ${p.name} kh√¥ng ƒë·ªß ti·ªÅn!`,
                                threadID
                            );
                        }
                    }

                    // C·∫≠p nh·∫≠t ti·ªÅn c∆∞·ª£c cho c·∫£ b√†n
                    room.betAmount = upAmount;
                    for (let p of room.players) {
                        p.betAmount = upAmount;
                    }

                    return api.sendMessage(
                        `üí∞ Ch·ªß b√†n ƒë√£ tƒÉng ti·ªÅn c∆∞·ª£c l√™n ${formatNumber(upAmount)} Xu\n` +
                        `‚ö†Ô∏è T·∫•t c·∫£ ng∆∞·ªùi ch∆°i s·∫Ω ph·∫£i c∆∞·ª£c ${formatNumber(upAmount)} Xu`,
                        threadID
                    );
            }
        } catch (err) {
            console.error("Main game error:", err);
            return api.sendMessage("C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i!", event.threadID);
        }
    },

    async startGame(api, threadID) {
        try {
            const room = this.gameRooms.get(threadID);
            if (!room) return;

            room.status = "playing";
            room.deck = this.createDeck();
            
            // Ki·ªÉm tra l·∫°i s·ªë d∆∞ tr∆∞·ªõc khi tr·ª´ ti·ªÅn
            let canPlay = true;
            for (let player of room.players) {
                const balance = getBalance(player.id);
                if (balance < player.betAmount) {
                    canPlay = false;
                    api.sendMessage(
                        `‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√¨ ${player.name} kh√¥ng ƒë·ªß ${formatNumber(player.betAmount)} Xu!`,
                        threadID
                    );
                    break;
                }
            }

            if (!canPlay) {
                room.status = "waiting";
                return;
            }

            // Tr·ª´ ti·ªÅn ng∆∞·ªùi ch∆°i
            for (let player of room.players) {
                updateBalance(player.id, -player.betAmount);
                player.hasPaid = true;
            }

            await api.sendMessage("üé¥ ƒêang chia b√†i...\n‚è≥ ƒê·ª£i 10 gi√¢y ƒë·ªÉ xem k·∫øt qu·∫£!", threadID);

            setTimeout(async () => {
                try {
                    for (let player of room.players) {
                        player.cards = room.deck.splice(0, 3);
                        player.total = this.calculateHand(player.cards).value; 
                    }

                    let resultMsg = `üé¥ K·∫øt qu·∫£ (C∆∞·ª£c: ${formatNumber(room.betAmount)} Xu):\n\n`;
                    
                    room.players.sort((a, b) => {
                        const handA = this.calculateHand(a.cards);
                        const handB = this.calculateHand(b.cards);
                        
                        if (handA.rank !== handB.rank) {
                            return handB.rank - handA.rank;
                        }
                        if (handA.value !== handB.value) {
                            return handB.value - handA.value;
                        }
                        return Math.max(...b.cards.map(c => this.getSuitValue(c.suit))) - 
                               Math.max(...a.cards.map(c => this.getSuitValue(c.suit)));
                    });

                    // S·ª≠a ph·∫ßn hi·ªÉn th·ªã k·∫øt qu·∫£ ƒë·ªÉ th√™m th√¥ng tin ti·ªÅn c∆∞·ª£c
                    for (let i = 0; i < room.players.length; i++) {
                        const player = room.players[i];
                        const hand = this.calculateHand(player.cards);
                        const cards = player.cards.map(c => `${c.value}${c.suit}`).join(" ");
                        resultMsg += `${i+1}. ${player.name} (C∆∞·ª£c: ${formatNumber(player.betAmount)} Xu)\n`; // Th√™m th√¥ng tin c∆∞·ª£c
                        resultMsg += `B√†i: ${cards}\n`;
                        resultMsg += `K·∫øt qu·∫£: ${hand.type} (${hand.value} ƒëi·ªÉm)\n\n`;
                    }

                    const winner = room.players[0];
                    const totalPot = room.players.reduce((sum, player) => sum + player.betAmount, 0);
                    // B·ªè ph√≠ 5%, winner nh·∫≠n to√†n b·ªô pot
                    const winnings = totalPot;

                    // C·∫≠p nh·∫≠t th·ªëng k√™ ng∆∞·ªùi th·∫Øng
                    const winnerStats = this.playerStats.get(winner.id) || {
                        gamesPlayed: 0,
                        gamesWon: 0,
                        totalEarnings: 0,
                        lastGameTime: Date.now()
                    };
                    
                    winnerStats.gamesPlayed++;
                    winnerStats.gamesWon++;
                    winnerStats.totalEarnings += winnings;
                    winnerStats.lastGameTime = Date.now();
                    this.playerStats.set(winner.id, winnerStats);

                    // C·∫≠p nh·∫≠t th·ªëng k√™ ng∆∞·ªùi thua
                    room.players.forEach(player => {
                        if (player.id !== winner.id) {
                            const stats = this.playerStats.get(player.id) || {
                                gamesPlayed: 0,
                                gamesWon: 0,
                                totalEarnings: 0,
                                lastGameTime: Date.now()
                            };
                            stats.gamesPlayed++;
                            stats.totalEarnings -= player.betAmount;
                            stats.lastGameTime = Date.now();
                            this.playerStats.set(player.id, stats);
                        }
                    });

                    // Th√™m th√¥ng tin th·ªëng k√™ v√†o tin nh·∫Øn k·∫øt qu·∫£
                    resultMsg += `\nüìä Th√¥ng k√™ ng∆∞·ªùi th·∫Øng:\n`;
                    resultMsg += `S·ªë v√°n th·∫Øng: ${winnerStats.gamesWon}\n`;
                    resultMsg += `T·ªïng thu: ${formatNumber(winnerStats.totalEarnings)} Xu\n`;

                    // Tr·∫£ ti·ªÅn cho winner
                    await updateBalance(winner.id, winnings);
                    await updateQuestProgress(winner.id, "win_games");

                    resultMsg += `\nüéâ Ng∆∞·ªùi th·∫Øng: ${winner.name}\n`;
                    resultMsg += `üí∞ Th·∫Øng: ${formatNumber(winnings)} Xu\n\n`;
                    resultMsg += "‚è≥ V√°n m·ªõi s·∫Ω b·∫Øt ƒë·∫ßu sau 45 gi√¢y...";

                    await api.sendMessage(resultMsg, threadID);

                    // Reset game state
                    room.status = "waiting";
                    room.deck = null;
                    for (let player of room.players) {
                        player.cards = [];
                        player.total = 0;
                        player.hasPaid = false; // Reset tr·∫°ng th√°i tr·ª´ ti·ªÅn
                    }

                    setTimeout(async () => {
                        if (this.gameRooms.has(threadID)) {
                            const room = this.gameRooms.get(threadID);
                            if (room.players.length >= 2) {
                                const kickedPlayers = [];
                                room.players = room.players.filter(player => {
                                    const balance = getBalance(player.id);
                                    if (balance < room.betAmount) { // S·ª≠a t·ª´ 10000 th√†nh room.betAmount
                                        kickedPlayers.push(player.name);
                                        return false;
                                    }
                                    return true;
                                });

                                if (kickedPlayers.length > 0) {
                                    await api.sendMessage(
                                        `‚ö†Ô∏è Nh·ªØng ng∆∞·ªùi ch∆°i sau ƒë√£ b·ªã kick do kh√¥ng ƒë·ªß ${formatNumber(room.betAmount)} Xu cho v√°n m·ªõi:\n${kickedPlayers.join(", ")}`,
                                        threadID
                                    );
                                }

                                if (room.players.length < 2) {
                                    api.sendMessage("‚ùå Kh√¥ng ƒë·ªß ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu v√°n m·ªõi!", threadID);
                                    this.gameRooms.delete(threadID);
                                    return;
                                }

                                if (!room.players.find(p => p.id === room.host)) {
                                    room.host = room.players[0].id;
                                    room.hostName = room.players[0].name;
                                    await api.sendMessage(
                                        `üëë ${room.hostName} l√† ch·ªß b√†n m·ªõi!`,
                                        threadID
                                    );
                                }

                                for (let player of room.players) {
                                    updateBalance(player.id, -room.betAmount); // S·ª≠a t·ª´ 10000 th√†nh room.betAmount
                                }
                                
                                await api.sendMessage(
                                    `üé¥ B·∫Øt ƒë·∫ßu v√°n m·ªõi!\n` +
                                    `üë• S·ªë ng∆∞·ªùi ch∆°i: ${room.players.length}\n` +
                                    `üí∞ Ti·ªÅn c∆∞·ª£c: ${formatNumber(room.betAmount)} Xu\n` + // Hi·ªÉn th·ªã ƒë√∫ng s·ªë ti·ªÅn c∆∞·ª£c hi·ªán t·∫°i
                                    `üíµ T·ªïng ti·ªÅn: ${formatNumber(room.betAmount * room.players.length)} Xu\n` +
                                    `ƒêang chia b√†i...`, 
                                    threadID
                                );
                                this.startGame(api, threadID);
                            } else {
                                api.sendMessage("‚ùå Kh√¥ng ƒë·ªß ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu v√°n m·ªõi!", threadID);
                                this.gameRooms.delete(threadID);
                            }
                        }
                    }, 45000); 

                } catch (err) {
                    // Ho√†n ti·ªÅn n·∫øu c√≥ l·ªói
                    if (room && room.players) {
                        for (let player of room.players) {
                            if (player.hasPaid) {
                                await updateBalance(player.id, player.betAmount);
                            }
                        }
                    }
                    console.error("Error in game completion:", err);
                    await api.sendMessage("C√≥ l·ªói x·∫£y ra khi k·∫øt th√∫c v√°n! ƒê√£ ho√†n ti·ªÅn cho ng∆∞·ªùi ch∆°i.", threadID);
                }
            }, 10000);

        } catch (err) {
            console.error("Fatal error in startGame:", err);
            await api.sendMessage("C√≥ l·ªói nghi√™m tr·ªçng x·∫£y ra!", threadID);
            this.gameRooms.delete(threadID);
        }
    },

    createDeck() {
        const suits = ["‚ô†Ô∏è", "‚ô£Ô∏è", "‚ô¶Ô∏è", "‚ô•Ô∏è"];
        const values = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
        let deck = [];
        
        for (let suit of suits) {
            for (let value of values) {
                deck.push({ suit, value });
            }
        }
        
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    },

    calculateHand(cards) {
        const values = cards.map(c => {
            if (c.value === "A") return 1;
            if (["J", "Q", "K"].includes(c.value)) return 10;
            return parseInt(c.value);
        });

        // Check S√°p (3 of a kind)
        if (cards[0].value === cards[1].value && cards[1].value === cards[2].value) {
            return {
                type: "SAP",
                rank: this.RANKINGS.SAP,
                value: parseInt(cards[0].value) || 10
            };
        }

        // Check Li√™ng (straight)
        const cardValues = cards.map(c => {
            if (c.value === "A") return 1;
            if (c.value === "J") return 11;
            if (c.value === "Q") return 12;
            if (c.value === "K") return 13;
            return parseInt(c.value);
        }).sort((a, b) => a - b);

        // Check regular straight (1,2,3 or consecutive numbers)
        const isRegularStraight = cardValues[0] + 1 === cardValues[1] && cardValues[1] + 1 === cardValues[2];
        // Check A,Q,K sequence (1,12,13)
        const isAQKStraight = cardValues[0] === 1 && cardValues[1] === 12 && cardValues[2] === 13;

        if (isRegularStraight || isAQKStraight) {
            return {
                type: "LIENG",
                rank: this.RANKINGS.LIENG,
                value: Math.max(...cardValues)
            };
        }

        if (cards.every(c => ["J", "Q", "K"].includes(c.value))) {
            return {
                type: "ANH",
                rank: this.RANKINGS.ANH,
                value: 10
            };
        }

        if (cards.every(c => c.suit === cards[0].suit)) {
            return {
                type: "DONGCHAT",
                rank: this.RANKINGS.DONGCHAT,
                value: Math.max(...values)
            };
        }

        return {
            type: "THUONG",
            rank: this.RANKINGS.THUONG,
            value: values.reduce((sum, val) => sum + val, 0) % 10
        };
    },

    getSuitValue(suit) {
        return ["‚ô†Ô∏è", "‚ô£Ô∏è", "‚ô¶Ô∏è", "‚ô•Ô∏è"].indexOf(suit);
    },

    calculateTotal(cards) {
        return cards.reduce((sum, card) => {
            if (card.value === "A") return sum + 1;
            if (["J", "Q", "K"].includes(card.value)) return sum + 10;
            return sum + parseInt(card.value);
        }, 0) % 10;
    }
};
