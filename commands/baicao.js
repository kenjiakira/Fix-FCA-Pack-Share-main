const { createBaicaoCanvas, createPlayerCardCanvas, createGameStateCanvas } = require('../game/canvas/baicaoCanvas');
const { getBalance, updateBalance } = require('../utils/currencies');
const path = require('path');
const fs = require('fs');

function formatNumber(number) {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
function getUserNameFromData(userId) {
    try {
        if (!global.userData) {
            const userDataPath = path.join(__dirname, '../events/cache/userData.json');
            if (fs.existsSync(userDataPath)) {
                global.userData = JSON.parse(fs.readFileSync(userDataPath, 'utf8'));
            } else {
                global.userData = {};
            }
        }
        
        if (global.userData[userId] && global.userData[userId].name) {
            return global.userData[userId].name;
        }
        
        return getname(userId) || "Facebook User";
    } catch (error) {
        console.error('Error getting user name from userData:', error);
        return getname(userId) || "Facebook User";
    }
}
const games = {};

const suits = ['‚ô†Ô∏è', '‚ô£Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è'];
const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

class BaiCaoGame {
    constructor(threadID) {
        this.threadID = threadID;
        this.players = new Map();
        this.deck = [];
        this.state = "waiting";
        this.betAmount = 0;
        this.currentPlayers = 0;
        this.maxPlayers = 8;
        this.timeoutID = null;
        this.roundCount = 0;
        this.aiPlayers = 0;
        this.aiDecisionTime = 0;
        this.aiDifficulty = "normal";
    }

    initializeDeck() {
        this.deck = [];
        for (let suit of suits) {
            for (let rank of ranks) {
                this.deck.push({ suit, rank });
            }
        }
    }

    shuffleDeck() {
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }
    }

    dealCards() {
        for (let [playerID, player] of this.players) {
            player.cards = this.deck.splice(0, 3);
            player.point = this.calculatePoints(player.cards);
        }
    }

    calculatePoints(cards) {
        let values = cards.map(card => {
            if (['J', 'Q', 'K'].includes(card.rank)) return 10;
            if (card.rank === 'A') return 1;
            return parseInt(card.rank);
        });
        return values.reduce((a, b) => a + b, 0) % 10;
    }

    getPlayerCards(playerID) {
        const player = this.players.get(playerID);
        if (!player || !player.cards) return "Ch∆∞a c√≥ b√†i";
        return player.cards.map(card => `${card.rank}${card.suit}`).join(" ");
    }
    addAIPlayer(difficulty = "normal") {
        const aiNumber = ++this.aiPlayers;
        const aiID = `ai_${Date.now()}_${aiNumber}`;

        let personality;
        switch (difficulty) {
            case "easy":
                personality = {
                    changeThreshold: 5,
                    decisionDelay: 3000,
                    name: `ü§ñ AI D·ªÖ #${aiNumber}`
                };
                break;
            case "hard":
                personality = {
                    changeThreshold: 7,
                    decisionDelay: 1000,
                    name: `ü§ñ AI Kh√≥ #${aiNumber}`
                };
                break;
            default:
                personality = {
                    changeThreshold: 6,
                    decisionDelay: 2000,
                    name: `ü§ñ AI #${aiNumber}`
                };
        }
        this.players.set(aiID, {
            name: personality.name,
            ready: false,
            cards: [],
            isAI: true,
            personality: personality,
            hasChanged: false
        });

        this.currentPlayers++;
        return aiID;
    }

    makeAIPlayersReady(api) {
        const pendingAIs = Array.from(this.players.entries())
            .filter(([_, player]) => player.isAI && !player.ready)
            .map(([id, player]) => player);
        
        if (pendingAIs.length === 0) return;
        
        setTimeout(() => {
            if (this.state !== "playing") return;
            
            let readyAINames = [];
            let allReady = true;
            
            for (const player of pendingAIs) {
                player.ready = true;
                readyAINames.push(player.name);
            }
            
            for (let [_, player] of this.players) {
                if (!player.ready) {
                    allReady = false;
                    break;
                }
            }
            
            if (readyAINames.length > 0) {
                api.sendMessage(
                    `ü§ñ ${readyAINames.length > 1 ? "T·∫§T C·∫¢ AI" : readyAINames[0]} ƒë√£ s·∫µn s√†ng theo!`,
                    this.threadID
                );
            }
            
            if (allReady) {
                this.endGame(api);
            }
        }, 1000); 
    }

    handleAIDecisions(api) {
        if (this.state !== "playing") return;
    
        const aiPlayers = Array.from(this.players.entries())
            .filter(([_, player]) => player.isAI)
            .map(([id, player]) => ({ id, player }));
        
        if (aiPlayers.length === 0) return;
        
        setTimeout(async () => {
            let aiActionsMsg = [];
            let changeDelay = 0;
            
            for (const { id, player } of aiPlayers) {
                const shouldChange = player.point <= player.personality.changeThreshold && !player.hasChanged;
                
                if (shouldChange) {
                    setTimeout(() => {
                        if (this.state !== "playing") return;
                        
                        player.cards = this.deck.splice(0, 3);
                        player.point = this.calculatePoints(player.cards);
                        player.hasChanged = true;
                        
                        api.sendMessage(`${player.name} ƒë√£ ƒë·ªïi b√†i!`, this.threadID);
                    }, changeDelay);
                    
                    changeDelay += 500;
                }
            }
            
            setTimeout(() => {
                if (this.state !== "playing") return;
                
                const maxDecisionDelay = Math.max(...aiPlayers.map(({ player }) => 
                    player.personality.decisionDelay / 2 || 1000));
                    
                setTimeout(() => {
                    if (this.state !== "playing") return;
                    
                    let readyAINames = [];
                    let allReady = true;
                    
                    for (const { player } of aiPlayers) {
                        player.ready = true;
                        readyAINames.push(player.name);
                    }
                    
                    for (let [_, player] of this.players) {
                        if (!player.ready) {
                            allReady = false;
                            break;
                        }
                    }
                    
                    if (readyAINames.length > 0) {
                        api.sendMessage(
                            `ü§ñ ${readyAINames.length > 1 ? "T·∫§T C·∫¢ AI" : readyAINames[0]} ƒë√£ s·∫µn s√†ng!`,
                            this.threadID
                        );
                    }
                    
                    if (allReady) {
                        this.endGame(api);
                    }
                }, maxDecisionDelay);
                
            }, changeDelay + 500);
    
        }, 1500); 
    }
    async start(api) {
        this.state = "playing";
        this.initializeDeck();
        this.shuffleDeck();
        this.dealCards();
        
        try {
            const gameStateCanvas = await createGameStateCanvas(this);
            
            const tempFilePath = path.join(__dirname, `../temp/gamestate_${this.threadID}_${Date.now()}.png`);
            
            if (!fs.existsSync(path.join(__dirname, '../temp'))) {
                fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
            }
            
            fs.writeFileSync(tempFilePath, gameStateCanvas);
            
            await api.sendMessage(
                {
                    body: "üé≤ CHIA B√ÄI TH√ÄNH C√îNG üé≤\n\n" +
                          "üëâ S·ª≠ d·ª•ng:\n" +
                          "‚Ä¢ .baicao xem => Xem b√†i c·ªßa b·∫°n\n" +
                          "‚Ä¢ .baicao ƒë·ªïi => ƒê·ªïi b√†i (1 l·∫ßn)\n" +
                          "‚Ä¢ .baicao ready => S·∫µn s√†ng\n\n" +
                          "‚è≥ Th·ªùi gian: 60 gi√¢y",
                    attachment: fs.createReadStream(tempFilePath)
                },
                this.threadID,
                () => {
                    try {
                        fs.unlinkSync(tempFilePath);
                    } catch (e) {
                        console.error("Error removing temp file:", e);
                    }
                }
            );
        } catch (err) {
            console.error("Error generating game state canvas:", err);
            
            let message = "üé≤ CHIA B√ÄI TH√ÄNH C√îNG üé≤\n";
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
            message += "üëâ S·ª≠ d·ª•ng:\n";
            message += "‚Ä¢ .baicao xem => Xem b√†i c·ªßa b·∫°n\n";
            message += "‚Ä¢ .baicao ƒë·ªïi => ƒê·ªïi b√†i (1 l·∫ßn)\n";
            message += "‚Ä¢ .baicao ready => S·∫µn s√†ng\n\n";
            message += "‚è≥ Th·ªùi gian: 60 gi√¢y";
            
            await api.sendMessage(message, this.threadID);
        }
    
        this.handleAIDecisions(api);
    
        this.timeoutID = setTimeout(() => {
            if (this.state === "playing") {
                this.endGame(api);
            }
        }, 90000);
    }

    async endGame(api) {
        clearTimeout(this.timeoutID);
        this.state = "ended";
    
        let results = [];
        for (let [playerID, player] of this.players) {
            results.push({
                playerID,
                name: player.name,
                cards: this.getPlayerCards(playerID),
                point: player.point,
                isAI: player.isAI || false
            });
        }
    
        results.sort((a, b) => b.point - a.point);
    
        const winner = results[0];
        const totalPool = this.betAmount * this.players.size;
        const winAmount = Math.floor(totalPool * 0.95); 
        if (!winner.isAI) {
            await updateBalance(winner.playerID, winAmount);
        }
        
        try {
            const resultsCanvas = await createBaicaoCanvas(this, results);
            
            const tempFilePath = path.join(__dirname, `../temp/results_${this.threadID}_${Date.now()}.png`);
            
            if (!fs.existsSync(path.join(__dirname, '../temp'))) {
                fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
            }
            
            fs.writeFileSync(tempFilePath, resultsCanvas);
            
            await api.sendMessage(
                {
                    body: "üéÆ K·∫æT QU·∫¢ B√ÄI C√ÄO üéÆ\n\n" +
                          "‚Ä¢ .baicao next - Ch∆°i ti·∫øp\n" +
                          "‚Ä¢ .baicao leave - R·ªùi b√†n",
                    attachment: fs.createReadStream(tempFilePath)
                },
                this.threadID, 
                () => {
                    try {
                        fs.unlinkSync(tempFilePath);
                    } catch (e) {
                        console.error("Error removing temp file:", e);
                    }
                }
            );
        } catch (err) {
            console.error("Error generating results canvas:", err);
            
            let message = "üéÆ K·∫æT QU·∫¢ B√ÄI C√ÄO üéÆ\n";
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
    
            results.forEach((result, index) => {
                message += `${index + 1}. ${result.name}${result.isAI ? ' ü§ñ' : ''}\n`;
                message += `‚îú‚îÄ B√†i: ${result.cards}\n`;
                message += `‚îî‚îÄ ƒêi·ªÉm: ${result.point}\n`;
            });
    
            message += "\nüí∞ TH∆Ø·ªûNG:\n";
            message += `‚ú® Ng∆∞·ªùi th·∫Øng: ${winner.name}${winner.isAI ? ' ü§ñ' : ''}\n`;
            message += `üíµ Ti·ªÅn th·∫Øng: ${formatNumber(winAmount)}$\n`;
            message += `üí∞ T·ªïng c∆∞·ª£c: ${formatNumber(totalPool)}$\n`;
            message += `üìå Ph√≠: ${formatNumber(totalPool - winAmount)}$`;
    
            message += "\n\nüìã L∆Ø·ª¢T CH∆†I M·ªöI:\n";
            message += "‚Ä¢ .baicao next - Ch∆°i ti·∫øp\n";
            message += "‚Ä¢ .baicao leave - R·ªùi b√†n";
    
            await api.sendMessage(message, this.threadID);
        }
    
        this.state = "waiting_next";
        this.roundCount++;
    
        for (let [playerID, player] of this.players) {
            player.cards = [];
            player.point = 0;
            player.ready = false;
            player.hasChanged = false;
        }
    }

    async startNewRound(api) {
        this.state = "playing";
        this.initializeDeck();
        this.shuffleDeck();
        this.dealCards();
        
        try {
            const gameStateCanvas = await createGameStateCanvas(this);
            
            const tempFilePath = path.join(__dirname, `../temp/gamestate_${this.threadID}_${Date.now()}.png`);
            
            if (!fs.existsSync(path.join(__dirname, '../temp'))) {
                fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
            }
            
            fs.writeFileSync(tempFilePath, gameStateCanvas);
            
            await api.sendMessage(
                {
                    body: `üé≤ V√íNG M·ªöI B·∫ÆT ƒê·∫¶U üé≤\n\n` +
                          `üìå V√≤ng: ${this.roundCount}\n` +
                          `üë• Ng∆∞·ªùi ch∆°i: ${this.players.size}\n` +
                          `ü§ñ AI: ${this.aiPlayers}\n` +
                          `üí∞ C∆∞·ª£c: ${formatNumber(this.betAmount)}$\n\n` +
                          "üëâ S·ª≠ d·ª•ng:\n" +
                          "‚Ä¢ .baicao xem => Xem b√†i c·ªßa b·∫°n\n" +
                          "‚Ä¢ .baicao ƒë·ªïi => ƒê·ªïi b√†i (1 l·∫ßn)\n" +
                          "‚Ä¢ .baicao ready => S·∫µn s√†ng\n\n" +
                          "‚è≥ Th·ªùi gian: 60 gi√¢y",
                    attachment: fs.createReadStream(tempFilePath)
                },
                this.threadID,
                () => {
                    try {
                        fs.unlinkSync(tempFilePath);
                    } catch (e) {
                        console.error("Error removing temp file:", e);
                    }
                }
            );
        } catch (err) {
            console.error("Error generating game state canvas:", err);
            
            let message = "üé≤ V√íNG M·ªöI B·∫ÆT ƒê·∫¶U üé≤\n";
            message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
            message += `üìå V√≤ng: ${this.roundCount}\n`;
            message += `üë• Ng∆∞·ªùi ch∆°i: ${this.players.size}\n`;
            message += `ü§ñ AI: ${this.aiPlayers}\n`;
            message += `üí∞ C∆∞·ª£c: ${formatNumber(this.betAmount)}$\n\n`;
            message += "üëâ S·ª≠ d·ª•ng:\n";
            message += "‚Ä¢ .baicao xem => Xem b√†i c·ªßa b·∫°n\n";
            message += "‚Ä¢ .baicao ƒë·ªïi => ƒê·ªïi b√†i (1 l·∫ßn)\n";
            message += "‚Ä¢ .baicao ready => S·∫µn s√†ng\n\n";
            message += "‚è≥ Th·ªùi gian: 60 gi√¢y";
            
            await api.sendMessage(message, this.threadID);
        }
    
        this.handleAIDecisions(api);
    
        this.timeoutID = setTimeout(() => {
            if (this.state === "playing") {
                this.endGame(api);
            }
        }, 90000);
    }
    async removePlayer(playerID) {
        if (this.players.has(playerID)) {
            this.players.delete(playerID);
            this.currentPlayers--;
            return true;
        }
        return false;
    }
}

module.exports = {
    name: "baicao",
    dev: "HNT",
    onPrefix: true,
    category: "Games",
    info: "Ch∆°i B√†i C√†o",
    usages: "baicao [create/join/start/xem/ƒë·ªïi/ready]",
    cooldowns: 0,

    onLaunch: async function ({ api, event, target }) {
        const { threadID, senderID, messageID } = event;

        if (!target[0]) {
            return api.sendMessage(
                "üéÆ B√ÄI C√ÄO üéÆ\n" +
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                "üëâ H∆∞·ªõng d·∫´n:\n" +
                "‚Ä¢ .baicao create [s·ªë ti·ªÅn] - T·∫°o b√†n\n" +
                "‚Ä¢ .baicao join - Tham gia\n" +
                "‚Ä¢ .baicao ai [easy/normal/hard] [s·ªë l∆∞·ª£ng] - Th√™m ng∆∞·ªùi ch∆°i AI\n" +
                "‚Ä¢ .baicao start - B·∫Øt ƒë·∫ßu\n" +
                "‚Ä¢ .baicao xem - Xem b√†i\n" +
                "‚Ä¢ .baicao ƒë·ªïi - ƒê·ªïi b√†i\n" +
                "‚Ä¢ .baicao ready - S·∫µn s√†ng\n\n" +
                "üí∞ C∆∞·ª£c: 1,000$ ƒë·∫øn 50,000,000$\n" +
                "üë• S·ªë ng∆∞·ªùi: 2-8 ng∆∞·ªùi/b√†n",
                threadID, messageID
            );
        }

        const command = target[0].toLowerCase();
        const game = games[threadID];

        switch (command) {
            case "create": {
                if (game) {
                    return api.sendMessage("‚ùå ƒê√£ c√≥ b√†n ƒë∆∞·ª£c t·∫°o trong nh√≥m n√†y!", threadID, messageID);
                }

                const betAmount = parseInt(target[1]);
                if (isNaN(betAmount) || betAmount < 1000 || betAmount > 50000000) {
                    return api.sendMessage(
                        "‚ùå S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá!\nüí∞ C∆∞·ª£c t·ª´ 1,000$ ƒë·∫øn 50,000,000$",
                        threadID, messageID
                    );
                }

                const userBalance = getBalance(senderID);
                if (userBalance < betAmount) {
                    return api.sendMessage(
                        "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c!\n" +
                        `üí∞ S·ªë d∆∞: ${formatNumber(userBalance)}$`,
                        threadID, messageID
                    );
                }

                games[threadID] = new BaiCaoGame(threadID);
                const newGame = games[threadID];
                newGame.betAmount = betAmount;
            
                const name = getUserNameFromData(senderID);
                newGame.players.set(senderID, {
                    name: name,
                    ready: false,
                    cards: []
                });
                newGame.currentPlayers = 1;

                await updateBalance(senderID, -betAmount);

                return api.sendMessage(
                    "üéÆ T·∫†O B√ÄN TH√ÄNH C√îNG üéÆ\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `üí∞ C∆∞·ª£c: ${formatNumber(betAmount)}$\n` +
                    `üë• Ng∆∞·ªùi t·∫°o: ${name}\n` +
                    "üëâ S·ªë ng∆∞·ªùi tham gia: 1/8\n\n" +
                    "‚Ä¢ .baicao join - Tham gia\n" +
                    "‚Ä¢ .baicao start - B·∫Øt ƒë·∫ßu game",
                    threadID
                );
            }
            case "bot":
            case "ai": {
                if (!game) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                }

                if (game.state !== "waiting") {
                    return api.sendMessage("‚ùå Kh√¥ng th·ªÉ th√™m AI khi tr√≤ ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!", threadID, messageID);
                }

                if (!game.players.has(senderID)) {
                    return api.sendMessage("‚ùå Ch·ªâ ch·ªß ph√≤ng m·ªõi c√≥ th·ªÉ th√™m AI!", threadID, messageID);
                }

                if (game.currentPlayers >= game.maxPlayers) {
                    return api.sendMessage("‚ùå B√†n ƒë√£ ƒë·ªß ng∆∞·ªùi ch∆°i!", threadID, messageID);
                }

                let difficulty = target[1] ? target[1].toLowerCase() : "normal";
                if (!["easy", "normal", "hard"].includes(difficulty)) {
                    difficulty = "normal";
                }

                let count = parseInt(target[2]) || 1;
                count = Math.min(count, game.maxPlayers - game.currentPlayers);

                for (let i = 0; i < count; i++) {
                    if (game.currentPlayers >= game.maxPlayers) break;
                    game.addAIPlayer(difficulty);
                }

                return api.sendMessage(
                    `‚úÖ ƒê√£ th√™m ${count} AI ${difficulty}!\n` +
                    `üë• S·ªë ng∆∞·ªùi ch∆°i: ${game.currentPlayers}/${game.maxPlayers}`,
                    threadID, messageID
                );
            }
            case "join": {
                if (!game) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                }

                if (game.state !== "waiting") {
                    return api.sendMessage("‚ùå B√†n ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!", threadID, messageID);
                }

                if (game.players.has(senderID)) {
                    return api.sendMessage("‚ùå B·∫°n ƒë√£ tham gia b√†n n√†y!", threadID, messageID);
                }

                if (game.currentPlayers >= game.maxPlayers) {
                    return api.sendMessage("‚ùå B√†n ƒë√£ ƒë·ªß ng∆∞·ªùi ch∆°i!", threadID, messageID);
                }

                const userBalance = getBalance(senderID);
                if (userBalance < game.betAmount) {
                    return api.sendMessage(
                        "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ tham gia!\n" +
                        `üí∞ C·∫ßn: ${formatNumber(game.betAmount)}$\n` +
                        `üíµ S·ªë d∆∞: ${formatNumber(userBalance)}$`,
                        threadID, messageID
                    );
                }

                const name = getUserNameFromData(senderID);
                game.players.set(senderID, {
                    name: name,
                    ready: false,
                    cards: []
                });
                game.currentPlayers++;

                await updateBalance(senderID, -game.betAmount);

                return api.sendMessage(
                    `‚úÖ ${name} ƒë√£ tham gia!\n` +
                    `üë• S·ªë ng∆∞·ªùi ch∆°i: ${game.currentPlayers}/8\n` +
                    `üí∞ C∆∞·ª£c: ${formatNumber(game.betAmount)}$`,
                    threadID
                );
            }
            case "start": {
                if (!game) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                }

                if (game.state !== "waiting") {
                    return api.sendMessage("‚ùå B√†n ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!", threadID, messageID);
                }

                if (game.currentPlayers < 2) {
                    return api.sendMessage("‚ùå C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu!", threadID, messageID);
                }

                if (!game.players.has(senderID)) {
                    return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                }

                await game.start(api);
                break;
            }

            case "xem": {
                if (!game) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                }
            
                if (game.state !== "playing") {
                    return api.sendMessage("‚ùå B√†n ch∆°i ch∆∞a b·∫Øt ƒë·∫ßu!", threadID, messageID);
                }
            
                if (!game.players.has(senderID)) {
                    return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                }
            
                const player = game.players.get(senderID);
                
                const canvasCardData = {
                    name: player.name,
                    point: player.point,
                    cards: player.cards
                };
                
                try {
                    const cardCanvas = await createPlayerCardCanvas(canvasCardData);
                    
                    const tempFilePath = path.join(__dirname, `../temp/cards_${senderID}_${Date.now()}.png`);
                    
                    if (!fs.existsSync(path.join(__dirname, '../temp'))) {
                        fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
                    }
                    
                    fs.writeFileSync(tempFilePath, cardCanvas);
                    
                    return api.sendMessage(
                        {
                            body: `üÉè B√ÄI C·ª¶A B·∫†N üÉè\n${player.hasChanged ? '(ƒê√£ ƒë·ªïi b√†i)' : ''}`,
                            attachment: fs.createReadStream(tempFilePath)
                        },
                        threadID, 
                        () => {
                            try {
                                fs.unlinkSync(tempFilePath);
                            } catch (e) {
                                console.error("Error removing temp file:", e);
                            }
                        },
                        messageID
                    );
                } catch (err) {
                    console.error("Error generating card canvas:", err);
                    
                    return api.sendMessage(
                        "üÉè B√ÄI C·ª¶A B·∫†N üÉè\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `B√†i: ${game.getPlayerCards(senderID)}\n` +
                        `ƒêi·ªÉm: ${player.point}`,
                        threadID, messageID
                    );
                }
            }

            case "ƒë·ªïi":
                case "doi": {
                    if (!game) {
                        return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                    }
                
                    if (game.state !== "playing") {
                        return api.sendMessage("‚ùå B√†n ch∆°i ch∆∞a b·∫Øt ƒë·∫ßu!", threadID, messageID);
                    }
                
                    if (!game.players.has(senderID)) {
                        return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                    }
                
                    const player = game.players.get(senderID);
                    if (player.hasChanged) {
                        return api.sendMessage("‚ùå B·∫°n ƒë√£ ƒë·ªïi b√†i r·ªìi!", threadID, messageID);
                    }
                
                    player.cards = game.deck.splice(0, 3);
                    player.point = game.calculatePoints(player.cards);
                    player.hasChanged = true;
                
                    const canvasCardData = {
                        name: player.name,
                        point: player.point,
                        cards: player.cards
                    };
                    
                    try {
                        const cardCanvas = await createPlayerCardCanvas(canvasCardData);
                        
                        const tempFilePath = path.join(__dirname, `../temp/newcards_${senderID}_${Date.now()}.png`);
                        
                        if (!fs.existsSync(path.join(__dirname, '../temp'))) {
                            fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
                        }
                        
                        fs.writeFileSync(tempFilePath, cardCanvas);
                        
                        return api.sendMessage(
                            {
                                body: "üîÑ ƒê·ªîI B√ÄI TH√ÄNH C√îNG üîÑ",
                                attachment: fs.createReadStream(tempFilePath)
                            },
                            threadID, 
                            () => {
                                try {
                                    fs.unlinkSync(tempFilePath);
                                } catch (e) {
                                    console.error("Error removing temp file:", e);
                                }
                            },
                            messageID
                        );
                    } catch (err) {
                        console.error("Error generating card canvas:", err);
                        
                        return api.sendMessage(
                            "üîÑ ƒê·ªîI B√ÄI TH√ÄNH C√îNG üîÑ\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            `B√†i m·ªõi: ${game.getPlayerCards(senderID)}\n` +
                            `ƒêi·ªÉm: ${player.point}`,
                            threadID, messageID
                        );
                    }
                }

                case "ready": {
                    if (!game) {
                        return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                    }
                
                    if (game.state !== "playing") {
                        return api.sendMessage("‚ùå B√†n ch∆°i ch∆∞a b·∫Øt ƒë·∫ßu!", threadID, messageID);
                    }
                
                    if (!game.players.has(senderID)) {
                        return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                    }
                
                    const player = game.players.get(senderID);
                    if (player.ready) {
                        return api.sendMessage("‚ùå B·∫°n ƒë√£ s·∫µn s√†ng r·ªìi!", threadID, messageID);
                    }
                
                    player.ready = true;
                
                    game.makeAIPlayersReady(api);
                
                    let allReady = true;
                    for (let [_, player] of game.players) {
                        if (!player.ready) {
                            allReady = false;
                            break;
                        }
                    }
                
                    if (allReady) {
                        return game.endGame(api);
                    }
                
                    return api.sendMessage(
                        `‚úÖ ${player.name} ƒë√£ s·∫µn s√†ng!\n` +
                        "‚è≥ ƒê·ª£i c√°c ng∆∞·ªùi ch∆°i kh√°c...",
                        threadID
                    );
                }

                case "next": {
                    if (!game) {
                        return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                    }
                
                    if (game.state !== "waiting_next") {
                        return api.sendMessage("‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu v√≤ng m·ªõi l√∫c n√†y!", threadID, messageID);
                    }
                
                    if (!game.players.has(senderID)) {
                        return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                    }
                
                    const userBalance = getBalance(senderID);
                    if (userBalance < game.betAmount) {
                        game.removePlayer(senderID);
                        return api.sendMessage(
                            "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ ti·∫øp t·ª•c!\n" +
                            `üí∞ C·∫ßn: ${formatNumber(game.betAmount)}$\n` +
                            `üíµ S·ªë d∆∞: ${formatNumber(userBalance)}$`,
                            threadID, messageID
                        );
                    }
                
                    await updateBalance(senderID, -game.betAmount);
                    game.players.get(senderID).ready = true;
                    
                    setTimeout(() => {
                        let aiCount = 0;
                        for (let [playerID, player] of game.players) {
                            if (player.isAI && !player.ready) {
                                player.ready = true;
                                aiCount++;
                            }
                        }
                        
                        if (aiCount > 0) {
                            api.sendMessage(
                                `ü§ñ ${aiCount > 1 ? "T·∫•t c·∫£ AI" : "AI"} ƒë√£ s·∫µn s√†ng cho v√≤ng m·ªõi!`,
                                threadID
                            );
                        }
                        
                        let allPlayersReady = true;
                        for (let [_, player] of game.players) {
                            if (!player.ready) {
                                allPlayersReady = false;
                                break;
                            }
                        }
                        
                        if (allPlayersReady) {
                            game.startNewRound(api);
                        }
                    }, 1000);
                
                    return api.sendMessage(
                        `‚úÖ ${game.players.get(senderID).name} ƒë√£ s·∫µn s√†ng cho v√≤ng m·ªõi!\n` +
                        "‚è≥ ƒê·ª£i c√°c ng∆∞·ªùi ch∆°i kh√°c...",
                        threadID
                    );
                }

            case "leave": {
                if (!game) {
                    return api.sendMessage("‚ùå Ch∆∞a c√≥ b√†n n√†o ƒë∆∞·ª£c t·∫°o!", threadID, messageID);
                }

                if (!game.players.has(senderID)) {
                    return api.sendMessage("‚ùå B·∫°n kh√¥ng tham gia b√†n n√†y!", threadID, messageID);
                }

                if (game.state !== "waiting_next") {
                    return api.sendMessage("‚ùå Ch·ªâ c√≥ th·ªÉ r·ªùi b√†n sau khi k·∫øt th√∫c v√≤ng!", threadID, messageID);
                }

                const playerName = game.players.get(senderID).name;
                game.removePlayer(senderID);

                if (game.players.size < 2) {
                    api.sendMessage(
                        "üîö B√ÄN CH∆†I K·∫æT TH√öC\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        "‚ùå Kh√¥ng ƒë·ªß ng∆∞·ªùi ch∆°i t·ªëi thi·ªÉu!",
                        threadID
                    );
                    delete games[threadID];
                } else {
                    api.sendMessage(
                        `üëã ${playerName} ƒë√£ r·ªùi b√†n!\n` +
                        `üë• C√≤n l·∫°i: ${game.players.size} ng∆∞·ªùi ch∆°i`,
                        threadID
                    );
                }
                break;  
            }

            default:
                return api.sendMessage("‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!", threadID, messageID);
        }
    }
};
