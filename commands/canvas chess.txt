const { createCanvas, loadImage } = require('canvas');
const { Chess } = require('chess.js');

    piece_url_images: {
        'p': 'https://upload.wikimedia.org/wikipedia/commons/c/cd/Chess_pdt60.png',
        'r': 'https://upload.wikimedia.org/wikipedia/commons/a/a0/Chess_rdt60.png',
        'n': 'https://upload.wikimedia.org/wikipedia/commons/f/f1/Chess_ndt60.png',
        'b': 'https://upload.wikimedia.org/wikipedia/commons/8/81/Chess_bdt60.png',
        'q': 'https://upload.wikimedia.org/wikipedia/commons/a/af/Chess_qdt60.png',
        'k': 'https://upload.wikimedia.org/wikipedia/commons/e/e3/Chess_kdt60.png',
        'P': 'https://upload.wikimedia.org/wikipedia/commons/0/04/Chess_plt60.png',
        'R': 'https://upload.wikimedia.org/wikipedia/commons/5/5c/Chess_rlt60.png',
        'N': 'https://upload.wikimedia.org/wikipedia/commons/2/28/Chess_nlt60.png',
        'B': 'https://upload.wikimedia.org/wikipedia/commons/9/9b/Chess_blt60.png',
        'Q': 'https://upload.wikimedia.org/wikipedia/commons/4/49/Chess_qlt60.png',
        'K': 'https://upload.wikimedia.org/wikipedia/commons/3/3b/Chess_klt60.png',
    }

    piece_images: {},
    cached_images: false,
    games: new Map(),

    async loadPieceImages() {
        if (this.cached_images) return;
        
        try {
            const piece_letters = Object.keys(this.piece_url_images);
            const imagePromises = piece_letters.map(async letter => {
                try {
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Timeout')), 10000)
                    );
                    const imagePromise = loadImage(this.piece_url_images[letter]);
                    return await Promise.race([imagePromise, timeoutPromise]);
                } catch (err) {
                    console.error(`Failed to load piece ${letter}, retrying...`);
                    return await loadImage(this.piece_url_images[letter]);
                }
            });

            const images = await Promise.all(imagePromises);
            this.piece_images = images.reduce((obj, img, i) => ({ ...obj, [piece_letters[i]]: img }), {});
            this.cached_images = true;
        } catch (error) {
            console.error('Failed to load chess pieces:', error);
            throw new Error('Không thể tải hình ảnh quân cờ. Vui lòng thử lại sau.');
        }
    },

    async ensureCacheDir() {
        const cacheDir = path.join(__dirname, 'cache');
        if (!fs.existsSync(cacheDir)) {
            fs.mkdirSync(cacheDir, { recursive: true });
        }
    },

    async drawChessBoard(chess) {
        try {
            await this.ensureCacheDir();
            const canvas = createCanvas(500, 500);
            const ctx = canvas.getContext('2d');
            const _8 = [...Array(8)].map((_, i) => i);

            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            _8.forEach(i => _8.forEach(j => {
                ctx.fillStyle = (i + j) % 2 === 0 ? '#fff' : '#999';
                ctx.fillRect((i * 50) + 50, (j * 50) + 50, 50, 50);
            }));

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 50, 50 * 8, 50 * 8);

            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            _8.forEach(i => {
                ctx.fillText(8 - i, 25, (i * 50 + 25) + 50);
                ctx.fillText(String.fromCharCode(65 + i), (i * 50 + 25) + 50, (50 * 8 + 25) + 50);
            });

            chess.board().forEach((row, i) => row.forEach((piece, j) => {
                if (piece !== null) {
                    const image = this.piece_images[piece.color === 'b' ? piece.type : piece.type.toUpperCase()];
                    if (image) {
                        ctx.drawImage(image, (j * 50) + 50, (i * 50) + 50, 50, 50);
                    }
                }
            }));

            const imagePath = path.join(__dirname, 'cache', `chess_${Date.now()}_${Math.floor(Math.random()*1000)}.png`);
            
            return new Promise((resolve, reject) => {
                const out = fs.createWriteStream(imagePath);
                const stream = canvas.createPNGStream();
                
                stream.pipe(out);
                out.on('finish', () => resolve(imagePath));
                out.on('error', reject);
                
                setTimeout(() => {
                    stream.unpipe(out);
                    out.end();
                    reject(new Error('Timeout'));
                }, 10000);
            });

        } catch (error) {
            console.error('Error drawing chess board:', error);
            throw new Error('Không thể tạo bàn cờ. Vui lòng thử lại.');
        }
    },

    getPlayerName(id, playerNumber) {
        try {
            return global.data?.userName?.get(id) || `Player ${playerNumber}`;
        } catch {
            return `Player ${playerNumber}`;
        }
    }