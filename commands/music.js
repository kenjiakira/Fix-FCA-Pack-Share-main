const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

module.exports = {
    name: "music",
    usedby: 0,
    category: "Media",
    info: "T·∫£i nh·∫°c t·ª´ Youtube d·∫°ng MP3",
    onPrefix: true,
    dev: "HNT",
    cooldowns: 10,

    onReply: async function({ api, event }) {
        const { threadID, messageID, senderID, body } = event;
        if (!global.pyMusicCache || !global.pyMusicCache[threadID]) return;
        
        const input = body.toLowerCase().trim();
        const { videos, searchMessageID } = global.pyMusicCache[threadID];
        const choice = parseInt(input);

        if (isNaN(choice) || choice < 1 || choice > 6) {
            return api.sendMessage("Vui l√≤ng ch·ªçn s·ªë t·ª´ 1 ƒë·∫øn 6", threadID, messageID);
        }

        const video = videos[choice - 1];
        const findingMessage = await api.sendMessage(`üéµ | ƒêang t·∫£i nh·∫°c: "${video.title}"...`, threadID, messageID);
        const outputPath = path.resolve(__dirname, 'cache', `pymusic_${Date.now()}.%(ext)s`);
        const finalPath = outputPath.replace('.%(ext)s', '.mp3');

        try {
            const pythonScript = path.resolve(__dirname, '..', 'python', 'video_downloader.py');
            
            const result = await new Promise((resolve, reject) => {
                const python = spawn('python', [pythonScript, 'audio', video.url, outputPath, '128'], {
                    stdio: ['pipe', 'pipe', 'pipe']
                });
                let output = '';
                let error = '';

                python.stdout.on('data', (data) => {
                    output += data.toString();
                });

                python.stderr.on('data', (data) => {
                    error += data.toString();
                });

                python.on('close', (code) => {
                    if (code === 0) {
                        try {
                            const lines = output.trim().split('\n');
                            let jsonLine = '';
                            
                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (line.startsWith('{') && line.endsWith('}')) {
                                    jsonLine = line;
                                    break;
                                }
                            }
                            
                            if (!jsonLine) {
                                reject(new Error(`No valid JSON found in output: "${output}"`));
                                return;
                            }
                            
                            const parsed = JSON.parse(jsonLine);
                            resolve(parsed);
                        } catch (e) {
                            reject(new Error(`Failed to parse Python output. Raw output: "${output}". Parse error: ${e.message}`));
                        }
                    } else {
                        reject(new Error(`Python script failed with code ${code}. Error: ${error || 'Unknown error'}`));
                    }
                });
            });

            if (!result.success) {
                let errorMessage = result.error;
                if (errorMessage.includes('FFmpeg') || errorMessage.includes('ffmpeg')) {
                    errorMessage = `${errorMessage}\n\nüí° H∆∞·ªõng d·∫´n c√†i FFmpeg:\n` +
                        '‚Ä¢ Windows: T·∫£i t·ª´ https://ffmpeg.org v√† th√™m v√†o PATH\n' +
                        '‚Ä¢ Ho·∫∑c d√πng Chocolatey: choco install ffmpeg\n' +
                        '‚Ä¢ Ho·∫∑c d√πng Winget: winget install ffmpeg\n\n' +
                        '‚ö†Ô∏è Kh√¥ng c√≥ FFmpeg s·∫Ω t·∫£i file audio g·ªëc (M4A/WEBM)';
                }
                await api.editMessage(`‚ùå | ${errorMessage}`, findingMessage.messageID, threadID);
                return;
            }

            const { data } = result;
            const views = data.view_count ? data.view_count.toLocaleString() : '0';
            const likes = data.like_count ? data.like_count.toLocaleString() : '·∫®n';
            const audioPath = data.file_path || finalPath;

            // Clean up any leftover files with different extensions
            const basePath = outputPath.replace('.%(ext)s', '');
            const possibleFiles = [
                basePath + '.mp3',
                basePath + '.m4a', 
                basePath + '.webm',
                basePath + '.ogg',
                basePath + '.aac',
                finalPath
            ];

            let actualFile = audioPath;
            if (!fs.existsSync(actualFile)) {
                // Find any existing file
                for (const file of possibleFiles) {
                    if (fs.existsSync(file)) {
                        actualFile = file;
                        break;
                    }
                }
            }

            if (actualFile && fs.existsSync(actualFile)) {
                const formatInfo = data.format ? ` | Format: ${data.format}` : '';
                const fileExt = path.extname(actualFile).toUpperCase().substring(1);
                
                await api.sendMessage({
                    body: `üéµ ${data.title}\n‚è±Ô∏è Th·ªùi l∆∞·ª£ng: ${data.duration}\nüë§ K√™nh: ${data.uploader}\nüëç L∆∞·ª£t th√≠ch: ${likes}\nüëÅÔ∏è L∆∞·ª£t xem: ${views}\nüìÅ K√≠ch th∆∞·ªõc: ${data.file_size.toFixed(2)}MB${formatInfo || ` | ${fileExt}`}`,
                    attachment: fs.createReadStream(actualFile)
                }, threadID, () => {
                    api.unsendMessage(findingMessage.messageID);
                    api.unsendMessage(searchMessageID);
                    
                    // Clean up all possible files
                    possibleFiles.forEach(file => {
                        if (fs.existsSync(file)) {
                            try { fs.unlinkSync(file); } catch(e) {}
                        }
                    });
                });
            } else {
                await api.editMessage(`‚ùå | Kh√¥ng th·ªÉ t√¨m th·∫•y file audio ƒë√£ t·∫£i`, findingMessage.messageID, threadID);
            }

            delete global.pyMusicCache[threadID];
        } catch (error) {
            // Clean up any files on error
            const basePath = outputPath.replace('.%(ext)s', '');
            const possibleFiles = [
                basePath + '.mp3',
                basePath + '.m4a', 
                basePath + '.webm',
                basePath + '.ogg',
                basePath + '.aac',
                finalPath
            ];
            
            possibleFiles.forEach(file => {
                if (fs.existsSync(file)) {
                    try { fs.unlinkSync(file); } catch(e) {}
                }
            });
            
            await api.editMessage(`‚ùå | L·ªói khi t·∫£i nh·∫°c: ${error.message}`, findingMessage.messageID, threadID);
        }
    },

    onLaunch: async function ({ api, event, target }) {
        const { threadID, messageID } = event;
        if (!target[0]) {
            return api.sendMessage(`‚ùå Vui l√≤ng nh·∫≠p t√™n b√†i h√°t!`, threadID);
        }

        try {
            const musicQuery = target.join(" ");
            const findingMessage = await api.sendMessage(`üîç | ƒêang t√¨m "${musicQuery}". Vui l√≤ng ch·ªù...`, threadID);

            const pythonScript = path.resolve(__dirname, '..', 'python', 'video_downloader.py');
            
            const result = await new Promise((resolve, reject) => {
                const python = spawn('python', [pythonScript, 'search', musicQuery], {
                    stdio: ['pipe', 'pipe', 'pipe']
                });
                let output = '';
                let error = '';

                python.stdout.on('data', (data) => {
                    output += data.toString();
                });

                python.stderr.on('data', (data) => {
                    error += data.toString();
                });

                python.on('close', (code) => {
                    if (code === 0) {
                        try {
                            const lines = output.trim().split('\n');
                            let jsonLine = '';
                            
                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (line.startsWith('{') && line.endsWith('}')) {
                                    jsonLine = line;
                                    break;
                                }
                            }
                            
                            if (!jsonLine) {
                                reject(new Error(`No valid JSON found in output: "${output}"`));
                                return;
                            }
                            
                            const parsed = JSON.parse(jsonLine);
                            resolve(parsed);
                        } catch (e) {
                            reject(new Error(`Failed to parse Python output. Raw output: "${output}". Parse error: ${e.message}`));
                        }
                    } else {
                        reject(new Error(`Python script failed with code ${code}. Error: ${error || 'Unknown error'}`));
                    }
                });
            });

            if (!result.success) {
                return api.editMessage(`‚ùå | L·ªói t√¨m ki·∫øm: ${result.error}`, findingMessage.messageID, threadID);
            }

            const videos = result.videos;
            if (!videos.length) {
                return api.editMessage(`‚ùå | Kh√¥ng t√¨m th·∫•y b√†i h√°t: "${musicQuery}"`, findingMessage.messageID, threadID);
            }

            const body = "üéµ K·∫øt qu·∫£ t√¨m ki·∫øm nh·∫°c:\n\n" + 
                videos.map((video, index) => 
                    `${index + 1}. ${video.title}\n‚îî‚îÄ‚îÄ üë§ ${video.uploader}\n‚îî‚îÄ‚îÄ ‚è±Ô∏è ${video.duration}\n‚îî‚îÄ‚îÄ üëÅÔ∏è ${video.view_count.toLocaleString()} l∆∞·ª£t xem\n\n`
                ).join("") + 
                "üí° Reply s·ªë t·ª´ 1-6 ƒë·ªÉ ch·ªçn b√†i h√°t";

            const msg = await api.sendMessage(body, threadID, messageID);

            global.pyMusicCache = global.pyMusicCache || {};
            global.pyMusicCache[threadID] = {
                videos,
                searchMessageID: msg.messageID 
            };

            global.client.onReply.push({
                name: this.name,
                messageID: msg.messageID,
                author: event.senderID
            });

            api.unsendMessage(findingMessage.messageID);

        } catch (error) {
            await api.sendMessage(`‚ùå | L·ªói: ${error.message}`, threadID);
        }
    }
};