const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { getBalance, updateBalance, updateQuestProgress } = require('../utils/currencies');
const { createCanvas, loadImage } = require('canvas');

const farmDataPath = path.join(__dirname, './json/farm_data.json');
const farmImagesDir = path.join(__dirname, '../cache/farm');

if (!fs.existsSync(path.dirname(farmDataPath))) {
    fs.mkdirSync(path.dirname(farmDataPath), { recursive: true });
}

if (!fs.existsSync(farmImagesDir)) {
    fs.mkdirSync(farmImagesDir, { recursive: true });
}

const CROPS = {
    lua: {
        name: "L√∫a",
        emoji: "üåæ",
        price: 50000,
        time: 30 * 60, 
        yield: 80000,
        exp: 10,
        water: 3,
        level: 1,
        description: "C√¢y l√∫a n∆∞·ªõc truy·ªÅn th·ªëng"
    },
    rau: {
        name: "Rau xanh",
        emoji: "ü•¨",
        price: 10000,
        time: 15 * 60,
        yield: 18000,
        exp: 5,
        water: 2,
        level: 1,
        description: "C√°c lo·∫°i rau xanh: rau mu·ªëng, rau c·∫£i..."
    },
    ca_rot: {
        name: "C√† r·ªët",
        emoji: "ü•ï",
        price: 15000,
        time: 20 * 60, 
        yield: 25000,
        exp: 6,
        water: 2,
        level: 1,
        description: "C√† r·ªët nhi·ªÅu vitamin A"
    },
    dau: {
        name: "ƒê·∫≠u",
        emoji: "üå±",
        price: 20000,
        time: 25 * 60, 
        yield: 35000,
        exp: 7,
        water: 2,
        level: 2,
        description: "C√°c lo·∫°i ƒë·∫≠u: ƒë·∫≠u xanh, ƒë·∫≠u ƒëen..."
    },
    ngo: {
        name: "Ng√¥ (B·∫Øp)",
        emoji: "üåΩ",
        price: 25000,
        time: 35 * 60, 
        yield: 45000,
        exp: 8,
        water: 3,
        level: 3,
        description: "Ng√¥ ng·ªçt (b·∫Øp) ƒë·∫∑c s·∫£n mi·ªÅn Trung"
    },
    ca_chua: {
        name: "C√† chua",
        emoji: "üçÖ",
        price: 30000,
        time: 40 * 60, 
        yield: 55000,
        exp: 9,
        water: 3,
        level: 4,
        description: "C√† chua t∆∞∆°i ng·ªçt"
    },
    khoai_tay: {
        name: "Khoai t√¢y",
        emoji: "ü•î",
        price: 35000,
        time: 45 * 60, 
        yield: 65000,
        exp: 10,
        water: 3,
        level: 5,
        description: "Khoai t√¢y ƒê√† L·∫°t"
    },
    dua_hau: {
        name: "D∆∞a h·∫•u",
        emoji: "üçâ",
        price: 45000,
        time: 60 * 60, 
        yield: 85000,
        exp: 13,
        water: 4,
        level: 6,
        description: "D∆∞a h·∫•u mi·ªÅn Trung ng·ªçt l·ªãm"
    },
    thanh_long: {
        name: "Thanh Long",
        emoji: "üêâ",
        price: 70000,
        time: 80 * 60, 
        yield: 130000,
        exp: 15,
        water: 2,
        level: 8,
        description: "Thanh long ru·ªôt ƒë·ªè ƒë·∫∑c s·∫£n Vi·ªát Nam"
    },
    khoai_lang: {
        name: "Khoai lang",
        emoji: "üç†",
        price: 40000,
        time: 50 * 60, 
        yield: 70000,
        exp: 12,
        water: 2,
        level: 7,
        description: "Khoai lang v·ªè t√≠m ru·ªôt v√†ng"
    }
};

// C·∫•u h√¨nh v·∫≠t nu√¥i
const ANIMALS = {
    ga: {
        name: "G√†",
        emoji: "üêì",
        price: 100000,
        productTime: 3 * 60 * 60,
        product: "tr·ª©ng",
        productEmoji: "ü•ö",
        productPrice: 15000,
        feed: 5000,
        level: 3,
        description: "G√† ta ch·∫°y b·ªô, cho tr·ª©ng ch·∫•t l∆∞·ª£ng cao"
    },
    vit: {
        name: "V·ªãt",
        emoji: "ü¶Ü",
        price: 150000,
        productTime: 4 * 60 * 60, // 4 ti·∫øng
        product: "tr·ª©ng v·ªãt",
        productEmoji: "ü•ö",
        productPrice: 20000,
        feed: 7000,
        level: 5,
        description: "V·ªãt th·∫£ ƒë·ªìng, ƒë·∫ª tr·ª©ng v·ªãt dinh d∆∞·ª°ng"
    },
    heo: {
        name: "Heo",
        emoji: "üê∑",
        price: 300000,
        productTime: 6 * 60 * 60,
        product: "th·ªãt",
        productEmoji: "ü•©",
        productPrice: 50000,
        feed: 15000,
        level: 8,
        description: "Heo ƒë·∫∑c s·∫£n nu√¥i th·∫£ v∆∞·ªùn"
    },
    bo: {
        name: "B√≤",
        emoji: "üêÑ",
        price: 500000,
        productTime: 8 * 60 * 60,
        product: "s·ªØa",
        productEmoji: "ü•õ",
        productPrice: 80000,
        feed: 25000,
        level: 10,
        description: "B√≤ s·ªØa cho s·ªØa t∆∞∆°i nguy√™n ch·∫•t"
    },
    ca: {
        name: "C√°",
        emoji: "üêü",
        price: 80000,
        productTime: 2 * 60 * 60,
        product: "c√° t∆∞∆°i",
        productEmoji: "üê†",
        productPrice: 30000,
        feed: 8000,
        level: 4,
        description: "C√° ƒë·ªìng nu√¥i trong ao"
    }
};

// C·∫•u h√¨nh c·ª≠a h√†ng
const SHOP_ITEMS = {
    phan_bon: {
        name: "Ph√¢n b√≥n",
        emoji: "üí©",
        price: 20000,
        description: "Gi·∫£m 20% th·ªùi gian tr·ªìng tr·ªçt",
        effect: "grow_boost",
        duration: 24 * 60 * 60 * 1000,
        level: 1
    },
    thuoc_sau: {
        name: "Thu·ªëc s√¢u",
        emoji: "üß™",
        price: 30000,
        description: "TƒÉng 20% s·∫£n l∆∞·ª£ng thu ho·∫°ch",
        effect: "yield_boost",
        duration: 24 * 60 * 60 * 1000,
        level: 3
    },
    may_cay: {
        name: "M√°y c√†y",
        emoji: "üöú",
        price: 200000,
        description: "T·ª± ƒë·ªông gieo tr·ªìng v·ª• m·ªõi sau thu ho·∫°ch",
        effect: "auto_plant",
        duration: null, 
        level: 6
    },
    he_thong_tuoi: {
        name: "H·ªá th·ªëng t∆∞·ªõi",
        emoji: "üíß",
        price: 150000,
        description: "T·ª± ƒë·ªông t∆∞·ªõi c√¢y m·ªói 4 gi·ªù",
        effect: "auto_water",
        duration: null, 
        level: 5
    },
    chuong_trai: {
        name: "Chu·ªìng tr·∫°i n√¢ng c·∫•p",
        emoji: "üè°",
        price: 250000,
        description: "TƒÉng s·ªë l∆∞·ª£ng v·∫≠t nu√¥i t·ªëi ƒëa l√™n 10",
        effect: "animal_capacity",
        duration: null, 
        level: 7
    },
    thuc_an_gia_suc: {
        name: "Th·ª©c ƒÉn gia s√∫c",
        emoji: "üåæ",
        price: 50000,
        description: "TƒÉng 30% s·∫£n l∆∞·ª£ng t·ª´ v·∫≠t nu√¥i",
        effect: "animal_boost",
        duration: 24 * 60 * 60 * 1000,
        level: 4
    },
    giong_cao_cap: {
        name: "Gi·ªëng c√¢y cao c·∫•p",
        emoji: "üå±",
        price: 100000,
        description: "TƒÉng 50% kinh nghi·ªám t·ª´ tr·ªìng tr·ªçt",
        effect: "exp_boost",
        duration: 24 * 60 * 60 * 1000,
        level: 2
    }
};

// C·∫•u h√¨nh c·∫•p ƒë·ªô
const LEVELS = [
    { level: 1, exp: 0, title: "N√¥ng d√¢n t·∫≠p s·ª±", reward: 50000, plotSize: 4 },
    { level: 2, exp: 100, title: "N√¥ng d√¢n c·∫ßn m·∫´n", reward: 60000, plotSize: 6 },
    { level: 3, exp: 300, title: "Tr·ªìng tr·ªçt vi√™n", reward: 80000, plotSize: 8 },
    { level: 4, exp: 600, title: "N√¥ng d√¢n kinh nghi·ªám", reward: 100000, plotSize: 9 },
    { level: 5, exp: 1000, title: "Ng∆∞·ªùi l√†m v∆∞·ªùn", reward: 120000, plotSize: 12 },
    { level: 6, exp: 1500, title: "Ch·ªß trang tr·∫°i nh·ªè", reward: 150000, plotSize: 16 },
    { level: 7, exp: 2500, title: "N√¥ng d√¢n chuy√™n nghi·ªáp", reward: 200000, plotSize: 20 },
    { level: 8, exp: 4000, title: "Ch·ªß trang tr·∫°i", reward: 300000, plotSize: 25 },
    { level: 9, exp: 6000, title: "N√¥ng gia th·ªãnh v∆∞·ª£ng", reward: 400000, plotSize: 30 },
    { level: 10, exp: 10000, title: "ƒê·∫°i ƒëi·ªÅn ch·ªß", reward: 500000, plotSize: 36 }
];

// Th·ªùi ti·∫øt
const WEATHER_EFFECTS = {
    sunny: {
        name: "N·∫Øng r√°o",
        emoji: "‚òÄÔ∏è",
        cropBonus: 0.1,
        waterDrain: 0.2,
        description: "Ng√†y n·∫Øng ƒë·∫πp, c√¢y tr·ªìng ph√°t tri·ªÉn t·ªët nh∆∞ng c·∫ßn nhi·ªÅu n∆∞·ªõc h∆°n"
    },
    rainy: {
        name: "M∆∞a",
        emoji: "üåßÔ∏è",
        cropBonus: 0.05,
        waterFill: 0.5,
        description: "Tr·ªùi m∆∞a, t·ª± ƒë·ªông t∆∞·ªõi c√¢y nh∆∞ng nƒÉng su·∫•t th·∫•p h∆°n"
    },
    cloudy: {
        name: "√Çm u",
        emoji: "‚òÅÔ∏è",
        description: "Tr·ªùi √¢m u, kh√¥ng c√≥ ƒëi·ªÅu g√¨ ƒë·∫∑c bi·ªát"
    },
    storm: {
        name: "B√£o",
        emoji: "üå™Ô∏è",
        cropDamage: 0.2,
        description: "B√£o! C√¢y tr·ªìng c√≥ th·ªÉ b·ªã h·ªèng, h√£y thu ho·∫°ch s·ªõm!"
    },
    drought: {
        name: "H·∫°n h√°n",
        emoji: "üî•",
        waterDrain: 0.4,
        description: "H·∫°n h√°n, c√¢y m·∫•t n∆∞·ªõc nhanh ch√≥ng"
    }
};

// S·ª± ki·ªán ƒë·∫∑c bi·ªát
const EVENTS = {
    tet: {
        name: "T·∫øt Nguy√™n ƒê√°n",
        startMonth: 1, // Th√°ng 1-2 
        duration: 15,
        crops: {
            hoa_dao: {
                name: "Hoa ƒê√†o",
                emoji: "üå∏",
                price: 100000,
                time: 48 * 60 * 60,
                yield: 300000,
                exp: 30,
                water: 5,
                description: "Hoa ƒë√†o ƒë·ªè th·∫Øm, bi·ªÉu t∆∞·ª£ng c·ªßa T·∫øt mi·ªÅn B·∫Øc"
            },
            hoa_mai: {
                name: "Hoa Mai",
                emoji: "üåº",
                price: 100000,
                time: 48 * 60 * 60,
                yield: 300000,
                exp: 30,
                water: 5,
                description: "Hoa mai v√†ng r·ª±c r·ª°, bi·ªÉu t∆∞·ª£ng c·ªßa T·∫øt mi·ªÅn Nam"
            }
        }
    },
    trungThu: {
        name: "T·∫øt Trung Thu",
        startMonth: 8, // Th√°ng 8-9
        duration: 10,
        crops: {
            banhDeo: {
                name: "B√°nh D·∫ªo",
                emoji: "ü•Æ",
                price: 50000,
                time: 24 * 60 * 60,
                yield: 150000,
                exp: 20,
                water: 0, // Kh√¥ng c·∫ßn t∆∞·ªõi
                description: "B√°nh d·∫ªo nh√¢n th∆°m ngon truy·ªÅn th·ªëng"
            },
            banhNuong: {
                name: "B√°nh N∆∞·ªõng",
                emoji: "ü•ß",
                price: 60000,
                time: 24 * 60 * 60,
                yield: 180000,
                exp: 25,
                water: 0, // Kh√¥ng c·∫ßn t∆∞·ªõi
                description: "B√°nh n∆∞·ªõng nh√¢n th·∫≠p c·∫©m"
            }
        }
    }
};

// H√†m h·ªó tr·ª£
function formatNumber(number) {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function calculateLevel(exp) {
    for (let i = LEVELS.length - 1; i >= 0; i--) {
        if (exp >= LEVELS[i].exp) {
            return LEVELS[i];
        }
    }
    return LEVELS[0];
}

function getCurrentWeather(userID) {
    if (!userID) {
        console.error("userID is undefined in getCurrentWeather");
        return WEATHER_EFFECTS.sunny; // Default to sunny weather
    }
    
    try {
        const farmData = loadFarmData();
        if (!farmData || !farmData.farms) {
            console.error("Invalid farm data in getCurrentWeather");
            return WEATHER_EFFECTS.sunny;
        }
        
        const userFarm = farmData.farms[userID] || createUserFarm(userID);
        
        if (!userFarm.weather || Date.now() > userFarm.weather.nextChange) {
            // ƒê·ªïi th·ªùi ti·∫øt m·ªói 6 gi·ªù
            const weatherTypes = Object.keys(WEATHER_EFFECTS);
            // X√°c su·∫•t th·ªùi ti·∫øt (m∆∞a v√† n·∫Øng ph·ªï bi·∫øn h∆°n)
            let weatherChances = [0.4, 0.4, 0.1, 0.05, 0.05]; // sunny, rainy, cloudy, storm, drought
            
            // ƒêi·ªÅu ch·ªânh x√°c su·∫•t theo m√πa
            const date = new Date();
            const month = date.getMonth() + 1;
            
            if (month >= 5 && month <= 8) { // M√πa h√®
                weatherChances = [0.5, 0.2, 0.1, 0.1, 0.1]; // Nhi·ªÅu n·∫Øng v√† h·∫°n h√°n h∆°n
            } else if (month >= 9 && month <= 11) { // M√πa thu
                weatherChances = [0.3, 0.4, 0.2, 0.05, 0.05];
            } else if (month == 12 || month <= 2) { // M√πa ƒë√¥ng
                weatherChances = [0.2, 0.3, 0.4, 0.05, 0.05]; // Nhi·ªÅu √¢m u h∆°n
            } else { // M√πa xu√¢n
                weatherChances = [0.3, 0.4, 0.2, 0.1, 0]; // Nhi·ªÅu m∆∞a, kh√¥ng h·∫°n h√°n
            }
            
            let random = Math.random();
            let weatherIndex = 0;
            let sum = 0;
            
            for (let i = 0; i < weatherChances.length; i++) {
                sum += weatherChances[i];
                if (random < sum) {
                    weatherIndex = i;
                    break;
                }
            }
            
            userFarm.weather = {
                type: weatherTypes[weatherIndex],
                nextChange: Date.now() + 6 * 60 * 60 * 1000, // 6 gi·ªù
            };
            
            saveFarmData(farmData);
        }
        
        return WEATHER_EFFECTS[userFarm.weather.type] || WEATHER_EFFECTS.sunny;
    } catch (error) {
        console.error("Error in getCurrentWeather:", error);
        return WEATHER_EFFECTS.sunny;
    }
}

function checkEvent() {
    const now = new Date();
    const month = now.getMonth() + 1; 
    const day = now.getDate();
    
    for (const [eventId, event] of Object.entries(EVENTS)) {
       
        if (month === event.startMonth && day <= event.duration) {
            return {
                id: eventId,
                ...event
            };
        }
        
        if (eventId === 'tet' && month === event.startMonth + 1 && day <= 15) {
            return {
                id: eventId,
                ...event
            };
        }
    }
    
    return null;
}

function loadFarmData() {
    try {
        if (!fs.existsSync(farmDataPath)) {
            // Kh·ªüi t·∫°o d·ªØ li·ªáu m·∫∑c ƒë·ªãnh
            const defaultData = {
                farms: {},
                lastUpdate: Date.now()
            };
            fs.writeFileSync(farmDataPath, JSON.stringify(defaultData, null, 2));
            return defaultData;
        }
        const data = JSON.parse(fs.readFileSync(farmDataPath, 'utf8'));
        
        // Ensure data structure is valid
        if (!data.farms) {
            data.farms = {};
        }
        
        return data;
    } catch (error) {
        console.error('L·ªói khi ƒë·ªçc d·ªØ li·ªáu farm:', error);
        return { farms: {}, lastUpdate: Date.now() };
    }
}

function saveFarmData(data) {
    try {
        fs.writeFileSync(farmDataPath, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('L·ªói khi l∆∞u d·ªØ li·ªáu farm:', error);
    }
}

function createUserFarm(userID) {
    const farmData = loadFarmData();
    if (!farmData.farms[userID]) {
        farmData.farms[userID] = {
            id: userID,
            exp: 0,
            plots: [],
            inventory: {},
            animals: {},
            items: {},
            lastActive: Date.now(),
            createdAt: Date.now(),
            autoHarvest: false,
            weather: {
                type: 'sunny',
                nextChange: Date.now() + 6 * 60 * 60 * 1000
            }
        };
        
        // Kh·ªüi t·∫°o 4 √¥ ƒë·∫•t ƒë·∫ßu ti√™n
        for (let i = 0; i < 4; i++) {
            farmData.farms[userID].plots.push({
                id: i,
                status: 'empty',
                crop: null,
                plantedAt: null,
                water: 0,
                lastWatered: null
            });
        }
        
        saveFarmData(farmData);
    }
    
    return farmData.farms[userID];
}

function applyItemEffects(userFarm) {
    if (!userFarm) {
        console.error("userFarm is undefined in applyItemEffects");
        return {
            growBoost: 1,
            yieldBoost: 1,
            expBoost: 1,
            animalBoost: 1,
            autoPlant: false,
            autoWater: false,
            animalCapacity: 5
        };
    }
    
    const effects = {
        growBoost: 1,
        yieldBoost: 1,
        expBoost: 1,
        animalBoost: 1,
        autoPlant: false,
        autoWater: false,
        animalCapacity: 5
    };
    
    // Safely handle items that might be undefined
    if (!userFarm.items) return effects;
    
    // √Åp d·ª•ng hi·ªáu ·ª©ng t·ª´ c√°c v·∫≠t ph·∫©m
    for (const [itemId, item] of Object.entries(userFarm.items || {})) {
        if (!item || !item.active || (item.expiry && Date.now() > item.expiry)) {
            continue;
        }
        
        switch (item.effect) {
            case 'grow_boost':
                effects.growBoost = 0.8; // Gi·∫£m 20% th·ªùi gian
                break;
            case 'yield_boost':
                effects.yieldBoost = 1.2; // TƒÉng 20% s·∫£n l∆∞·ª£ng
                break;
            case 'exp_boost':
                effects.expBoost = 1.5; // TƒÉng 50% kinh nghi·ªám
                break;
            case 'animal_boost':
                effects.animalBoost = 1.3; // TƒÉng 30% s·∫£n l∆∞·ª£ng v·∫≠t nu√¥i
                break;
            case 'auto_plant':
                effects.autoPlant = true;
                break;
            case 'auto_water':
                effects.autoWater = true;
                break;
            case 'animal_capacity':
                effects.animalCapacity = 10;
                break;
        }
    }
    
    // √Åp d·ª•ng hi·ªáu ·ª©ng t·ª´ th·ªùi ti·∫øt - use a safer approach
    try {
        const weather = getCurrentWeather(userFarm.id);
        if (weather && weather.cropBonus) {
            effects.yieldBoost *= (1 + weather.cropBonus);
        }
    } catch (err) {
        console.error("Error applying weather effects:", err);
    }
    
    return effects;
}

function updateFarms() {
    try {
        const farmData = loadFarmData();
        if (!farmData || !farmData.farms) {
            console.error('Invalid farm data structure');
            return;
        }
        
        const currentTime = Date.now();
        
        Object.entries(farmData.farms || {}).forEach(([userID, farm]) => {
            if (!farm) return;
            
            if (farm.animals) {
                Object.entries(farm.animals).forEach(([animalId, animal]) => {
                    if (!animal) return;
                    
                    if (animal.lastProduced && animal.fed) {
                        const animalType = animal.type;
                        if (!animalType || !ANIMALS[animalType]) return;
                        
                        const animalConfig = ANIMALS[animalType];
                        const productionTime = animalConfig.productTime * 1000;
                        farm.id = userID;
                        
                        if (currentTime - animal.lastProduced >= productionTime) {
               
                            if (!farm.inventory) {
                                farm.inventory = {};
                            }
                            
                            if (!farm.inventory[animalConfig.product]) {
                                farm.inventory[animalConfig.product] = 0;
                            }
                            
                            const effects = applyItemEffects(farm);
                            const productAmount = Math.ceil(animalConfig.productPrice * effects.animalBoost);
                            
                            farm.inventory[animalConfig.product] += 1;
                            animal.lastProduced = currentTime;
                            animal.fed = false; 
                        }
                    }
                });
            }
            
            if (farm.plots) {
                farm.plots.forEach(plot => {
                    if (!plot || plot.status !== 'growing' || !plot.crop) return;
                    
                    const cropConfig = CROPS[plot.crop];
                    if (!cropConfig) return;
                    
                    const effects = applyItemEffects(farm);
                    const growTime = cropConfig.time * 1000 * effects.growBoost;
                    
                    const weather = getCurrentWeather(userID);
                    if (weather && weather.waterDrain && plot.water > 0) {
                        const timeSinceLastUpdate = currentTime - (farmData.lastUpdate || currentTime);
                        const waterDrainRate = weather.waterDrain * timeSinceLastUpdate / (1000 * 60 * 60);
                        plot.water = Math.round(Math.max(0, plot.water - waterDrainRate) * 10) / 10; // Round to 1 decimal place
                    }
                    
                    if (weather && weather.waterFill) {
                        const timeSinceLastUpdate = currentTime - (farmData.lastUpdate || currentTime);
                        const waterFillRate = weather.waterFill * timeSinceLastUpdate / (1000 * 60 * 60);
                        plot.water = Math.round(Math.min(cropConfig.water, plot.water + waterFillRate) * 10) / 10; // Round to 1 decimal place
                    }
                    
                    if (effects.autoWater && plot.water < cropConfig.water / 2) {
                        const lastAutoWater = plot.lastAutoWater || 0;
                        if (currentTime - lastAutoWater >= 4 * 60 * 60 * 1000) { 
                            plot.water = Math.round(cropConfig.water); 
                            plot.lastAutoWater = currentTime;
                        }
                    }
                    
                    if (currentTime - (plot.plantedAt || 0) >= growTime) {
                       
                        if (plot.water > 0) {
                            plot.status = 'ready';
                        } else {
                            
                            plot.plantedAt += 30 * 60 * 1000;
                        }
                    }
                    
                    if (weather && weather.type === 'storm' && weather.cropDamage && Math.random() < weather.cropDamage) {
                        plot.status = 'damaged';
                    }
                });
            }
            
            // C·∫≠p nh·∫≠t th·ªùi ti·∫øt
            if (farm.weather && currentTime > farm.weather.nextChange) {
                const weather = getCurrentWeather(userID);
                if (weather) {
                    farm.weather = {
                        type: weather.type,
                        nextChange: currentTime + 6 * 60 * 60 * 1000 // 6 gi·ªù
                    };
                }
            }
        });
        
        // C·∫≠p nh·∫≠t th·ªùi gian c·∫≠p nh·∫≠t cu·ªëi c√πng
        farmData.lastUpdate = currentTime;
        saveFarmData(farmData);
    } catch (error) {
        console.error('Error in updateFarms:', error);
    }
}

async function generateFarmImage(userFarm) {
    try {
        const canvas = createCanvas(800, 600);
        const ctx = canvas.getContext('2d');
        const currentTime = Date.now(); 
        
        const bgImage = await loadImage(path.join(__dirname, '../cache/farm/farm_bg.jpg'));
        ctx.drawImage(bgImage, 0, 0, 800, 600);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, 800, 50);
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        const level = calculateLevel(userFarm.exp);
        ctx.fillText(`Trang tr·∫°i C·∫•p ${level.level} - ${level.title}`, 20, 30);
        
        ctx.font = '16px Arial';
        ctx.fillText(`EXP: ${userFarm.exp}/${level.level < 10 ? LEVELS[level.level].exp : 'MAX'}`, 650, 30);
        
        const plotSize = 100;
        const plotsPerRow = 6;
        let plotX = 50;
        let plotY = 100;
        let rowCount = 0;
        
        const cropImages = {};
        for (const cropId in CROPS) {
            try {
                cropImages[cropId] = await loadImage(path.join(__dirname, `../cache/farm/crops/${cropId}.png`));
            } catch (err) {
                console.log(`Warning: Could not load image for crop ${cropId}`);
           
                cropImages[cropId] = await loadImage(path.join(__dirname, `../cache/farm/placeholder.png`));
            }
        }
        
        for (let i = 0; i < userFarm.plots.length; i++) {
            if (i > 0 && i % plotsPerRow === 0) {
                plotX = 50;
                plotY += plotSize + 20;
                rowCount++;
            }
            
            const plot = userFarm.plots[i];
            
            ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
            ctx.fillRect(plotX, plotY, plotSize, plotSize);
            ctx.strokeStyle = 'black';
            ctx.strokeRect(plotX, plotY, plotSize, plotSize);
            
            if (plot.status !== 'empty') {
                const cropImg = cropImages[plot.crop];
                if (cropImg) {
                    ctx.drawImage(cropImg, plotX + 10, plotY + 10, plotSize - 20, plotSize - 20);
                }
                
                let statusText = '';
                let statusColor = 'white';
                
                if (plot.status === 'growing') {
                    const cropConfig = CROPS[plot.crop];
                    if (cropConfig) {
                        const effects = applyItemEffects(userFarm);
                        const growTime = cropConfig.time * 1000 * effects.growBoost;
                        const progress = Math.min(100, Math.floor((currentTime - plot.plantedAt) / growTime * 100));
                        
                        statusText = `${progress}%`;
                        statusColor = progress < 50 ? '#ffcc00' : '#00cc00';
                        
                        const waterPercent = plot.water / cropConfig.water * 100;
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
                        ctx.fillRect(plotX, plotY + plotSize - 10, plotSize * (waterPercent / 100), 10);
                    } else {
                        statusText = 'ERROR';
                        statusColor = '#ff0000';
                    }
                } else if (plot.status === 'ready') {
                    statusText = 'S·∫¥N S√ÄNG';
                    statusColor = '#00ff00';
                } else if (plot.status === 'damaged') {
                    statusText = 'H∆Ø H·ªéNG';
                    statusColor = '#ff0000';
                }
                
                if (statusText) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(plotX, plotY + plotSize - 25, plotSize, 25);
                    ctx.fillStyle = statusColor;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(statusText, plotX + plotSize / 2, plotY + plotSize - 10);
                    ctx.textAlign = 'left';
                }
                
                // Draw crop name
                if (plot.crop) {
                    const cropConfig = CROPS[plot.crop];
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(plotX, plotY, plotSize, 20);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(`${cropConfig.emoji} ${cropConfig.name}`, plotX + 5, plotY + 15);
                }
            } else {
                // Empty plot
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('+', plotX + plotSize / 2, plotY + plotSize / 2 + 8);
                ctx.textAlign = 'left';
                
                ctx.font = '12px Arial';
                ctx.fillText(`√î ƒë·∫•t ${i + 1}`, plotX + 5, plotY + 15);
            }
            
            plotX += plotSize + 10;
        }
        
        // Draw weather info
        const weather = getCurrentWeather(userFarm.id);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(600, 60, 180, 80);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial';
        ctx.fillText(`${weather.emoji} ${weather.name}`, 610, 80);
        ctx.font = '12px Arial';
        ctx.fillText(weather.description, 610, 100);
        
        // Draw current event if any
        const currentEvent = checkEvent();
        if (currentEvent) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.fillRect(50, 60, 180, 30);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`üéâ ${currentEvent.name}`, 60, 80);
        }
        
        // Save the canvas to a file
        const outputPath = path.join(farmImagesDir, `farm_${userFarm.id}.png`);
        const buffer = canvas.toBuffer('image/png');
        fs.writeFileSync(outputPath, buffer);
        return outputPath;
        
    } catch (error) {
        console.error('Error generating farm image:', error);
        return null;
    }
}

module.exports = {
    name: "farm",
    dev: "HNT",
    usedby: 2,
    category: "Games",
    info: "Tr·ªìng tr·ªçt v√† chƒÉn nu√¥i nh∆∞ ·ªü n√¥ng th√¥n Vi·ªát Nam",
    onPrefix: true,
    usages: [
        "farm - xem trang tr·∫°i",
        "farm tr·ªìng <c√¢y tr·ªìng> <s·ªë √¥> - tr·ªìng c√¢y",
        "farm t∆∞·ªõi <s·ªë √¥> - t∆∞·ªõi n∆∞·ªõc cho c√¢y",
        "farm thu <s·ªë √¥> - thu ho·∫°ch",
        "farm mua <v·∫≠t nu√¥i/v·∫≠t ph·∫©m> - mua v·∫≠t nu√¥i ho·∫∑c v·∫≠t ph·∫©m",
        "farm cho_ƒÉn <lo·∫°i> - cho v·∫≠t nu√¥i ƒÉn",
        "farm thu_s·∫£n_ph·∫©m - thu th·∫≠p s·∫£n ph·∫©m t·ª´ v·∫≠t nu√¥i",
        "farm b√°n <s·∫£n ph·∫©m> <s·ªë l∆∞·ª£ng> - b√°n s·∫£n ph·∫©m thu ho·∫°ch",
        "farm c·ª≠a_h√†ng - xem c·ª≠a h√†ng",
        "farm info <c√¢y tr·ªìng/v·∫≠t nu√¥i> - xem th√¥ng tin"
    ],
    cooldowns: 3,

    onLaunch: async function({ api, event, target }) {
        const { threadID, messageID, senderID } = event;
        const currentTime = Date.now(); // Add this globally for the function

        try {
            updateFarms();
            
            const farmData = loadFarmData();
            if (!farmData || !farmData.farms) {
                console.error("Invalid farm data structure");
                return api.sendMessage("‚ùå L·ªói d·ªØ li·ªáu trang tr·∫°i! Vui l√≤ng th·ª≠ l·∫°i sau.", threadID, messageID);
            }
            
            const userFarm = farmData.farms[senderID] || createUserFarm(senderID);
            userFarm.id = senderID;
            farmData.farms[senderID] = userFarm;
            saveFarmData(farmData);
            
            if (!target[0]) {
                try {

                    const level = calculateLevel(userFarm.exp);
                    const nextLevel = level.level < 10 ? LEVELS[level.level] : null;
                    
                    let plotsReady = 0;
                    let plotsGrowing = 0;
                    let plotsEmpty = 0;
                    
                    userFarm.plots.forEach(plot => {
                        if (plot.status === 'ready') plotsReady++;
                        else if (plot.status === 'growing') plotsGrowing++;
                        else if (plot.status === 'empty') plotsEmpty++;
                    });
                    
                    let animalProducts = 0;
                    Object.entries(userFarm.animals || {}).forEach(([_, animal]) => {
                        if (animal.productReady) animalProducts++;
                    });
                    
                    // Ki·ªÉm tra s·ª± ki·ªán
                    const currentEvent = checkEvent();
                    const eventMessage = currentEvent ? 
                        `\nüéâ S·ª± ki·ªán ƒë·∫∑c bi·ªát: ${currentEvent.name} ƒëang di·ªÖn ra!\n` +
                        `‚Üí C√°c lo·∫°i c√¢y ƒë·∫∑c bi·ªát c√≥ s·∫µn ƒë·ªÉ tr·ªìng!` : '';
                    
                    const imagePath = await generateFarmImage(userFarm);
                    
                    const message = 
                        `üåæ N√îNG TR·∫†I VUI V·∫∫ üåæ\n` +
                        `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                        `üë®‚Äçüåæ C·∫•p ƒë·ªô: ${level.level} - ${level.title}\n` +
                        `üìä EXP: ${userFarm.exp}/${nextLevel ? nextLevel.exp : 'MAX'}\n` +
                        `üå± ƒê·∫•t tr·ªìng: ${userFarm.plots.length} √¥ (${plotsReady} s·∫µn s√†ng, ${plotsGrowing} ƒëang ph√°t tri·ªÉn, ${plotsEmpty} tr·ªëng)\n` +
                        `üêÑ V·∫≠t nu√¥i: ${Object.keys(userFarm.animals || {}).length} con (${animalProducts} s·∫£n ph·∫©m s·∫µn s√†ng)\n` +
                        `üå§Ô∏è Th·ªùi ti·∫øt: ${WEATHER_EFFECTS[userFarm.weather.type].emoji} ${WEATHER_EFFECTS[userFarm.weather.type].name}` +
                        eventMessage +
                        `\n\nüí° S·ª≠ d·ª•ng:\n` +
                        `‚Üí .farm tr·ªìng <c√¢y tr·ªìng> <s·ªë √¥> - ƒê·ªÉ tr·ªìng c√¢y\n` +
                        `‚Üí .farm c·ª≠a_h√†ng - Xem c·ª≠a h√†ng\n` +
                        `‚Üí .farm thu <s·ªë √¥> - Thu ho·∫°ch`;
                    
                    if (imagePath) {
                        await api.sendMessage({
                            body: message,
                            attachment: fs.createReadStream(imagePath)
                        }, threadID, messageID);
                    } else {
                        await api.sendMessage(message, threadID, messageID);
                    }
                    
                    try {
                        if (imagePath) fs.unlinkSync(imagePath);
                    } catch (err) {
                        console.error('Error cleaning up farm image:', err);
                    }
                    
                } catch (error) {
                    console.error("Farm display error:", error);
                    return api.sendMessage("‚ùå C√≥ l·ªói x·∫£y ra khi hi·ªÉn th·ªã trang tr·∫°i!", threadID, messageID);
                }
                return;
            }
            
            const command = target[0].toLowerCase();
            
            switch (command) {
                case "tr·ªìng":
                case "trong":
                case "plant": {
                    const cropId = target[1]?.toLowerCase();
                    const plotNumber = parseInt(target[2]) - 1;
                    
                    if (!cropId) {
                        let availableCrops = "üìã DANH S√ÅCH C√ÇY TR·ªíNG\n";
                        
                        const currentEvent = checkEvent();
                        if (currentEvent && currentEvent.crops) {
                            availableCrops += `\nüéâ C√ÇY TR·ªíNG S·ª∞ KI·ªÜN ${currentEvent.name}:\n`;
                            Object.entries(currentEvent.crops).forEach(([id, crop]) => {
                                availableCrops += `‚Üí ${crop.emoji} ${crop.name} (.farm tr·ªìng ${id})\n`;
                                availableCrops += `   üí∞ Gi√°: ${formatNumber(crop.price)} Xu\n`;
                                availableCrops += `   ‚è±Ô∏è Th·ªùi gian: ${Math.floor(crop.time / 3600)} gi·ªù ${(crop.time % 3600) / 60} ph√∫t\n`;
                                availableCrops += `   üíµ Thu ho·∫°ch: ${formatNumber(crop.yield)} Xu\n`;
                            });
                            availableCrops += "\n";
                        }
                        
                        availableCrops += "üìä C√ÇY TR·ªíNG TH∆Ø·ªúNG:\n";
                        const currentLevel = calculateLevel(userFarm.exp).level;
                        
                        Object.entries(CROPS)
                            .filter(([_, crop]) => crop.level <= currentLevel)
                            .forEach(([id, crop]) => {
                                availableCrops += `‚Üí ${crop.emoji} ${crop.name} (.farm tr·ªìng ${id})\n`;
                                availableCrops += `   üí∞ Gi√°: ${formatNumber(crop.price)} Xu\n`;
                                availableCrops += `   ‚è±Ô∏è Th·ªùi gian: ${Math.floor(crop.time / 60)} ph√∫t\n`;
                                availableCrops += `   üíß N∆∞·ªõc: ${crop.water} l·∫ßn t∆∞·ªõi\n`;
                                availableCrops += `   üíµ Thu ho·∫°ch: ${formatNumber(crop.yield)} Xu\n`;
                            });
                        
                        const lockedCrops = Object.entries(CROPS)
                            .filter(([_, crop]) => crop.level > currentLevel);
                        
                        if (lockedCrops.length > 0) {
                            availableCrops += "\nüîí C√ÇY TR·ªíNG KH√ìA (C·∫¶N N√ÇNG C·∫§P):\n";
                            lockedCrops.forEach(([id, crop]) => {
                                availableCrops += `‚Üí ${crop.emoji} ${crop.name} (C·∫ßn ƒë·∫°t c·∫•p ${crop.level})\n`;
                            });
                        }
                        
                        return api.sendMessage(availableCrops, threadID, messageID);
                    }
                    
                    let cropConfig;
                    const currentEvent = checkEvent();
                    
                    if (currentEvent && currentEvent.crops && currentEvent.crops[cropId]) {
                        cropConfig = currentEvent.crops[cropId];
                    } else if (CROPS[cropId]) {
                        cropConfig = CROPS[cropId];
                    } else {
                        return api.sendMessage(`‚ùå C√¢y tr·ªìng kh√¥ng t·ªìn t·∫°i! S·ª≠ d·ª•ng .farm tr·ªìng ƒë·ªÉ xem danh s√°ch.`, threadID, messageID);
                    }
                    
                    // Check user level
                    const currentLevel = calculateLevel(userFarm.exp).level;
                    if (cropConfig.level > currentLevel) {
                        return api.sendMessage(
                            `‚ùå B·∫°n c·∫ßn ƒë·∫°t c·∫•p ƒë·ªô ${cropConfig.level} ƒë·ªÉ tr·ªìng ${cropConfig.name}!\n` +
                            `üë®‚Äçüåæ C·∫•p ƒë·ªô hi·ªán t·∫°i: ${currentLevel}`,
                            threadID, messageID
                        );
                    }
                    
                    // Validate plot number
                    if (isNaN(plotNumber)) {
                        return api.sendMessage(
                            `‚ùå Vui l√≤ng nh·∫≠p s·ªë √¥ ƒë·∫•t ƒë·ªÉ tr·ªìng!\n` +
                            `üå± C√∫ ph√°p: .farm tr·ªìng ${cropId} <s·ªë √¥>`,
                            threadID, messageID
                        );
                    }
                    
                    if (plotNumber < 0 || plotNumber >= userFarm.plots.length) {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t kh√¥ng t·ªìn t·∫°i!\n` +
                            `üå± B·∫°n c√≥ ${userFarm.plots.length} √¥ ƒë·∫•t (t·ª´ 1 ƒë·∫øn ${userFarm.plots.length})`,
                            threadID, messageID
                        );
                    }
                    
                    // Check if plot is empty
                    const plot = userFarm.plots[plotNumber];
                    if (plot.status !== 'empty' && plot.status !== 'damaged') {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t ${plotNumber + 1} ƒëang c√≥ c√¢y tr·ªìng!\n` +
                            `‚Üí S·ª≠ d·ª•ng .farm thu ${plotNumber + 1} n·∫øu c√¢y ƒë√£ s·∫µn s√†ng thu ho·∫°ch`,
                            threadID, messageID
                        );
                    }
                    
                    // Check if user has enough money
                    const balance = await getBalance(senderID);
                    if (balance < cropConfig.price) {
                        return api.sendMessage(
                            `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ mua ${cropConfig.name}!\n` +
                            `üí∞ Gi√°: ${formatNumber(cropConfig.price)} Xu\n` +
                            `üíµ S·ªë d∆∞: ${formatNumber(balance)} Xu`,
                            threadID, messageID
                        );
                    }
                    
                    // Plant the crop
                    await updateBalance(senderID, -cropConfig.price);
                    plot.status = 'growing';
                    plot.crop = cropId;
                    plot.plantedAt = Date.now();
                    plot.water = cropConfig.water > 0 ? 1 : 0; // B·∫Øt ƒë·∫ßu v·ªõi 1 ƒë∆°n v·ªã n∆∞·ªõc ho·∫∑c 0 n·∫øu c√¢y kh√¥ng c·∫ßn n∆∞·ªõc
                    plot.lastWatered = Date.now();
                    
                    saveFarmData(farmData);
                    
                    return api.sendMessage(
                        `‚úÖ ƒê√£ tr·ªìng ${cropConfig.emoji} ${cropConfig.name} t·∫°i √¥ ƒë·∫•t ${plotNumber + 1}!\n` +
                        `‚è±Ô∏è Th·ªùi gian thu ho·∫°ch: ${Math.floor(cropConfig.time / 3600) > 0 ? 
                            `${Math.floor(cropConfig.time / 3600)} gi·ªù ${Math.floor((cropConfig.time % 3600) / 60)} ph√∫t` : 
                            `${Math.floor(cropConfig.time / 60)} ph√∫t`}\n` +
                        `üí¶ Nh·ªõ t∆∞·ªõi n∆∞·ªõc th∆∞·ªùng xuy√™n: .farm t∆∞·ªõi ${plotNumber + 1}`,
                        threadID, messageID
                    );
                }

                case "info":
case "th√¥ng_tin": {
    const infoTarget = target[1]?.toLowerCase();
    
    if (infoTarget) {
        if (CROPS[infoTarget]) {
            const crop = CROPS[infoTarget];
            return api.sendMessage(
                `üìä TH√îNG TIN C√ÇY TR·ªíNG\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `${crop.emoji} T√™n: ${crop.name}\n` +
                `üí∞ Gi√° gi·ªëng: ${formatNumber(crop.price)} Xu\n` +
                `‚è±Ô∏è Th·ªùi gian ph√°t tri·ªÉn: ${Math.floor(crop.time / 3600) > 0 ? 
                    `${Math.floor(crop.time / 3600)} gi·ªù ${Math.floor((crop.time % 3600) / 60)} ph√∫t` : 
                    `${Math.floor(crop.time / 60)} ph√∫t`}\n` +
                `üíß N∆∞·ªõc c·∫ßn thi·∫øt: ${crop.water} l·∫ßn t∆∞·ªõi\n` +
                `üíµ Thu ho·∫°ch: ${formatNumber(crop.yield)} Xu\n` +
                `üìà L·ª£i nhu·∫≠n: ${formatNumber(crop.yield - crop.price)} Xu\n` +
                `üìä Kinh nghi·ªám: ${crop.exp} EXP\n` +
                `üèÜ C·∫•p ƒë·ªô y√™u c·∫ßu: ${crop.level}\n` +
                `üìù M√¥ t·∫£: ${crop.description}\n`,
                threadID, messageID
            );
        }
        
        // Check for animal info
        if (ANIMALS[infoTarget]) {
            const animal = ANIMALS[infoTarget];
            return api.sendMessage(
                `üìä TH√îNG TIN V·∫¨T NU√îI\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `${animal.emoji} T√™n: ${animal.name}\n` +
                `üí∞ Gi√° mua: ${formatNumber(animal.price)} Xu\n` +
                `‚è±Ô∏è Chu k·ª≥ s·∫£n xu·∫•t: ${Math.floor(animal.productTime / 3600)} gi·ªù\n` +
                `üç≤ Chi ph√≠ th·ª©c ƒÉn: ${formatNumber(animal.feed)} Xu/l·∫ßn\n` +
                `${animal.productEmoji} S·∫£n ph·∫©m: ${animal.product}\n` +
                `üíµ Gi√° tr·ªã: ${formatNumber(animal.productPrice)} Xu\n` +
                `üìà L·ª£i nhu·∫≠n/ng√†y: ${formatNumber((24/(animal.productTime/3600))*animal.productPrice - (24/(animal.productTime/3600))*animal.feed)} Xu\n` +
                `üèÜ C·∫•p ƒë·ªô y√™u c·∫ßu: ${animal.level}\n` +
                `üìù M√¥ t·∫£: ${animal.description}`,
                threadID, messageID
            );
        }
    
        if (SHOP_ITEMS[infoTarget]) {
            const item = SHOP_ITEMS[infoTarget];
            return api.sendMessage(
                `üìä TH√îNG TIN V·∫¨T PH·∫®M\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `${item.emoji} T√™n: ${item.name}\n` +
                `üí∞ Gi√° mua: ${formatNumber(item.price)} Xu\n` +
                `‚è±Ô∏è Th·ªùi h·∫°n: ${item.duration ? Math.floor(item.duration / (24 * 60 * 60 * 1000)) + ' ng√†y' : 'Vƒ©nh vi·ªÖn'}\n` +
                `üîÆ Hi·ªáu ·ª©ng: ${item.description}\n` +
                `üèÜ C·∫•p ƒë·ªô y√™u c·∫ßu: ${item.level}`,
                threadID, messageID
            );
        }
        
        return api.sendMessage(
            `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ "${target[1]}"!\n` +
            `üí° H√£y nh·∫≠p ƒë√∫ng ID c·ªßa c√¢y tr·ªìng, v·∫≠t nu√¥i ho·∫∑c v·∫≠t ph·∫©m.\n` +
            `‚Üí V√≠ d·ª•: .farm info lua (L√∫a)\n` +
            `‚Üí V√≠ d·ª•: .farm info ga (G√†)`,
            threadID, messageID
        );
    }
    
    const level = calculateLevel(userFarm.exp);
    const nextLevel = level.level < 10 ? LEVELS[level.level] : null;
    
    let message = `üåæ TH√îNG TIN TRANG TR·∫†I üåæ\n` +
                 `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                 `üë®‚Äçüåæ C·∫•p ƒë·ªô: ${level.level} - ${level.title}\n` +
                 `üìä EXP: ${userFarm.exp}/${nextLevel ? nextLevel.exp : 'MAX'}\n` +
                 `üè° Ng√†y th√†nh l·∫≠p: ${new Date(userFarm.createdAt).toLocaleDateString('vi-VN')}\n`;
    
    // Weather info
    const weather = getCurrentWeather(senderID);
    message += `üå§Ô∏è Th·ªùi ti·∫øt: ${weather.emoji} ${weather.name}\n` +
              `‚Üí ${weather.description}\n`;
    
    // Plots info
    let plotsReady = 0;
    let plotsGrowing = 0;
    let plotsEmpty = 0;
    let plotsDamaged = 0;
    
    userFarm.plots.forEach(plot => {
        if (plot.status === 'ready') plotsReady++;
        else if (plot.status === 'growing') plotsGrowing++;
        else if (plot.status === 'empty') plotsEmpty++;
        else if (plot.status === 'damaged') plotsDamaged++;
    });
    
    message += `\nüå± TR·ªíNG TR·ªåT:\n` +
              `‚Üí T·ªïng s·ªë √¥ ƒë·∫•t: ${userFarm.plots.length} √¥\n` +
              `‚Üí ƒêang tr·ªìng: ${plotsGrowing} √¥\n` +
              `‚Üí S·∫µn s√†ng thu ho·∫°ch: ${plotsReady} √¥\n` +
              `‚Üí B·ªã h∆∞ h·ªèng: ${plotsDamaged} √¥\n` +
              `‚Üí C√≤n tr·ªëng: ${plotsEmpty} √¥\n`;
    
    // Currently growing crops
    const growingPlots = userFarm.plots.filter(plot => plot.status === 'growing');
    if (growingPlots.length > 0) {
        message += `\nC√ÇY ƒêANG PH√ÅT TRI·ªÇN:\n`;
        
        const cropCounts = {};
        growingPlots.forEach(plot => {
            if (!plot.crop) return;
            const cropId = plot.crop;
            const cropConfig = CROPS[cropId] || 
                (checkEvent() && checkEvent().crops ? checkEvent().crops[cropId] : null);
                
            if (cropConfig) {
                if (!cropCounts[cropId]) {
                    cropCounts[cropId] = {
                        count: 0,
                        name: cropConfig.name,
                        emoji: cropConfig.emoji
                    };
                }
                cropCounts[cropId].count++;
            }
        });
        
        Object.values(cropCounts).forEach(crop => {
            message += `‚Üí ${crop.emoji} ${crop.name}: ${crop.count} √¥\n`;
        });
    }
    
    const animalCount = Object.keys(userFarm.animals || {}).length;
    message += `\nüêÑ CHƒÇN NU√îI:\n` +
              `‚Üí S·ªë l∆∞·ª£ng v·∫≠t nu√¥i: ${animalCount} con\n`;
              
    if (animalCount > 0) {
        const animalCounts = {};
        Object.entries(userFarm.animals || {}).forEach(([_, animal]) => {
            if (!animal.type) return;
            const animalType = animal.type;
            if (!animalCounts[animalType]) {
                animalCounts[animalType] = {
                    count: 0,
                    ready: 0,
                    name: ANIMALS[animalType]?.name || animalType,
                    emoji: ANIMALS[animalType]?.emoji || "üêæ"
                };
            }
            animalCounts[animalType].count++;
            if (animal.productReady) animalCounts[animalType].ready++;
        });
        
        Object.values(animalCounts).forEach(animal => {
            message += `‚Üí ${animal.emoji} ${animal.name}: ${animal.count} con (${animal.ready} s·∫µn s√†ng)\n`;
        });
    }
    
    const inventoryEntries = Object.entries(userFarm.inventory || {});
    if (inventoryEntries.length > 0) {
        message += `\nüß∫ KHO H√ÄNG:\n`;
        
        inventoryEntries.forEach(([item, quantity]) => {
            if (quantity <= 0) return;
            
            let emoji = "üì¶";
            let productPrice = 0;
            
            for (const animalId in ANIMALS) {
                if (ANIMALS[animalId].product === item) {
                    emoji = ANIMALS[animalId].productEmoji;
                    productPrice = ANIMALS[animalId].productPrice;
                    break;
                }
            }
            
            message += `‚Üí ${emoji} ${item}: ${quantity} (${formatNumber(quantity * productPrice)} Xu)\n`;
        });
    }
    
    const activeItems = Object.entries(userFarm.items || {})
        .filter(([_, item]) => item.active && (!item.expiry || item.expiry > Date.now()));
        
    if (activeItems.length > 0) {
        message += `\nüîÆ V·∫¨T PH·∫®M ƒêANG HO·∫†T ƒê·ªòNG:\n`;
        
        activeItems.forEach(([itemId, item]) => {
            const shopItem = SHOP_ITEMS[itemId];
            if (!shopItem) return;
            
            const timeLeft = item.expiry ? 
                Math.max(0, Math.floor((item.expiry - Date.now()) / (60 * 60 * 1000))) : 
                "‚àû";
                
            message += `‚Üí ${shopItem.emoji} ${shopItem.name}: ${timeLeft === "‚àû" ? "Vƒ©nh vi·ªÖn" : `${timeLeft} gi·ªù c√≤n l·∫°i`}\n`;
        });
    }
    
    const effects = applyItemEffects(userFarm);
    message += `\nüîÑ HI·ªÜU ·ª®NG ƒêANG √ÅP D·ª§NG:\n`;
    
    if (effects.growBoost !== 1) {
        message += `‚Üí TƒÉng t·ªëc ph√°t tri·ªÉn: ${Math.round((1 - effects.growBoost) * 100)}%\n`;
    }
    
    if (effects.yieldBoost !== 1) {
        message += `‚Üí TƒÉng s·∫£n l∆∞·ª£ng: ${Math.round((effects.yieldBoost - 1) * 100)}%\n`;
    }
    
    if (effects.expBoost !== 1) {
        message += `‚Üí TƒÉng kinh nghi·ªám: ${Math.round((effects.expBoost - 1) * 100)}%\n`;
    }
    
    if (effects.animalBoost !== 1) {
        message += `‚Üí TƒÉng s·∫£n l∆∞·ª£ng v·∫≠t nu√¥i: ${Math.round((effects.animalBoost - 1) * 100)}%\n`;
    }
    
    if (effects.autoPlant) {
        message += `‚Üí T·ª± ƒë·ªông tr·ªìng l·∫°i c√¢y sau thu ho·∫°ch\n`;
    }
    
    if (effects.autoWater) {
        message += `‚Üí T·ª± ƒë·ªông t∆∞·ªõi c√¢y m·ªói 4 gi·ªù\n`;
    }
    
    message += `\nüí° Xem chi ti·∫øt v·ªÅ c√¢y tr·ªìng/v·∫≠t nu√¥i:\n‚Üí .farm info <t√™n_c√¢y/t√™n_v·∫≠t_nu√¥i>`;
    
    return api.sendMessage(message, threadID, messageID);
}
                
                case "t∆∞·ªõi":
                case "tuoi":
                case "water": {
                    const plotNumber = parseInt(target[1]) - 1;
                    
                    if (isNaN(plotNumber)) {
                        return api.sendMessage(
                            `‚ùå Vui l√≤ng nh·∫≠p s·ªë √¥ ƒë·∫•t ƒë·ªÉ t∆∞·ªõi n∆∞·ªõc!\n` +
                            `üå± C√∫ ph√°p: .farm t∆∞·ªõi <s·ªë √¥>`,
                            threadID, messageID
                        );
                    }
                    
                    if (plotNumber < 0 || plotNumber >= userFarm.plots.length) {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t kh√¥ng t·ªìn t·∫°i!\n` +
                            `üå± B·∫°n c√≥ ${userFarm.plots.length} √¥ ƒë·∫•t (t·ª´ 1 ƒë·∫øn ${userFarm.plots.length})`,
                            threadID, messageID
                        );
                    }
                    
                    const plot = userFarm.plots[plotNumber];
                    if (plot.status !== 'growing') {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t ${plotNumber + 1} kh√¥ng c√≥ c√¢y ƒëang ph√°t tri·ªÉn!`,
                            threadID, messageID
                        );
                    }
                    
                    const cropConfig = CROPS[plot.crop] || (currentEvent && currentEvent.crops[plot.crop]);
                    if (!cropConfig) {
                        return api.sendMessage(
                            `‚ùå L·ªói d·ªØ li·ªáu c√¢y tr·ªìng!`,
                            threadID, messageID
                        );
                    }
                    
                    if (cropConfig.water === 0) {
                        return api.sendMessage(
                            `‚ùå ${cropConfig.name} kh√¥ng c·∫ßn t∆∞·ªõi n∆∞·ªõc!`,
                            threadID, messageID
                        );
                    }
                    
                    if (plot.water >= cropConfig.water) {
                        return api.sendMessage(
                            `‚ùå ${cropConfig.name} ƒë√£ ƒë∆∞·ª£c t∆∞·ªõi ƒë·ªß n∆∞·ªõc!`,
                            threadID, messageID
                        );
                    }
                    
                    // Water the crop
                    plot.water = Math.min(cropConfig.water, plot.water + 1);
                    plot.lastWatered = Date.now();
                    
                    saveFarmData(farmData);
                    
                    return api.sendMessage(
                        `‚úÖ ƒê√£ t∆∞·ªõi n∆∞·ªõc cho ${cropConfig.emoji} ${cropConfig.name} t·∫°i √¥ ƒë·∫•t ${plotNumber + 1}!\n` +
                        `üíß N∆∞·ªõc hi·ªán t·∫°i: ${Math.round(plot.water)}/${cropConfig.water}`,
                        threadID, messageID
                    );
                }
                
                case "thu":
                case "thu_hoach":
                case "harvest": {
                    const plotNumber = parseInt(target[1]) - 1;
                    
                    if (isNaN(plotNumber)) {
                        // Harvest all ready crops
                        let readyPlots = userFarm.plots.filter(plot => plot.status === 'ready');
                        
                        if (readyPlots.length === 0) {
                            return api.sendMessage(
                                `‚ùå Kh√¥ng c√≥ c√¢y n√†o s·∫µn s√†ng ƒë·ªÉ thu ho·∫°ch!`,
                                threadID, messageID
                            );
                        }
                        
                        let totalYield = 0;
                        let totalExp = 0;
                        let harvestedCount = 0;
                        let harvestDetails = [];
                        
                        for (const plot of readyPlots) {
                            const cropId = plot.crop;
                            if (!cropId) continue;
                            
                            let cropConfig = CROPS[cropId];
                            if (!cropConfig) {
                                // Ki·ªÉm tra c√¢y s·ª± ki·ªán
                                const currentEvent = checkEvent();
                                if (currentEvent && currentEvent.crops && currentEvent.crops[cropId]) {
                                    cropConfig = currentEvent.crops[cropId];
                                } else {
                                    continue;
                                }
                            }
                            
                            // Apply boost effects
                            const effects = applyItemEffects(userFarm);
                            const yieldAmount = Math.floor(cropConfig.yield * effects.yieldBoost);
                            const expAmount = Math.floor(cropConfig.exp * effects.expBoost);
                            
                            // Add rewards
                            totalYield += yieldAmount;
                            totalExp += expAmount;
                            harvestedCount++;
                            
                            harvestDetails.push({
                                cropName: cropConfig.name,
                                emoji: cropConfig.emoji,
                                yield: yieldAmount,
                                exp: expAmount
                            });
                            
                            // Reset the plot
                            plot.status = 'empty';
                            plot.crop = null;
                            plot.plantedAt = null;
                            plot.water = 0;
                            plot.lastWatered = null;
                            
                            // Auto replant if the user has the item
                            if (effects.autoPlant) {
                                const userBalance = await getBalance(senderID);
                                if (userBalance >= cropConfig.price) {
                                    await updateBalance(senderID, -cropConfig.price);
                                    plot.status = 'growing';
                                    plot.crop = cropId;
                                    plot.plantedAt = Date.now();
                                    plot.water = cropConfig.water > 0 ? 1 : 0;
                                    plot.lastWatered = Date.now();
                                }
                            }
                        }
                        
                        // Update balance and exp
                        await updateBalance(senderID, totalYield);
                        userFarm.exp += totalExp;
                        
                        // Check for level up
                        const oldLevel = calculateLevel(userFarm.exp - totalExp).level;
                        const newLevel = calculateLevel(userFarm.exp).level;
                        
                        saveFarmData(farmData);
                        
                        let message = `‚úÖ ƒê√£ thu ho·∫°ch ${harvestedCount} c√¢y tr·ªìng!\n\n`;
                        
                        const groupedCrops = {};
                        harvestDetails.forEach(details => {
                            if (!groupedCrops[details.cropName]) {
                                groupedCrops[details.cropName] = {
                                    count: 0,
                                    totalYield: 0,
                                    totalExp: 0,
                                    emoji: details.emoji
                                };
                            }
                            groupedCrops[details.cropName].count++;
                            groupedCrops[details.cropName].totalYield += details.yield;
                            groupedCrops[details.cropName].totalExp += details.exp;
                        });
                        
                        Object.entries(groupedCrops).forEach(([cropName, details]) => {
                            message += `${details.emoji} ${cropName} x${details.count}: +${formatNumber(details.totalYield)} Xu, +${details.totalExp} EXP\n`;
                        });
                        
                        message += `\nüìä T·ªïng thu ho·∫°ch: +${formatNumber(totalYield)} Xu, +${totalExp} EXP`;
                        
                        if (newLevel > oldLevel) {
                            const newLevelData = LEVELS[newLevel - 1];
                            message += `\n\nüéâ CH√öC M·ª™NG! B·∫°n ƒë√£ l√™n c·∫•p ${newLevel}!\n`;
                            message += `üèÜ Danh hi·ªáu m·ªõi: ${newLevelData.title}\n`;
                            message += `üí∞ Ph·∫ßn th∆∞·ªüng: +${formatNumber(newLevelData.reward)} Xu\n`;
                            
                            if (newLevelData.plotSize > userFarm.plots.length) {
                                const newPlotsCount = newLevelData.plotSize - userFarm.plots.length;
                                message += `üå± M·ªü kh√≥a: ${newPlotsCount} √¥ ƒë·∫•t m·ªõi\n`;
                                
                                for (let i = 0; i < newPlotsCount; i++) {
                                    userFarm.plots.push({
                                        id: userFarm.plots.length,
                                        status: 'empty',
                                        crop: null,
                                        plantedAt: null,
                                        water: 0,
                                        lastWatered: null
                                    });
                                }
                            }
                            
                            await updateBalance(senderID, newLevelData.reward);
                            saveFarmData(farmData);
                        }
                        
                        updateQuestProgress(senderID, "farm_harvest", harvestedCount);
                        
                        return api.sendMessage(message, threadID, messageID);
                    }
                    
                    if (plotNumber < 0 || plotNumber >= userFarm.plots.length) {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t kh√¥ng t·ªìn t·∫°i!\n` +
                            `üå± B·∫°n c√≥ ${userFarm.plots.length} √¥ ƒë·∫•t (t·ª´ 1 ƒë·∫øn ${userFarm.plots.length})`,
                            threadID, messageID
                        );
                    }
                    
                    const plot = userFarm.plots[plotNumber];
                    
                    if (!plot) {
                        return api.sendMessage(
                            `‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu √¥ ƒë·∫•t ${plotNumber + 1}!`,
                            threadID, messageID
                        );
                    }
                    
                    if (plot.status === 'empty') {
                        return api.sendMessage(
                            `‚ùå √î ƒë·∫•t ${plotNumber + 1} ƒëang tr·ªëng, kh√¥ng c√≥ g√¨ ƒë·ªÉ thu ho·∫°ch!`,
                            threadID, messageID
                        );
                    }
                    
                    if (plot.status === 'growing') {
                        const cropId = plot.crop;
                        if (!cropId) {
                            plot.status = 'empty';
                            saveFarmData(farmData);
                            return api.sendMessage(
                                `‚ùå L·ªói d·ªØ li·ªáu c√¢y tr·ªìng! ƒê√£ ƒë·∫∑t l·∫°i √¥ ƒë·∫•t ${plotNumber + 1}.`,
                                threadID, messageID
                            );
                        }
                        
                        let cropConfig = CROPS[cropId];
                        
                        if (!cropConfig) {
                            const currentEvent = checkEvent();
                            if (currentEvent && currentEvent.crops && currentEvent.crops[cropId]) {
                                cropConfig = currentEvent.crops[cropId];
                            } else {
                                plot.status = 'empty';
                                plot.crop = null;
                                saveFarmData(farmData);
                                return api.sendMessage(
                                    `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin c√¢y tr·ªìng! ƒê√£ ƒë·∫∑t l·∫°i √¥ ƒë·∫•t ${plotNumber + 1}.`,
                                    threadID, messageID
                                );
                            }
                        }
                        
                        const effects = applyItemEffects(userFarm);
                        const growTime = cropConfig.time * 1000 * effects.growBoost;
                        const remainingTime = growTime - (Date.now() - plot.plantedAt);
                        
                        if (remainingTime > 0) {
                            const remainingHours = Math.floor(remainingTime / (1000 * 60 * 60));
                            const remainingMinutes = Math.floor((remainingTime % (1000 * 60 * 60)) / (1000 * 60));
                            const remainingSeconds = Math.floor((remainingTime % (1000 * 60)) / 1000);
                            
                            return api.sendMessage(
                                `‚ùå ${cropConfig.emoji} ${cropConfig.name} ch∆∞a s·∫µn s√†ng ƒë·ªÉ thu ho·∫°ch!\n` +
                                `‚è±Ô∏è Th·ªùi gian c√≤n l·∫°i: ${remainingHours > 0 ? `${remainingHours} gi·ªù ` : ''}${remainingMinutes} ph√∫t ${remainingSeconds} gi√¢y`,
                                threadID, messageID
                            );
                        }
                        
                        plot.status = 'ready';
                    }
                    
                    if (plot.status === 'ready') {
                        const cropId = plot.crop;
                        if (!cropId) {
                            plot.status = 'empty';
                            saveFarmData(farmData);
                            return api.sendMessage(
                                `‚ùå L·ªói d·ªØ li·ªáu c√¢y tr·ªìng! ƒê√£ ƒë·∫∑t l·∫°i √¥ ƒë·∫•t ${plotNumber + 1}.`,
                                threadID, messageID
                            );
                        }
                        
                        let cropConfig = CROPS[cropId];
                        
                        if (!cropConfig) {
                            const currentEvent = checkEvent();
                            if (currentEvent && currentEvent.crops && currentEvent.crops[cropId]) {
                                cropConfig = currentEvent.crops[cropId];
                            } else {
                                plot.status = 'empty';
                                plot.crop = null;
                                saveFarmData(farmData);
                                return api.sendMessage(
                                    `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin c√¢y tr·ªìng! ƒê√£ ƒë·∫∑t l·∫°i √¥ ƒë·∫•t ${plotNumber + 1}.`,
                                    threadID, messageID
                                );
                            }
                        }
                        
                        try {
                            // Apply boost effects
                            const effects = applyItemEffects(userFarm);
                            const yieldAmount = Math.floor(cropConfig.yield * effects.yieldBoost);
                            const expAmount = Math.floor(cropConfig.exp * effects.expBoost);
                            
                            // Add rewards
                            await updateBalance(senderID, yieldAmount);
                            userFarm.exp += expAmount;
                            
                            // Check for level up
                            const oldLevel = calculateLevel(userFarm.exp - expAmount).level;
                            const newLevel = calculateLevel(userFarm.exp).level;
                            
                            // Reset the plot
                            plot.status = 'empty';
                            plot.crop = null;
                            plot.plantedAt = null;
                            plot.water = 0;
                            plot.lastWatered = null;
                            
                            // Auto replant if the user has the item
                            let autoReplanted = false;
                            if (effects.autoPlant) {
                                try {
                                    const userBalance = await getBalance(senderID);
                                    if (userBalance >= cropConfig.price) {
                                        await updateBalance(senderID, -cropConfig.price);
                                        plot.status = 'growing';
                                        plot.crop = cropId;
                                        plot.plantedAt = Date.now();
                                        plot.water = cropConfig.water > 0 ? 1 : 0;
                                        plot.lastWatered = Date.now();
                                        autoReplanted = true;
                                    }
                                } catch (error) {
                                    console.error("Error in auto replant:", error);
                                }
                            }
                            
                            // Save after harvest
                            saveFarmData(farmData);
                            
                            // Update quest progress
                            updateQuestProgress(senderID, "farm_harvest", 1);
                            
                            // Create message
                            let message = 
                                `‚úÖ Thu ho·∫°ch th√†nh c√¥ng ${cropConfig.emoji} ${cropConfig.name}!\n` +
                                `üí∞ Nh·∫≠n ƒë∆∞·ª£c: ${formatNumber(yieldAmount)} Xu\n` +
                                `üìä EXP: +${expAmount}\n`;
                            
                            if (autoReplanted) {
                                message += `\nüå± ƒê√£ t·ª± ƒë·ªông tr·ªìng l·∫°i ${cropConfig.emoji} ${cropConfig.name}!`;
                            }
                            
                            if (newLevel > oldLevel) {
                                const newLevelData = LEVELS[newLevel - 1];
                                message += `\n\nüéâ CH√öC M·ª™NG! B·∫°n ƒë√£ l√™n c·∫•p ${newLevel}!\n`;
                                message += `üèÜ Danh hi·ªáu m·ªõi: ${newLevelData.title}\n`;
                                message += `üí∞ Ph·∫ßn th∆∞·ªüng: +${formatNumber(newLevelData.reward)} Xu\n`;
                                
                                if (newLevelData.plotSize > userFarm.plots.length) {
                                    const newPlotsCount = newLevelData.plotSize - userFarm.plots.length;
                                    message += `üå± M·ªü kh√≥a: ${newPlotsCount} √¥ ƒë·∫•t m·ªõi\n`;
                                    
                                    // Add new plots
                                    for (let i = 0; i < newPlotsCount; i++) {
                                        userFarm.plots.push({
                                            id: userFarm.plots.length,
                                            status: 'empty',
                                            crop: null,
                                            plantedAt: null,
                                            water: 0,
                                            lastWatered: null
                                        });
                                    }
                                    saveFarmData(farmData);
                                }
                                
                                // Give level up reward
                                await updateBalance(senderID, newLevelData.reward);
                            }
                            
                            return api.sendMessage(message, threadID, messageID);
                        } catch (error) {
                            console.error("Error in harvest:", error);
                            return api.sendMessage(
                                `‚ùå C√≥ l·ªói x·∫£y ra khi thu ho·∫°ch: ${error.message}`,
                                threadID, messageID
                            );
                        }
                    }
                    
                    return api.sendMessage(
                        `‚ùå Kh√¥ng th·ªÉ thu ho·∫°ch √¥ ƒë·∫•t ${plotNumber + 1} (Tr·∫°ng th√°i: ${plot.status})!`,
                        threadID, messageID
                    );
                }
                
                case "c·ª≠a_h√†ng":
                    case "shop": {
                        const shopType = target[1]?.toLowerCase();
                        const buyItem = target[2]?.toLowerCase();
                        const currentLevel = calculateLevel(userFarm.exp).level;
                        
                        if (!shopType) {
                            return api.sendMessage(
                                "üè™ C·ª¨A H√ÄNG N√îNG TR·∫†I üè™\n" +
                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                "1Ô∏è‚É£ C√¢y tr·ªìng:\n" +
                                "‚Üí .farm c·ª≠a_h√†ng c√¢y\n\n" +
                                "2Ô∏è‚É£ V·∫≠t nu√¥i:\n" +
                                "‚Üí .farm c·ª≠a_h√†ng v·∫≠t_nu√¥i\n\n" +
                                "3Ô∏è‚É£ V·∫≠t ph·∫©m:\n" +
                                "‚Üí .farm c·ª≠a_h√†ng v·∫≠t_ph·∫©m\n\n" +
                                "4Ô∏è‚É£ B√°n s·∫£n ph·∫©m:\n" +
                                "‚Üí .farm b√°n <s·∫£n ph·∫©m> <s·ªë l∆∞·ª£ng>",
                                threadID, messageID
                            );
                        }
                        
                        // Handle crop shop
                        if (shopType === "c√¢y" || shopType === "cay" || shopType === "crops") {
                            let message = "üå± C·ª¨A H√ÄNG H·∫†T GI·ªêNG üå±\n" +
                                          "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                                          
                            // Check for event crops first
                            const currentEvent = checkEvent();
                            if (currentEvent && currentEvent.crops) {
                                message += `üéâ GI·ªêNG C√ÇY S·ª∞ KI·ªÜN ${currentEvent.name}\n`;
                                
                                Object.entries(currentEvent.crops).forEach(([cropId, crop]) => {
                                    message += `\n${crop.emoji} ${crop.name}\n`;
                                    message += `üí∞ Gi√°: ${formatNumber(crop.price)} Xu\n`;
                                    message += `‚è±Ô∏è Th·ªùi gian: ${Math.floor(crop.time / 3600) > 0 ? 
                                        `${Math.floor(crop.time / 3600)} gi·ªù ${Math.floor((crop.time % 3600) / 60)} ph√∫t` : 
                                        `${Math.floor(crop.time / 60)} ph√∫t`}\n`;
                                    message += `üíµ Thu ho·∫°ch: ${formatNumber(crop.yield)} Xu\n`;
                                    message += `üìà L·ª£i nhu·∫≠n: ${formatNumber(crop.yield - crop.price)} Xu\n`;
                                    message += `üí° Mua: .farm tr·ªìng ${cropId} <s·ªë_√¥>\n`;
                                });
                                
                                message += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";
                            }
                            
                            message += "üìã DANH S√ÅCH GI·ªêNG C√ÇY\n";
                            
                            // Group crops by level requirement
                            const cropsByLevel = {};
                            Object.entries(CROPS).forEach(([cropId, crop]) => {
                                if (!cropsByLevel[crop.level]) {
                                    cropsByLevel[crop.level] = [];
                                }
                                cropsByLevel[crop.level].push({ id: cropId, ...crop });
                            });
                            
                            // Display available crops first (based on user level)
                            for (let level = 1; level <= currentLevel; level++) {
                                if (cropsByLevel[level]) {
                                    if (level > 1) message += "\n";
                                    message += `üåü C·∫§P ƒê·ªò ${level}:\n`;
                                    
                                    cropsByLevel[level].forEach(crop => {
                                        message += `\n${crop.emoji} ${crop.name}\n`;
                                        message += `üí∞ Gi√°: ${formatNumber(crop.price)} Xu\n`;
                                        message += `‚è±Ô∏è Th·ªùi gian: ${Math.floor(crop.time / 60)} ph√∫t\n`;
                                        message += `üíß N∆∞·ªõc: ${crop.water} l·∫ßn\n`;
                                        message += `üíµ Thu ho·∫°ch: ${formatNumber(crop.yield)} Xu\n`;
                                        message += `üìà L·ª£i nhu·∫≠n: ${formatNumber(crop.yield - crop.price)} Xu\n`;
                                        message += `üí° Mua: .farm tr·ªìng ${crop.id} <s·ªë_√¥>\n`;
                                    });
                                }
                            }
                            
                            // Show locked crops
                            if (currentLevel < 10) {
                                message += "\nüîí C√ÇY TR·ªíNG KH√ìA:\n";
                                
                                for (let level = currentLevel + 1; level <= 10; level++) {
                                    if (cropsByLevel[level]) {
                                        cropsByLevel[level].forEach(crop => {
                                            message += `\n${crop.emoji} ${crop.name} (C·∫ßn c·∫•p ${level})\n`;
                                        });
                                    }
                                }
                            }
                            
                            return api.sendMessage(message, threadID, messageID);
                        }
                        
                        // Handle animal shop
                        if (shopType === "v·∫≠t_nu√¥i" || shopType === "vat_nuoi" || shopType === "animals") {
                            // If there's a buy command, process it
                            if (buyItem) {
                                const animalConfig = ANIMALS[buyItem];
                                if (!animalConfig) {
                                    return api.sendMessage(
                                        `‚ùå Kh√¥ng t√¨m th·∫•y v·∫≠t nu√¥i "${target[2]}"!\n` +
                                        `üí° S·ª≠ d·ª•ng .farm c·ª≠a_h√†ng v·∫≠t_nu√¥i ƒë·ªÉ xem danh s√°ch.`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check user level
                                if (animalConfig.level > currentLevel) {
                                    return api.sendMessage(
                                        `‚ùå B·∫°n c·∫ßn ƒë·∫°t c·∫•p ƒë·ªô ${animalConfig.level} ƒë·ªÉ mua ${animalConfig.name}!\n` +
                                        `üë®‚Äçüåæ C·∫•p ƒë·ªô hi·ªán t·∫°i: ${currentLevel}`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check user balance
                                const balance = await getBalance(senderID);
                                if (balance < animalConfig.price) {
                                    return api.sendMessage(
                                        `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ mua ${animalConfig.name}!\n` +
                                        `üí∞ Gi√°: ${formatNumber(animalConfig.price)} Xu\n` +
                                        `üíµ S·ªë d∆∞: ${formatNumber(balance)} Xu`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check animal capacity
                                const effects = applyItemEffects(userFarm);
                                const animalCount = Object.keys(userFarm.animals || {}).length;
                                const maxAnimals = effects.animalCapacity;
                                
                                if (animalCount >= maxAnimals) {
                                    return api.sendMessage(
                                        `‚ùå Trang tr·∫°i c·ªßa b·∫°n ƒë√£ ƒë·∫°t gi·ªõi h·∫°n v·∫≠t nu√¥i!\n` +
                                        `üêÑ S·ªë l∆∞·ª£ng hi·ªán t·∫°i: ${animalCount}/${maxAnimals}\n` +
                                        `üí° N√¢ng c·∫•p chu·ªìng tr·∫°i ƒë·ªÉ nu√¥i th√™m v·∫≠t nu√¥i.`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Buy the animal
                                await updateBalance(senderID, -animalConfig.price);
                                
                                if (!userFarm.animals) {
                                    userFarm.animals = {};
                                }
                                
                                const animalId = Date.now().toString();
                                userFarm.animals[animalId] = {
                                    id: animalId,
                                    type: buyItem,
                                    purchased: Date.now(),
                                    fed: false,
                                    lastFed: null,
                                    lastProduced: null,
                                    productReady: false
                                };
                                
                                saveFarmData(farmData);
                                
                                return api.sendMessage(
                                    `‚úÖ ƒê√£ mua ${animalConfig.emoji} ${animalConfig.name} th√†nh c√¥ng!\n` +
                                    `üí∞ Chi ph√≠: -${formatNumber(animalConfig.price)} Xu\n` +
                                    `ü•´ Nh·ªõ cho ƒÉn th∆∞·ªùng xuy√™n: .farm cho_ƒÉn ${buyItem}`,
                                    threadID, messageID
                                );
                            }
                            
                            // Display animal shop
                            let message = "üêÑ C·ª¨A H√ÄNG V·∫¨T NU√îI üêÑ\n" +
                                          "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                          "üìã DANH S√ÅCH V·∫¨T NU√îI\n";
                            
                            // Group animals by level requirement
                            const animalsByLevel = {};
                            Object.entries(ANIMALS).forEach(([animalId, animal]) => {
                                if (!animalsByLevel[animal.level]) {
                                    animalsByLevel[animal.level] = [];
                                }
                                animalsByLevel[animal.level].push({ id: animalId, ...animal });
                            });
                            
                            // Display available animals first (based on user level)
                            for (let level = 1; level <= currentLevel; level++) {
                                if (animalsByLevel[level]) {
                                    if (level > 1) message += "\n";
                                    message += `üåü C·∫§P ƒê·ªò ${level}:\n`;
                                    
                                    animalsByLevel[level].forEach(animal => {
                                        const dailyProfit = (24/(animal.productTime/3600))*animal.productPrice - (24/(animal.productTime/3600))*animal.feed;
                                        
                                        message += `\n${animal.emoji} ${animal.name}\n`;
                                        message += `üí∞ Gi√°: ${formatNumber(animal.price)} Xu\n`;
                                        message += `‚è±Ô∏è Chu k·ª≥: ${Math.floor(animal.productTime / 3600)} gi·ªù\n`;
                                        message += `üç≤ Th·ª©c ƒÉn: ${formatNumber(animal.feed)}/l·∫ßn\n`;
                                        message += `${animal.productEmoji} S·∫£n ph·∫©m: ${animal.product} (${formatNumber(animal.productPrice)} Xu)\n`;
                                        message += `üìà L·ª£i nhu·∫≠n/ng√†y: ${formatNumber(dailyProfit)} Xu\n`;
                                        message += `üí° Mua: .farm c·ª≠a_h√†ng v·∫≠t_nu√¥i ${animal.id}\n`;
                                    });
                                }
                            }
                            
                            // Show locked animals
                            if (currentLevel < 10) {
                                message += "\nüîí V·∫¨T NU√îI KH√ìA:\n";
                                
                                for (let level = currentLevel + 1; level <= 10; level++) {
                                    if (animalsByLevel[level]) {
                                        animalsByLevel[level].forEach(animal => {
                                            message += `\n${animal.emoji} ${animal.name} (C·∫ßn c·∫•p ${level})\n`;
                                        });
                                    }
                                }
                            }
                            
                            return api.sendMessage(message, threadID, messageID);
                        }
                        
                        // Handle item shop
                        if (shopType === "v·∫≠t_ph·∫©m" || shopType === "vat_pham" || shopType === "items") {
                            // If there's a buy command, process it
                            if (buyItem) {
                                const itemConfig = SHOP_ITEMS[buyItem];
                                if (!itemConfig) {
                                    return api.sendMessage(
                                        `‚ùå Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m "${target[2]}"!\n` +
                                        `üí° S·ª≠ d·ª•ng .farm c·ª≠a_h√†ng v·∫≠t_ph·∫©m ƒë·ªÉ xem danh s√°ch.`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check user level
                                if (itemConfig.level > currentLevel) {
                                    return api.sendMessage(
                                        `‚ùå B·∫°n c·∫ßn ƒë·∫°t c·∫•p ƒë·ªô ${itemConfig.level} ƒë·ªÉ mua ${itemConfig.name}!\n` +
                                        `üë®‚Äçüåæ C·∫•p ƒë·ªô hi·ªán t·∫°i: ${currentLevel}`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check user balance
                                const balance = await getBalance(senderID);
                                if (balance < itemConfig.price) {
                                    return api.sendMessage(
                                        `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ mua ${itemConfig.name}!\n` +
                                        `üí∞ Gi√°: ${formatNumber(itemConfig.price)} Xu\n` +
                                        `üíµ S·ªë d∆∞: ${formatNumber(balance)} Xu`,
                                        threadID, messageID
                                    );
                                }
                                
                                // Check if player already has the item
                                if (userFarm.items && userFarm.items[buyItem] && 
                                    (userFarm.items[buyItem].active && !userFarm.items[buyItem].expiry || 
                                    userFarm.items[buyItem].expiry > Date.now())) {
                                    
                                    // For permanent items, check if active
                                    if (!itemConfig.duration && userFarm.items[buyItem].active) {
                                        return api.sendMessage(
                                            `‚ùå B·∫°n ƒë√£ s·ªü h·ªØu ${itemConfig.name}!\n` +
                                            `üí° ƒê√¢y l√† v·∫≠t ph·∫©m vƒ©nh vi·ªÖn, kh√¥ng th·ªÉ mua th√™m.`,
                                            threadID, messageID
                                        );
                                    }
                                }
                                
                                // Buy the item
                                await updateBalance(senderID, -itemConfig.price);
                                
                                if (!userFarm.items) {
                                    userFarm.items = {};
                                }
                                
                                userFarm.items[buyItem] = {
                                    purchased: Date.now(),
                                    active: true,
                                    effect: itemConfig.effect,
                                    expiry: itemConfig.duration ? Date.now() + itemConfig.duration : null
                                };
                                
                                saveFarmData(farmData);
                                
                                return api.sendMessage(
                                    `‚úÖ ƒê√£ mua ${itemConfig.emoji} ${itemConfig.name} th√†nh c√¥ng!\n` +
                                    `üí∞ Chi ph√≠: -${formatNumber(itemConfig.price)} Xu\n` +
                                    `‚è±Ô∏è Th·ªùi h·∫°n: ${itemConfig.duration ? 
                                        Math.floor(itemConfig.duration / (24 * 60 * 60 * 1000)) + ' ng√†y' : 
                                        'Vƒ©nh vi·ªÖn'}\n` +
                                    `üîÆ Hi·ªáu ·ª©ng: ${itemConfig.description}\n` +
                                    `‚Üí Hi·ªáu ·ª©ng ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng t·ª± ƒë·ªông!`,
                                    threadID, messageID
                                );
                            }
                            
                            let message = "üîÆ C·ª¨A H√ÄNG V·∫¨T PH·∫®M üîÆ\n" +
                                          "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                                          "üìã DANH S√ÅCH V·∫¨T PH·∫®M\n";
                        
                            const itemsByLevel = {};
                            Object.entries(SHOP_ITEMS).forEach(([itemId, item]) => {
                                if (!itemsByLevel[item.level]) {
                                    itemsByLevel[item.level] = [];
                                }
                                itemsByLevel[item.level].push({ id: itemId, ...item });
                            });
                            
                            for (let level = 1; level <= currentLevel; level++) {
                                if (itemsByLevel[level]) {
                                    if (level > 1) message += "\n";
                                    message += `üåü C·∫§P ƒê·ªò ${level}:\n`;
                                    
                                    itemsByLevel[level].forEach(item => {
                                        const owned = userFarm.items && userFarm.items[item.id] && 
                                                     userFarm.items[item.id].active && 
                                                     (!userFarm.items[item.id].expiry || userFarm.items[item.id].expiry > Date.now());
                                        
                                        message += `\n${item.emoji} ${item.name} ${owned ? '(ƒê√£ s·ªü h·ªØu)' : ''}\n`;
                                        message += `üí∞ Gi√°: ${formatNumber(item.price)} Xu\n`;
                                        message += `‚è±Ô∏è Th·ªùi h·∫°n: ${item.duration ? 
                                            Math.floor(item.duration / (24 * 60 * 60 * 1000)) + ' ng√†y' : 
                                            'Vƒ©nh vi·ªÖn'}\n`;
                                        message += `üîÆ Hi·ªáu ·ª©ng: ${item.description}\n`;
                                        
                                        if (!owned) {
                                            message += `üí° Mua: .farm c·ª≠a_h√†ng v·∫≠t_ph·∫©m ${item.id}\n`;
                                        }
                                    });
                                }
                            }
                            
                            if (currentLevel < 10) {
                                message += "\nüîí V·∫¨T PH·∫®M KH√ìA:\n";
                                
                                for (let level = currentLevel + 1; level <= 10; level++) {
                                    if (itemsByLevel[level]) {
                                        itemsByLevel[level].forEach(item => {
                                            message += `\n${item.emoji} ${item.name} (C·∫ßn c·∫•p ${level})\n`;
                                        });
                                    }
                                }
                            }
                            
                            return api.sendMessage(message, threadID, messageID);
                        }
                        
                        return api.sendMessage(
                            "‚ùå Lo·∫°i c·ª≠a h√†ng kh√¥ng h·ª£p l·ªá!\n" +
                            "üí° S·ª≠ d·ª•ng m·ªôt trong c√°c l·ªánh sau:\n" +
                            "‚Üí .farm c·ª≠a_h√†ng c√¢y\n" +
                            "‚Üí .farm c·ª≠a_h√†ng v·∫≠t_nu√¥i\n" +
                            "‚Üí .farm c·ª≠a_h√†ng v·∫≠t_ph·∫©m",
                            threadID, messageID
                        );
                    }
                
                default:
                    return api.sendMessage(
                        "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!\n" +
                        "üí° S·ª≠ d·ª•ng:\n" +
                        "‚Üí .farm - Xem trang tr·∫°i\n" +
                        "‚Üí .farm tr·ªìng <c√¢y tr·ªìng> <s·ªë √¥> - Tr·ªìng c√¢y\n" +
                        "‚Üí .farm t∆∞·ªõi <s·ªë √¥> - T∆∞·ªõi n∆∞·ªõc cho c√¢y\n" +
                        "‚Üí .farm thu <s·ªë √¥> - Thu ho·∫°ch\n" +
                        "‚Üí .farm c·ª≠a_h√†ng - Xem c·ª≠a h√†ng",
                        threadID, messageID
                    );
            }
        } catch (error) {
            console.error("Farm command error:", error);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω l·ªánh farm! Vui l√≤ng th·ª≠ l·∫°i.", threadID, messageID);
        }
    }
};