const fs = require('fs');
const path = require('path');

// Hunt cooldown in milliseconds (default: 1 hour)
const HUNT_COOLDOWN = 60 * 1000;

const VOUCHER_TYPES = {
    BRONZE: { color: "#CD7F32", emoji: "ü•â", discount: 10, chance: 0.5, durationDays: 7 },
    SILVER: { color: "#C0C0C0", emoji: "ü•à", discount: 15, chance: 0.3, durationDays: 7 },
    GOLD: { color: "#FFD700", emoji: "üéñÔ∏è", discount: 20, chance: 0.15, durationDays: 7 },
    PLATINUM: { color: "#E5E4E2", emoji: "üíé", discount: 25, chance: 0.05, durationDays: 7 },
    EVENT: { color: "#FF4500", emoji: "üéä", discount: "ƒê·∫∑c bi·ªát", chance: 0 }
};

// Generate a random voucher code
function generateVoucherCode(type) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = `${type}_`;
    for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
}

// Check if user can hunt (cooldown)
function canHunt(userId) {
    const voucherData = loadVouchers();
    
    if (!voucherData.hunts || !voucherData.hunts[userId]) {
        return { canHunt: true };
    }
    
    const lastHunt = voucherData.hunts[userId].lastHunt;
    const now = Date.now();
    
    if (now - lastHunt < HUNT_COOLDOWN) {
        const timeLeft = HUNT_COOLDOWN - (now - lastHunt);
        const minutesLeft = Math.ceil(timeLeft / (1000 * 60));
        return { 
            canHunt: false, 
            timeLeft: minutesLeft,
            message: `‚è≥ B·∫°n c·∫ßn ch·ªù ${minutesLeft} ph√∫t n·ªØa ƒë·ªÉ ti·∫øp t·ª•c sƒÉn voucher.`
        };
    }
    
    return { canHunt: true };
}

// Hunt for a voucher
function huntVoucher(userId) {
    // Check cooldown
    const huntStatus = canHunt(userId);
    if (!huntStatus.canHunt) {
        return huntStatus;
    }
    
    // Update hunt timestamp
    const voucherData = loadVouchers();
    if (!voucherData.hunts) voucherData.hunts = {};
    if (!voucherData.hunts[userId]) {
        voucherData.hunts[userId] = { lastHunt: 0, totalHunts: 0, foundVouchers: 0 };
    }
    
    voucherData.hunts[userId].lastHunt = Date.now();
    voucherData.hunts[userId].totalHunts++;
    
    // Random chance to find nothing (25%)
    if (Math.random() < 0.25) {
        saveVouchers(voucherData);
        return { 
            success: false, 
            message: "üòî Th·∫≠t ti·∫øc! B·∫°n ƒë√£ t√¨m ki·∫øm trong r·ª´ng nh∆∞ng kh√¥ng t√¨m th·∫•y voucher n√†o." 
        };
    }
    
    // Determine voucher type based on chance
    const rand = Math.random();
    let cumulativeChance = 0;
    let selectedType = null;
    
    for (const [type, config] of Object.entries(VOUCHER_TYPES)) {
        if (config.chance && config.chance > 0) {
            cumulativeChance += config.chance;
            if (rand <= cumulativeChance) {
                selectedType = type;
                break;
            }
        }
    }
    
    // If somehow we didn't select a type, default to BRONZE
    if (!selectedType) selectedType = "BRONZE";
    
    // Generate voucher
    const voucherConfig = VOUCHER_TYPES[selectedType];
    const voucher = {
        type: selectedType,
        code: generateVoucherCode(selectedType),
        discount: voucherConfig.discount,
        expires: Date.now() + (voucherConfig.durationDays * 24 * 60 * 60 * 1000),
        used: false,
        source: "hunting",
        foundAt: Date.now()
    };
    
    // Add voucher to user's collection
    if (!voucherData.users) voucherData.users = {};
    if (!voucherData.users[userId]) {
        voucherData.users[userId] = [];
    }
    
    voucherData.users[userId].push(voucher);
    voucherData.hunts[userId].foundVouchers++;
    
    saveVouchers(voucherData);
    
    return {
        success: true,
        voucher: voucher,
        message: `üéâ CH√öC M·ª™NG! B·∫°n ƒë√£ t√¨m th·∫•y ${voucherConfig.emoji} VOUCHER ${selectedType}!`
    };
}

// Get hunt stats for a user
function getHuntStats(userId) {
    const voucherData = loadVouchers();
    
    if (!voucherData.hunts || !voucherData.hunts[userId]) {
        return {
            totalHunts: 0,
            foundVouchers: 0,
            successRate: "0%"
        };
    }
    
    const stats = voucherData.hunts[userId];
    const successRate = stats.totalHunts > 0 ? 
        Math.round((stats.foundVouchers / stats.totalHunts) * 100) + "%" : 
        "0%";
        
    return {
        totalHunts: stats.totalHunts,
        foundVouchers: stats.foundVouchers,
        successRate: successRate
    };
}

function formatNumber(number) {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function formatTimeLeft(timestamp) {
    const now = Date.now();
    const diff = timestamp - now;
    
    if (diff <= 0) return "ƒê√£ h·∫øt h·∫°n";
    
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    
    if (days > 0) return `${days} ng√†y ${hours} gi·ªù`;
    
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    if (hours > 0) return `${hours} gi·ªù ${minutes} ph√∫t`;
    
    return `${minutes} ph√∫t`;
}

function getVoucherIcon(type) {
    return VOUCHER_TYPES[type]?.emoji || "üé´";
}

function loadVouchers() {
    const voucherPath = path.join(__dirname, 'json', 'voucher.json');
    if (!fs.existsSync(voucherPath)) {
        fs.writeFileSync(voucherPath, JSON.stringify({users: {}, hunts: {}}, null, 2));
        return {users: {}, hunts: {}};
    }
    return JSON.parse(fs.readFileSync(voucherPath, 'utf8'));
}

function saveVouchers(voucherData) {
    const voucherPath = path.join(__dirname, 'json', 'voucher.json');
    fs.writeFileSync(voucherPath, JSON.stringify(voucherData, null, 2));
}

function getUserVouchers(userId) {
    const voucherData = loadVouchers();
    return (voucherData.users[userId] || []).sort((a, b) => {
        // Sort by: unused first, then by expiration (closest first), then by discount (highest first)
        if (a.used !== b.used) return a.used ? 1 : -1;
        if (a.expires !== b.expires) return a.expires - b.expires;
        return b.discount - a.discount;
    });
}

function checkExpiringVouchers(userId) {
    const vouchers = getUserVouchers(userId);
    const now = Date.now();
    const dayInMillis = 24 * 60 * 60 * 1000;
    
    // Find vouchers expiring within 3 days
    return vouchers.filter(v => !v.used && 
        v.expires > now && 
        v.expires < now + (3 * dayInMillis));
}

function transferVoucher(fromUserId, toUserId, voucherCode) {
    if (fromUserId === toUserId) return { success: false, message: "Kh√¥ng th·ªÉ t·ª± chuy·ªÉn voucher cho b·∫£n th√¢n" };
    
    const voucherData = loadVouchers();
    const fromUserVouchers = voucherData.users[fromUserId] || [];
    
    const voucherIndex = fromUserVouchers.findIndex(v => v.code === voucherCode && !v.used);
    if (voucherIndex === -1) {
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y voucher c√≥ th·ªÉ chuy·ªÉn" };
    }
    
    const voucher = {...fromUserVouchers[voucherIndex]};
    
    // Remove from sender
    fromUserVouchers.splice(voucherIndex, 1);
    voucherData.users[fromUserId] = fromUserVouchers;
    
    // Add to receiver
    if (!voucherData.users[toUserId]) voucherData.users[toUserId] = [];
    voucherData.users[toUserId].push(voucher);
    
    saveVouchers(voucherData);
    
    return { 
        success: true, 
        message: "Chuy·ªÉn voucher th√†nh c√¥ng",
        voucher
    };
}

function useVoucher(userId, voucherCode) {
    const voucherData = loadVouchers();
    const userVouchers = voucherData.users[userId] || [];
    
    const voucherIndex = userVouchers.findIndex(v => v.code === voucherCode && !v.used);
    if (voucherIndex === -1) {
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y voucher ho·∫∑c ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng" };
    }
    
    if (userVouchers[voucherIndex].expires < Date.now()) {
        return { success: false, message: "Voucher ƒë√£ h·∫øt h·∫°n" };
    }
    
    userVouchers[voucherIndex].used = true;
    voucherData.users[userId] = userVouchers;
    saveVouchers(voucherData);
    
    return { 
        success: true, 
        message: "ƒê√£ s·ª≠ d·ª•ng voucher th√†nh c√¥ng",
        voucher: userVouchers[voucherIndex]
    };
}

function renderVouchers(vouchers, showExpired = false) {
    if (vouchers.length === 0) {
        return "B·∫°n kh√¥ng c√≥ voucher n√†o";
    }

    const now = Date.now();
    let vouchersForDisplay = vouchers;
    
    if (!showExpired) {
        vouchersForDisplay = vouchers.filter(v => !v.used && v.expires > now);
    }
    
    if (vouchersForDisplay.length === 0) {
        return "B·∫°n kh√¥ng c√≥ voucher h·ª£p l·ªá n√†o";
    }

    let message = "";
    
    vouchersForDisplay.forEach((v, index) => {
        const isExpired = v.expires < now;
        const isUsed = v.used;
        const icon = getVoucherIcon(v.type);
        const status = isUsed ? "‚ö†Ô∏èƒê√É D√ôNG" : (isExpired ? "‚åõH·∫æT H·∫†N" : "‚úÖC√íN H·∫†N");
        const timeLeft = formatTimeLeft(v.expires);
        
        message += `${index + 1}. ${icon} VOUCHER ${v.type} [${status}]\n`;
        message += `   ‚îú M√£: ${v.code}\n`;
        message += `   ‚îú Gi·∫£m gi√°: ${v.discount}%\n`;
        message += `   ‚îî ${isExpired ? "H·∫øt h·∫°n t·ª´: " : "C√≤n l·∫°i: "} ${timeLeft}\n\n`;
    });
    
    return message;
}

module.exports = {
    name: "voucher",
    aliases: ["vch", "coupon", "hunt"],
    dev: "HNT",
    category: "Economy",
    info: "Qu·∫£n l√Ω voucher gi·∫£m gi√°",
    usages: [
        ".voucher - Xem danh s√°ch voucher",
        ".voucher all - Xem t·∫•t c·∫£ voucher (bao g·ªìm ƒë√£ d√πng/h·∫øt h·∫°n)",
        ".voucher use <m√£> - S·ª≠ d·ª•ng voucher",
        ".voucher transfer <@tag> <m√£> - Chuy·ªÉn voucher cho ng∆∞·ªùi kh√°c",
        ".voucher hunt - SƒÉn t√¨m voucher m·ªõi",
        ".voucher stats - Xem th·ªëng k√™ sƒÉn voucher"
    ].join('\n'),
    cooldowns: 5,
    onPrefix: true,

    onLaunch: async function({ api, event, target = [] }) {
        const { threadID, messageID, senderID, mentions } = event;
        
        const action = target[0]?.toLowerCase();
        
        // Check for expiring vouchers and notify if needed
        const expiringVouchers = checkExpiringVouchers(senderID);
        if (expiringVouchers.length > 0 && !action) {
            setTimeout(() => {
                const warningMsg = `‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n c√≥ ${expiringVouchers.length} voucher s·∫Øp h·∫øt h·∫°n!\nH√£y d√πng '.voucher' ƒë·ªÉ ki·ªÉm tra.`;
                api.sendMessage(warningMsg, senderID);
            }, 1000);
        }

        switch (action) {
            case "all": {
                const userVouchers = getUserVouchers(senderID);
                const message = `üìã T·∫§T C·∫¢ VOUCHER C·ª¶A B·∫†N\n\n${renderVouchers(userVouchers, true)}`;
                return api.sendMessage(message, threadID, messageID);
            }
            
            case "use": {
                const voucherCode = target[1];
                if (!voucherCode) {
                    return api.sendMessage("‚ùå Vui l√≤ng nh·∫≠p m√£ voucher c·∫ßn s·ª≠ d·ª•ng", threadID, messageID);
                }
                
                const result = useVoucher(senderID, voucherCode);
                if (!result.success) {
                    return api.sendMessage(`‚ùå ${result.message}`, threadID, messageID);
                }
                
                const icon = getVoucherIcon(result.voucher.type);
                return api.sendMessage(
                    `‚úÖ S·ª¨ D·ª§NG VOUCHER TH√ÄNH C√îNG\n\n` +
                    `${icon} Voucher ${result.voucher.type}\n` +
                    `üí∞ Gi·∫£m gi√°: ${result.voucher.discount}%\n` +
                    `üîñ M√£: ${result.voucher.code}\n\n` +
                    `Voucher ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng!`,
                    threadID, messageID
                );
            }
            
            case "transfer": {
                const mentionedIds = Object.keys(mentions);
                const targetUserId = mentionedIds.length > 0 ? mentionedIds[0] : target[1];
                const voucherCode = mentionedIds.length > 0 ? target[target.length - 1] : target[2];
                
                if (!targetUserId || !voucherCode) {
                    return api.sendMessage(
                        "‚ùå Vui l√≤ng tag ng∆∞·ªùi nh·∫≠n v√† cung c·∫•p m√£ voucher\n" +
                        "V√≠ d·ª•: .voucher transfer @user SILVER_ABC123", 
                        threadID, messageID
                    );
                }
                
                const result = transferVoucher(senderID, targetUserId, voucherCode);
                if (!result.success) {
                    return api.sendMessage(`‚ùå ${result.message}`, threadID, messageID);
                }
                
                const icon = getVoucherIcon(result.voucher.type);
                return api.sendMessage(
                    `‚úÖ CHUY·ªÇN VOUCHER TH√ÄNH C√îNG\n\n` +
                    `üë§ Ng∆∞·ªùi nh·∫≠n: ${targetUserId}\n` +
                    `${icon} Voucher ${result.voucher.type}\n` +
                    `üí∞ Gi·∫£m gi√°: ${result.voucher.discount}%\n` +
                    `üîñ M√£: ${result.voucher.code}`,
                    threadID, messageID
                );
            }
            
            case "hunt": {
                // Hunt for voucher
                const result = huntVoucher(senderID);
                
                if (!result.canHunt) {
                    return api.sendMessage(result.message, threadID, messageID);
                }
                
                if (!result.success) {
                    return api.sendMessage(
                        `${result.message}\n\n` +
                        "üîÑ H√£y th·ª≠ l·∫°i sau 1 ph√∫t n·ªØa.\n" +
                        "üí° G√µ '.voucher stats' ƒë·ªÉ xem th·ªëng k√™ sƒÉn voucher c·ªßa b·∫°n.",
                        threadID, messageID
                    );
                }
                
                const voucher = result.voucher;
                const voucherConfig = VOUCHER_TYPES[voucher.type];
                const expiresDate = new Date(voucher.expires).toLocaleDateString('vi-VN');
                
                return api.sendMessage(
                    `${result.message}\n\n` +
                    `${voucherConfig.emoji} M√£ voucher: ${voucher.code}\n` +
                    `üí∞ Gi·∫£m gi√°: ${voucher.discount}%\n` +
                    `‚è≥ H·∫øt h·∫°n: ${expiresDate}\n\n` +
                    "üìå C√°ch s·ª≠ d·ª•ng voucher:\n" +
                    "1. G√µ '.voucher' ƒë·ªÉ xem danh s√°ch voucher\n" +
                    "2. Khi mua VIP, voucher s·∫Ω t·ª± ƒë·ªông √°p d·ª•ng",
                    threadID, messageID
                );
            }
            
            case "stats": {
                // Show hunting statistics
                const stats = getHuntStats(senderID);
                
                return api.sendMessage(
                    "üìä TH·ªêNG K√ä SƒÇN VOUCHER\n\n" +
                    `üîç S·ªë l·∫ßn sƒÉn t√¨m: ${stats.totalHunts}\n` +
                    `üé´ Voucher ƒë√£ t√¨m th·∫•y: ${stats.foundVouchers}\n` +
                    `‚≠ê T·ªâ l·ªá th√†nh c√¥ng: ${stats.successRate}\n\n` +
                    "üí° H√£y s·ª≠ d·ª•ng '.voucher hunt' ƒë·ªÉ ti·∫øp t·ª•c sƒÉn voucher.",
                    threadID, messageID
                );
            }
            
            default: {
                const userVouchers = getUserVouchers(senderID);
                const activeVouchers = userVouchers.filter(v => !v.used && v.expires > Date.now());
                
                let message = `üìã VOUCHER C·ª¶A B·∫†N (${activeVouchers.length})\n\n`;
                message += renderVouchers(userVouchers);
                message += "\nüìå H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG:\n";
                message += "- Xem t·∫•t c·∫£ voucher: .voucher all\n";
                message += "- S·ª≠ d·ª•ng voucher: .voucher use <m√£>\n";
                message += "- Chuy·ªÉn voucher: .voucher transfer @tag <m√£>\n";
                message += "- SƒÉn voucher m·ªõi: .voucher hunt\n";
                message += "- Xem th·ªëng k√™ sƒÉn: .voucher stats";
                
                return api.sendMessage(message, threadID, messageID);
            }
        }
    }
};
