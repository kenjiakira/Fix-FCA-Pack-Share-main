const fs = require('fs');
const path = require('path');
const { getBalance, updateBalance, updateQuestProgress } = require('../utils/currencies');
const fishingItems = require('../config/fishing/items');
const fishTypes = require('../config/fishing/fish');
const locations = require('../config/fishing/locations');
const { 
    treasures, 
    specialEvents, 
    expMultipliers, 
    levelRewards, 
    defaultCollection,
    expRequirements,
    streakBonuses 
} = require('../config/fishing/constants');
const { getVIPBenefits } = require('../utils/vipCheck');

const levelRequirements = {
    pond: 1,       
    river: 3,      
    ocean: 5,     
    deepSea: 10,
    abyss: 20,      
    atlantis: 50, 
    spaceOcean: 100, 
    dragonRealm: 200 
};

function formatNumber(number) {
    if (number === undefined || number === null) return "0";
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


const messages = {
    cooldown: (waitTime, lastTime) => 
        `‚è≥ B·∫°n c·∫ßn ƒë·ª£i ${waitTime} gi√¢y n·ªØa m·ªõi c√≥ th·ªÉ c√¢u ti·∫øp!\n` +
        `‚åö Th·ªùi gian c√¢u l·∫ßn cu·ªëi: ${lastTime}`,
    levelUp: level => `üéâ Ch√∫c m·ª´ng ƒë·∫°t c·∫•p ${level}!`,
    rodBroken: rod => `‚ö†Ô∏è C·∫ßn c√¢u c≈© ƒë√£ h·ªèng! T·ª± ƒë·ªông chuy·ªÉn sang ${rod}!`,
    insufficientFunds: (cost, location) => 
        `‚ùå B·∫°n c·∫ßn ${formatNumber(cost)} xu ƒë·ªÉ c√¢u ·ªü ${location}!`
};

function calculateRequiredExp(level) {
    const { baseExp, multiplierPerLevel } = require('../config/fishing/constants').expRequirements;
    return Math.floor(baseExp * Math.pow(multiplierPerLevel, level - 1));
}

module.exports = {
    name: "fish",
    dev: "HNT",
    info: "C√¢u c√° ki·∫øm xu",
    usages: "fish",
    usedby: 0,
    cooldowns: 0, 
    onPrefix: true,

    lastFished: {},

    onLaunch: async function({ api, event }) {
        const { threadID, messageID, senderID } = event;
        const playerData = this.loadPlayerData(senderID);
        const allData = this.loadAllPlayers();
        
        const now = Date.now();
        const vipBenefits = getVIPBenefits(senderID);
        const COOLDOWN = vipBenefits?.fishingCooldown || 360000;
        
        let cooldownMsg = "";
        if (allData[senderID]?.lastFished && now - allData[senderID].lastFished < COOLDOWN) {
            const waitTime = Math.ceil((COOLDOWN - (now - allData[senderID].lastFished)) / 1000);
            cooldownMsg = `‚è≥ Ch·ªù ${waitTime} gi√¢y n·ªØa m·ªõi c√≥ th·ªÉ c√¢u ti·∫øp!\n`;
        }
        
        const menu = "üé£ MENU C√ÇU C√Å üé£\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
            `${cooldownMsg}` +
            "1. C√¢u c√°\n" +
            "2. C·ª≠a h√†ng\n" +
            "3. T√∫i ƒë·ªì\n" +
            "4. B·ªô s∆∞u t·∫≠p\n" +
            "5. X·∫øp h·∫°ng\n" +
            "6. H∆∞·ªõng d·∫´n\n\n" +
            "Reply tin nh·∫Øn v·ªõi s·ªë ƒë·ªÉ ch·ªçn!";

        const msg = await api.sendMessage(menu, threadID, messageID);
        
        global.client.onReply.push({
            name: this.name,
            messageID: msg.messageID,
            author: senderID,
            type: "menu",
            playerData
        });
    },

    loadPlayerData: function(userID) {
        const dataPath = path.join(__dirname, '../database/json/fishing.json');
        let data = {};
        
        try {
            if (fs.existsSync(dataPath)) {
                data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
            }
        } catch (err) {
            console.error("Error loading fishing data:", err);
        }

        if (!fishingItems || typeof fishingItems !== 'object') {
            console.error("Invalid fishingItems configuration");
            return null;
        }

        if (!fishingItems["C·∫ßn tr√∫c"]) {
            fishingItems["C·∫ßn tr√∫c"] = {
                durability: 10,
                price: 0,
                multiplier: 1
            };
        }

        const defaultRod = {
            name: "C·∫ßn tr√∫c",
            durability: fishingItems["C·∫ßn tr√∫c"].durability,
            inventory: ["C·∫ßn tr√∫c"]
        };

    
        if (!data[userID] || !data[userID].rod) {
            data[userID] = {
                rod: defaultRod.name,
                rodDurability: defaultRod.durability,
                inventory: defaultRod.inventory,
                collection: defaultCollection,
                exp: 0,
                level: 1,
                fishingStreak: 0,
                stats: {
                    totalExp: 0,
                    highestStreak: 0,
                    totalFishes: 0
                },
                activeBuffs: {},
                lastFished: 0,
                userID: userID
            };
        }

        if (!fishingItems[data[userID].rod]) {
            data[userID].rod = defaultRod.name;
            data[userID].rodDurability = defaultRod.durability;
        }

        const currentRod = fishingItems[data[userID].rod];
        if (!currentRod || typeof data[userID].rodDurability !== 'number' || 
            data[userID].rodDurability < 0 || 
            data[userID].rodDurability > currentRod.durability) {
            data[userID].rod = defaultRod.name;
            data[userID].rodDurability = defaultRod.durability;
        }

        if (!Array.isArray(data[userID].inventory)) {
            data[userID].inventory = ["C·∫ßn tr√∫c"];
        }

        data[userID].inventory = data[userID].inventory.filter(item => 
            fishingItems[item] !== undefined
        );

        if (!data[userID].inventory.includes("C·∫ßn tr√∫c")) {
            data[userID].inventory.push("C·∫ßn tr√∫c");
        }

        return data[userID];
    },

    savePlayerData: function(data) {
        const dataPath = path.join(__dirname, '../database/json/fishing.json');
        try {
         
            let existingData = {};
            if (fs.existsSync(dataPath)) {
                existingData = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
            }
            
            if (data.rod && data.inventory) { 
                existingData[data.userID] = data;
            } else {
                Object.entries(data).forEach(([userID, userData]) => {
                    existingData[userID] = userData;
                });
            }
            
            fs.writeFileSync(dataPath, JSON.stringify(existingData, null, 2));
        } catch (err) {
            console.error("Error saving fishing data:", err);
        }
    },

    onReply: async function({ api, event }) {
        const { threadID, messageID, senderID, body } = event;
        const reply = global.client.onReply.find(r => r.messageID === event.messageReply.messageID && r.author === senderID);
        if (!reply) return;

        if (reply.type !== "menu") {
            global.client.onReply = global.client.onReply.filter(r => r.messageID !== reply.messageID);
        }
        
        const allData = this.loadAllPlayers();
        const playerData = this.loadPlayerData(senderID);

        if (reply.type === "location") {
            if (allData[senderID]?.lastFished && Date.now() - allData[senderID].lastFished < 180000) {
                const waitTime = Math.ceil((180000 - (Date.now() - allData[senderID].lastFished)) / 1000);
                return api.sendMessage(
                    messages.cooldown(waitTime, new Date(allData[senderID].lastFished).toLocaleTimeString()),
                    threadID
                );
            }
        }

        switch (reply.type) {
            case "menu":
                const choice = parseInt(body);
                if (isNaN(choice) || choice < 1 || choice > 6) {
                    return api.sendMessage("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!", threadID);
                }

                switch(choice) {
                    case 1:
                        const now = Date.now();
                        const vipBenefits = getVIPBenefits(event.senderID);
                        const COOLDOWN = vipBenefits?.fishingCooldown || 360000;
                        
                        if (allData[event.senderID]?.lastFished && now - allData[event.senderID].lastFished < COOLDOWN) {
                            const waitTime = Math.ceil((COOLDOWN - (now - allData[event.senderID].lastFished)) / 1000);
                            return api.sendMessage(
                                messages.cooldown(waitTime, new Date(allData[event.senderID].lastFished).toLocaleTimeString()),
                                threadID
                            );
                        }

                const locationMenu = "üó∫Ô∏è CH·ªåN ƒê·ªäA ƒêI·ªÇM C√ÇU C√Å:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                            Object.entries(locations).map(([key, loc], index) => 
                                `${index + 1}. ${loc.name} [C·∫•p ${levelRequirements[key]}+]\n` +
                                `üí∞ Ph√≠: ${formatNumber(loc.cost)} Xu\n` +
                                `${playerData.level >= levelRequirements[key] ? '‚úÖ' : '‚ùå'} Y√™u c·∫ßu: C·∫•p ${levelRequirements[key]}\n`
                            ).join("\n");
                        
                        const locMsg = await api.sendMessage(
                            `üìä C·∫•p ƒë·ªô c·ªßa b·∫°n: ${playerData.level}\n` +
                            `üíµ S·ªë d∆∞: ${formatNumber(getBalance(event.senderID))} Xu\n\n` +
                            locationMenu,
                            threadID
                        );

                        setTimeout(() => {
                            api.unsendMessage(locMsg.messageID);
                        }, 20000); // T·ª± ƒë·ªông g·ª° sau 20 gi√¢y

                        global.client.onReply.push({
                            name: this.name,
                            messageID: locMsg.messageID,
                            author: event.senderID,
                            type: "location",
                            playerData
                        });
                        break;

                    case 2: 
                        const shopMenu = "üè™ C·ª¨A H√ÄNG C·∫¶N C√ÇU üé£\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                            Object.entries(fishingItems).map(([name, item], index) =>
                                `${index + 1}. ${name}\nüí∞ Gi√°: ${formatNumber(item.price)} Xu\n‚ö° ƒê·ªô b·ªÅn: ${item.durability}\n‚Üë T·ªâ l·ªá: x${item.multiplier}\n`
                            ).join("\n") +
                            "\nüíµ S·ªë d∆∞: " + formatNumber(getBalance(senderID)) + " Xu" +
                            "\n\nReply s·ªë ƒë·ªÉ mua c·∫ßn c√¢u!";
                        
                        const shopMsg = await api.sendMessage(shopMenu, threadID);
                        global.client.onReply.push({
                            name: this.name,
                            messageID: shopMsg.messageID,
                            author: senderID,
                            type: "shop",
                            playerData
                        });
                        break;

                    case 3: 
                        const inventory = `üéí T√öI ƒê·ªí C·ª¶A B·∫†N:\n` +
                            `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                            `üé£ C·∫ßn c√¢u: ${playerData.rod}\n` +
                            `‚ö° ƒê·ªô b·ªÅn: ${playerData.rodDurability}/${fishingItems[playerData.rod].durability}\n` +
                            `üìä C·∫•p ƒë·ªô: ${playerData.level}\n` +
                            `‚ú® EXP: ${playerData.exp}/${playerData.level * 1000}\n` +
                            `üèÜ Th√†nh t√≠ch:\n` +
                            Object.entries(fishTypes).map(([rarity, fishes]) => {
                                const rarityFishes = playerData.collection?.byRarity[rarity] || {};
                                const caughtFishes = Object.entries(rarityFishes)
                                    .filter(([_, count]) => count > 0)
                                    .map(([fish, count]) => `‚Ä¢ ${fish}: ${count} l·∫ßn`);
                                return caughtFishes.length ? `„Äê${rarity.toUpperCase()}„Äë\n${caughtFishes.join('\n')}` : '';
                            }).filter(Boolean).join('\n');
                        
                        api.sendMessage(inventory, threadID);
                        break;

                    case 4: 
                        const collection = "üìö B·ªò S∆ØU T·∫¨P C√Å:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            Object.entries(fishTypes).map(([rarity, fishes]) => {
                                const fishList = fishes.map(f => {
                                    const caught = playerData.collection?.byRarity[rarity]?.[f.name] || 0;
                                    return `${caught > 0 ? '‚úÖ' : '‚ùå'} ${f.name} (${formatNumber(f.value)} Xu) - ƒê√£ b·∫Øt: ${caught}`;
                                }).join('\n');
                                return `„Äê${rarity.toUpperCase()}„Äë\n${fishList}\n`;
                            }).join('\n') +
                            `\nüìä Th·ªëng k√™:\n` +
                            `T·ªïng s·ªë c√° ƒë√£ b·∫Øt: ${playerData.collection?.stats.totalCaught || 0}\n` +
                            `T·ªïng gi√° tr·ªã: ${formatNumber(playerData.collection?.stats.totalValue || 0)} Xu\n` +
                            `B·∫Øt qu√Ω gi√° nh·∫•t: ${playerData.collection?.stats.bestCatch?.name || 'Ch∆∞a c√≥'} (${formatNumber(playerData.collection?.stats.bestCatch?.value || 0)} Xu)`;
                        
                        api.sendMessage(collection, threadID);
                        break;

                    case 5: 
                        const allPlayers = this.loadAllPlayers();
                        const rankings = this.getRankingStats(allPlayers);
                        const top10 = rankings.slice(0, 10);
                        
                        const userRank = rankings.findIndex(player => player.id === senderID) + 1;
                        const userStats = rankings.find(player => player.id === senderID);

                        const rankMsg = "üèÜ B·∫¢NG X·∫æP H·∫†NG C√ÇU C√Å üèÜ\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            top10.map((player, index) => 
                                `${index + 1}. H·∫°ng ${index + 1}\n` +
                                `üë§ ID: ${player.id}\n` +
                                `üìä Level: ${player.level}\n` +
                                `üé£ T·ªïng c√°: ${formatNumber(player.totalCaught)}\n` +
                                `üí∞ T·ªïng gi√° tr·ªã: ${formatNumber(player.totalValue)} Xu\n` +
                                `üèÜ C√° qu√Ω nh·∫•t: ${player.bestCatch.name} (${formatNumber(player.bestCatch.value)} Xu)\n` +
                                `üî• Chu·ªói hi·ªán t·∫°i: ${player.streak}\n` +
                                `‚≠ê Chu·ªói cao nh·∫•t: ${player.highestStreak}\n`
                            ).join("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n") +
                            "\nüëâ Th·ª© h·∫°ng c·ªßa b·∫°n:\n" +
                            (userStats ? 
                                `H·∫°ng ${userRank}\n` +
                                `üìä Level: ${userStats.level}\n` +
                                `üé£ T·ªïng c√°: ${formatNumber(userStats.totalCaught)}\n` +
                                `üí∞ T·ªïng gi√° tr·ªã: ${formatNumber(userStats.totalValue)} Xu\n` +
                                `üî• Chu·ªói hi·ªán t·∫°i: ${userStats.streak}`
                                : "Ch∆∞a c√≥ d·ªØ li·ªáu");
                        
                        api.sendMessage(rankMsg, threadID);
                        break;

                    case 6:
                        api.sendMessage(
                            "üìñ H∆Ø·ªöNG D·∫™N C√ÇU C√Å üé£\n" +
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                            "1. Ch·ªçn ƒë·ªãa ƒëi·ªÉm c√¢u c√° ph√π h·ª£p v·ªõi t√∫i ti·ªÅn\n" +
                            "2. Mua c·∫ßn c√¢u t·ªët ƒë·ªÉ tƒÉng t·ªâ l·ªá b·∫Øt c√° hi·∫øm\n" +
                            "3. C·∫ßn c√¢u s·∫Ω m·∫•t ƒë·ªô b·ªÅn sau m·ªói l·∫ßn s·ª≠ d·ª•ng\n" +
                            "4. C√°c lo·∫°i c√° theo th·ª© t·ª± ƒë·ªô hi·∫øm:\n" +
                            "   R√°c < Ph·ªï th√¥ng < Hi·∫øm < Qu√Ω hi·∫øm < Huy·ªÅn tho·∫°i < Th·∫ßn tho·∫°i\n" +
                            "5. C√≥ c∆° h·ªôi nh·∫≠n ƒë∆∞·ª£c kho b√°u khi c√¢u c√°\n" +
                            "6. T√≠ch l≈©y EXP ƒë·ªÉ l√™n c·∫•p v√† m·ªü kh√≥a th√™m t√≠nh nƒÉng",
                            threadID
                        );
                        break;
                }
                break;

            case "shop":
                const shopChoice = parseInt(body) - 1;
                const items = Object.entries(fishingItems);
                if (shopChoice >= 0 && shopChoice < items.length) {
                    const [rodName, rodInfo] = items[shopChoice];
                    await this.handleShopPurchase(api, event, rodName, rodInfo, playerData);
                }
                break;

            case "location":
                const locationIndex = parseInt(body) - 1;
                const locationKeys = Object.keys(locations);
                if (locationIndex >= 0 && locationIndex < locationKeys.length) {
                    
                    await this.handleFishing(api, event, locations[locationKeys[locationIndex]], playerData);
                }
                break;
        }

        if (reply.type === "menu") {
            global.client.onReply.push({
                name: this.name,
                messageID: messageID,
                author: senderID,
                type: "menu",
                playerData
            });
        }
    },

    handleFishing: async function(api, event, location, playerData) {
    
        if (!fishingItems || !playerData) {
            await api.sendMessage("‚ùå L·ªói c·∫•u h√¨nh ho·∫∑c d·ªØ li·ªáu ng∆∞·ªùi ch∆°i!", event.threadID);
            return;
        }

        if (!fishingItems[playerData.rod]) {
            playerData.rod = "C·∫ßn tr√∫c";
            playerData.rodDurability = fishingItems["C·∫ßn tr√∫c"].durability;
            this.savePlayerData(playerData);
            await api.sendMessage("‚ö†Ô∏è ƒê√£ ph√°t hi·ªán l·ªói c·∫ßn c√¢u, ƒë√£ reset v·ªÅ c·∫ßn m·∫∑c ƒë·ªãnh!", event.threadID);
        }

        const allData = this.loadAllPlayers();
        const now = Date.now();

        if (!allData[event.senderID]) {
            allData[event.senderID] = playerData;
        }

        const vipBenefits = getVIPBenefits(event.senderID);
        const COOLDOWN = vipBenefits?.fishingCooldown || 360000; 
        const vipIcon = vipBenefits ? 
            (vipBenefits.packageId === 3 ? '‚≠ê‚≠ê‚≠ê' : 
             vipBenefits.packageId === 2 ? '‚≠ê‚≠ê' : '‚≠ê') : '';

        const cooldownMinutes = Math.ceil(COOLDOWN / 60000);

        if (allData[event.senderID].lastFished && now - allData[event.senderID].lastFished < COOLDOWN) {
            const waitTime = Math.ceil((COOLDOWN - (now - allData[event.senderID].lastFished)) / 1000);
            return api.sendMessage(
                messages.cooldown(waitTime, new Date(allData[event.senderID].lastFished).toLocaleTimeString()),
                event.threadID
            );
        }

        const levelRequirements = {
            pond: 1,
            river: 3,
            ocean: 5,
            deepSea: 10,
            abyss: 20,
            atlantis: 50,
            spaceOcean: 100,
            dragonRealm: 200
        };

        const locationKey = Object.keys(locations).find(key => locations[key] === location);
        if (levelRequirements[locationKey] > playerData.level) {
                const locationMenu = "üó∫Ô∏è CH·ªåN ƒê·ªäA ƒêI·ªÇM C√ÇU C√Å:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" +
                Object.entries(locations).map(([key, loc], index) => 
                    `${index + 1}. ${loc.name}\nüí∞ Ph√≠: ${formatNumber(loc.cost)} Xu\n`
                ).join("\n");
            
            const errorMsg = await api.sendMessage(
                `‚ùå B·∫°n c·∫ßn ƒë·∫°t c·∫•p ${levelRequirements[locationKey]} ƒë·ªÉ c√¢u ·ªü ${location.name}!\n` +
                `üìä C·∫•p ƒë·ªô hi·ªán t·∫°i: ${playerData.level}\n\n` +
                locationMenu,
                event.threadID
            );

            setTimeout(() => {
                api.unsendMessage(errorMsg.messageID);
            }, 20000); // T·ª± ƒë·ªông g·ª° sau 20 gi√¢y

            global.client.onReply.push({
                name: this.name,
                messageID: errorMsg.messageID,
                author: event.senderID,
                type: "location",
                playerData
            });
            
            return;
        }

        const availableRods = Object.keys(fishingItems).filter(rod => {
            return playerData.inventory.includes(rod) && 
                   fishingItems[rod] && 
                   fishingItems[rod].durability > 0;
        });

        if (availableRods.length === 0) {
  
            playerData.rod = "C·∫ßn tr√∫c";
            playerData.rodDurability = fishingItems["C·∫ßn tr√∫c"].durability;
            playerData.inventory = ["C·∫ßn tr√∫c"];
            this.savePlayerData(playerData);
            return api.sendMessage("‚ö†Ô∏è ƒê√£ reset v·ªÅ c·∫ßn c√¢u m·∫∑c ƒë·ªãnh do kh√¥ng c√≥ c·∫ßn c√¢u kh·∫£ d·ª•ng!", event.threadID);
        }

        if (!fishingItems[playerData.rod] || playerData.rodDurability <= 0) {
            const bestRod = availableRods[0];
            playerData.rod = bestRod;
            playerData.rodDurability = fishingItems[bestRod].durability;
            await api.sendMessage(`üé£ T·ª± ƒë·ªông chuy·ªÉn sang ${bestRod} do c·∫ßn hi·ªán t·∫°i kh√¥ng kh·∫£ d·ª•ng!`, event.threadID);
        }

        const balance = getBalance(event.senderID);
        if (balance < location.cost) {
            return api.sendMessage(messages.insufficientFunds(location.cost, location.name), event.threadID);
        }

        updateBalance(event.senderID, -location.cost);
        const fishingMsg = await api.sendMessage("üé£ ƒêang c√¢u...", event.threadID);

        setTimeout(async () => {
            try {
                const result = this.calculateCatch(location, fishingItems[playerData.rod].multiplier, playerData);
                
                playerData.lastFished = now;
                playerData.rodDurability--;

                const rarity = this.getFishRarity(result.name);

                if (!playerData.collection) {
                    playerData.collection = JSON.parse(JSON.stringify(defaultCollection));
                }

                if (!playerData.collection.byRarity[rarity][result.name]) {
                    playerData.collection.byRarity[rarity][result.name] = 0;
                }

                playerData.collection.byRarity[rarity][result.name]++;
                playerData.collection.stats.totalCaught++;
                playerData.collection.stats.totalValue += result.value;

                if (result.value > (playerData.collection.stats.bestCatch?.value || 0)) {
                    playerData.collection.stats.bestCatch = {
                        name: result.name,
                        value: result.value
                    };
                }

                let baseExp = result.exp * (expMultipliers[rarity] || 1);
                let streakBonus = 0;
                
                const streak = playerData.fishingStreak || 0;
                for (const [streakThreshold, bonus] of Object.entries(streakBonuses)) {
                    if (streak >= parseInt(streakThreshold)) {
                        streakBonus = bonus;
                    }
                }

                baseExp = Math.floor(baseExp * (1 + streakBonus));

                if (treasures.some(t => t.name === result.name)) {
                    baseExp *= 2;
                }

                playerData.exp = (playerData.exp || 0) + baseExp;
                const oldLevel = playerData.level;
                
                while (playerData.exp >= calculateRequiredExp(playerData.level)) {
                    playerData.exp -= calculateRequiredExp(playerData.level);
                    if (playerData.level < expRequirements.maxLevel) {
                        playerData.level++;
                        await api.sendMessage(messages.levelUp(playerData.level), event.threadID);
                        
                        if (levelRewards[playerData.level]) {
                            const reward = levelRewards[playerData.level];
                            updateBalance(event.senderID, reward.reward);
                            await api.sendMessage(reward.message, event.threadID);
                        }
                    }
                }

                if (now - (playerData.lastFished || 0) < 520000) {
                    playerData.fishingStreak = (playerData.fishingStreak || 0) + 1;
                } else {
                    playerData.fishingStreak = 1;
                }

                playerData.stats.totalExp = (playerData.stats.totalExp || 0) + baseExp;
                playerData.stats.highestStreak = Math.max(playerData.stats.highestStreak || 0, playerData.fishingStreak);
                playerData.stats.totalFishes = (playerData.stats.totalFishes || 0) + 1;

                this.savePlayerData({
                    ...playerData,
                    userID: event.senderID
                });

                updateBalance(event.senderID, result.value);

                const vipBonus = vipBenefits ? 
                    `‚ú® Th∆∞·ªüng EXP VIP x${vipBenefits.fishExpMultiplier || 1}\n` +
                    `üëë Th∆∞·ªüng xu VIP +${(vipBenefits.packageId * 5) || 0}%\n` : '';

                api.unsendMessage(fishingMsg.messageID);
                await api.sendMessage(
                    `üé£ B·∫°n ƒë√£ c√¢u ƒë∆∞·ª£c ${result.name}!\n` +
                    `üí∞ Gi√° g·ªëc: ${formatNumber(result.originalValue)} Xu\n` +
                    `üìã Thu·∫ø: ${formatNumber(result.taxAmount)} Xu (${(result.taxRate * 100).toFixed(1)}%)\n` +
                    `üíµ Th·ª±c nh·∫≠n: ${formatNumber(result.value)} Xu\n` +
                    `${vipBonus}` + 
                    `üìä EXP: +${formatNumber(baseExp)} (${this.getExpBreakdown(baseExp, streakBonus, rarity)})\n` +
                    `üìà Chu·ªói c√¢u: ${playerData.fishingStreak} l·∫ßn (${Math.floor(streakBonus * 100)}% bonus)\n` +
                    `üéöÔ∏è Level: ${oldLevel}${playerData.level > oldLevel ? ` ‚ûú ${playerData.level}` : ''}\n` +
                    `‚ú® EXP: ${formatNumber(playerData.exp)}/${formatNumber(calculateRequiredExp(playerData.level))}\n` +
                    `üéí ƒê·ªô b·ªÅn c·∫ßn: ${playerData.rodDurability}/${fishingItems[playerData.rod].durability}\n` +
                    `üíµ S·ªë d∆∞: ${formatNumber(getBalance(event.senderID))} Xu\n` +
                    `‚è≥ Ch·ªù ${cooldownMinutes} ph√∫t ƒë·ªÉ c√¢u ti·∫øp!`,
                    event.threadID
                );

            } catch (err) {
                console.error("Error in fishing:", err);
                api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi c√¢u c√°!", event.threadID);
            }
        }, 5000);
    },

    calculateCatch: function(location, multiplier, playerData) {
        try {
            const vipBenefits = getVIPBenefits(playerData.userID);
      
            const expMultiplier = vipBenefits.fishExpMultiplier > 1 ? 
                vipBenefits.fishExpMultiplier : 1;

            const random = Math.random() * 100;
            const vipMultiplier = vipBenefits?.fishExpMultiplier || 1;
            
            const vipBonus = vipBenefits ? (vipBenefits.packageId * 0.02) : 0;

            let chances = {
                trash: location.fish.trash || 0,
                common: location.fish.common || 0,
                uncommon: location.fish.uncommon || 0,
                rare: location.fish.rare || 0,
                legendary: location.fish.legendary || 0,
                mythical: location.fish.mythical || 0
            };
                
            if (vipBenefits) {
              
                chances.trash = Math.max(0, chances.trash * (1 - vipBenefits.trashReduction));
                
                const rareBonus = 0.1 + (vipBenefits.packageId * 0.15); 
                chances.rare *= (1 + rareBonus);
                chances.legendary *= (1 + rareBonus);
                chances.mythical *= (1 + rareBonus);

                chances.common *= (1 - rareBonus * 0.3);
                chances.uncommon *= (1 - rareBonus * 0.2);
            }

            const total = Object.values(chances).reduce((a, b) => a + b, 0);
            for (let type in chances) {
                chances[type] = (chances[type] / total) * 100;
            }

            let currentProb = 0;
            let type = 'common'; 
            for (const [fishType, chance] of Object.entries(chances)) {
                currentProb += chance;
                if (random <= currentProb) {
                    type = fishType;
                    break;
                }
            }

            const treasureChance = 0.05 + (vipBenefits ? 0.02 * vipBenefits.packageId : 0);
            if (Math.random() < treasureChance) {
                const treasure = treasures[Math.floor(Math.random() * treasures.length)];
                const originalValue = Math.floor(treasure.value * multiplier);
                const taxRate = this.calculateTaxRate('legendary', originalValue);
                const taxAmount = Math.floor(originalValue * taxRate);
                const finalValue = Math.floor(originalValue * (1 + (vipBonus || 0)) - taxAmount);
                const exp = Math.floor(50 * (vipBenefits?.fishExpMultiplier || 1));
                return {
                    name: treasure.name,
                    value: finalValue,
                    exp: exp,
                    taxRate: taxRate,
                    taxAmount: taxAmount,
                    originalValue: originalValue
                };
            }

            const fishArray = Array.isArray(fishTypes[type]) ? fishTypes[type] : [];
            if (!fishArray.length) {
                return {
                    name: "C√° Th∆∞·ªùng",
                    value: 1000,
                    exp: 5
                };
            }

            const fish = fishArray[Math.floor(Math.random() * fishArray.length)];
            const baseExp = type === 'trash' ? 1 :
                type === 'common' ? 5 :
                type === 'uncommon' ? 10 :
                type === 'rare' ? 20 :
                type === 'legendary' ? 50 : 100;

            const baseValue = fish.value * multiplier * (1 + vipBonus);
            const taxRate = this.calculateTaxRate(type, baseValue);
            const taxAmount = Math.floor(baseValue * taxRate);
            const finalValue = Math.floor(baseValue - taxAmount);

            return {
                name: fish.name,
                value: finalValue || 1000,
                exp: Math.floor(baseExp * (vipBenefits?.fishExpMultiplier || 1)) || 5,
                taxRate: taxRate,
                taxAmount: taxAmount,
                originalValue: baseValue
            };

        } catch (error) {
            console.error("Error in calculateCatch:", error);
            return {
                name: "C√° Th∆∞·ªùng",
                value: 1000,
                exp: 5,
                taxRate: 0,
                taxAmount: 0,
                originalValue: 1000
            };
        }
    },

    calculateTaxRate: function(type, value) {
    
        const baseTaxRates = {
            trash: 0,
            common: 0.02,  
            uncommon: 0.04, 
            rare: 0.6,    
            legendary: 0.8,
            mythical: 0.12   
        };

        let progressiveTax = 0;
        if (value > 1000000) progressiveTax = 0.02;   
        if (value > 5000000) progressiveTax = 0.5;     
        if (value > 10000000) progressiveTax = 0.8;   

        return Math.min(0.05, (baseTaxRates[type] || 0.01) + progressiveTax);
    },

    getFishRarity: function(fishName) {
        for (const [rarity, fishes] of Object.entries(fishTypes)) {
            if (fishes.some(fish => fish.name === fishName)) return rarity;
        }
        return 'common';
    },

    getExpBreakdown: function(totalExp, streakBonus, rarity) {
        try {
            if (!totalExp || !expMultipliers[rarity]) {
                return `C∆° b·∫£n: ${formatNumber(totalExp || 0)}`;
            }

            const multiplier = expMultipliers[rarity] || 1;
            const streak = streakBonus || 0;
            const base = Math.floor(totalExp / ((1 + streak) * multiplier));

            return `C∆° b·∫£n: ${formatNumber(base)} √ó ${multiplier} (${rarity}) √ó ${(1 + streak).toFixed(1)} (chu·ªói)`;
        } catch (error) {
            console.error("Error in getExpBreakdown:", error);
            return `C∆° b·∫£n: ${formatNumber(totalExp || 0)}`;
        }
    },

    loadAllPlayers: function() {
        const dataPath = path.join(__dirname, '../database/json/fishing.json');
        try {
            if (fs.existsSync(dataPath)) {
                return JSON.parse(fs.readFileSync(dataPath, 'utf8'));
            }
        } catch (err) {
            console.error("Error loading all players:", err);
        }
        return {};
    },

    addToInventory: function(playerData, itemName) {
        if (!playerData.inventory) playerData.inventory = [];
        if (!playerData.inventory.includes(itemName)) {
            playerData.inventory.push(itemName);
        }
    },

    handleShopPurchase: async function(api, event, rodName, rodInfo, playerData) {
        const { senderID, threadID } = event;
        const balance = getBalance(senderID);
        
        if (balance < rodInfo.price) {
            return api.sendMessage(`‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn mua ${rodName}!`, threadID);
        }

        try {
            updateBalance(senderID, -rodInfo.price);
            
            const userData = {
                ...playerData,
                userID: senderID,
                rod: rodName,
                rodDurability: rodInfo.durability
            };
            
            if (!userData.inventory.includes(rodName)) {                userData.inventory.push(rodName);
            }

            this.savePlayerData(userData);

            return api.sendMessage(
                `‚úÖ ƒê√£ mua th√†nh c√¥ng ${rodName}!\n` +
                `üí∞ S·ªë d∆∞ c√≤n l·∫°i: ${formatNumber(getBalance(senderID))} Xu`,
                threadID
            );
        } catch (err) {
            console.error("Error in shop purchase:", err);
            return api.sendMessage("‚ùå ƒê√£ x·∫£y ra l·ªói khi mua c·∫ßn c√¢u!", threadID);
        }
    },

    validatePlayerStats: function(playerData) {

        if (!fishingItems || !fishingItems["C·∫ßn tr√∫c"]) {
            throw new Error("fishingItems configuration is missing or invalid");
        }

        playerData.exp = playerData.exp || 0;
        playerData.level = playerData.level || 1;
        playerData.rod = fishingItems[playerData.rod] ? playerData.rod : "C·∫ßn tr√∫c";
        playerData.inventory = Array.isArray(playerData.inventory) ? playerData.inventory : ["C·∫ßn tr√∫c"];

        playerData.inventory = playerData.inventory.filter(item => fishingItems[item]);
        if (!playerData.inventory.includes("C·∫ßn tr√∫c")) {
            playerData.inventory.push("C·∫ßn tr√∫c");
        }

        const maxDurability = fishingItems[playerData.rod]?.durability || fishingItems["C·∫ßn tr√∫c"].durability;
        if (typeof playerData.rodDurability !== 'number' || 
            playerData.rodDurability < 0 || 
            playerData.rodDurability > maxDurability) {
            playerData.rodDurability = maxDurability;
        }

        playerData.exp = Math.max(0, playerData.exp);
        playerData.level = Math.max(1, playerData.level);
        playerData.rodDurability = Math.max(0, playerData.rodDurability);

        return playerData;
    },

    getRankingStats: function(allPlayers) {
        return Object.entries(allPlayers)
            .map(([id, data]) => ({
                id,
                level: data.level || 1,
                exp: data.exp || 0,
                totalCaught: Object.values(data.collection?.byRarity || {})
                    .reduce((acc, curr) => acc + Object.values(curr).reduce((a, b) => a + b, 0), 0),
                totalValue: data.collection?.stats?.totalValue || 0,
                bestCatch: data.collection?.stats?.bestCatch || { name: "Ch∆∞a c√≥", value: 0 },
                streak: data.fishingStreak || 0,
                highestStreak: data.stats?.highestStreak || 0
            }))
            .sort((a, b) => b.level - a.level || b.exp - a.exp);
    },
};