const axios = require('axios');
const schedule = require('node-schedule');
const fs = require('fs');
const path = require('path');
const { getBalance, updateBalance } = require('../utils/currencies');

const HISTORY_FILE = path.join(__dirname, './json/currencies/quicklotto_history.json');
const SETTINGS_FILE = path.join(__dirname, './json/lotto_settings.json');
const TICKETS_FILE = path.join(__dirname, './json/lotto_tickets.json');

const SCHEDULE_INTERVAL = '*/10 * * * *';
const SPECIAL_PRIZE_RATIO = 95; 
const DE3_PRIZE_RATIO = 999; 
const LO_PRIZE_RATIO = 3.67;
const MIN_BET_LO = 27000;

let nextDrawTime = null;
let lastResults = [];
let ticketData = { tickets: {} };

function loadSettings() {
    try {
        const jsonDir = path.join(__dirname, './json');
        if (!fs.existsSync(jsonDir)) {
            fs.mkdirSync(jsonDir, { recursive: true });
        }
        
        if (fs.existsSync(SETTINGS_FILE)) {
            return JSON.parse(fs.readFileSync(SETTINGS_FILE));
        }
        const defaultSettings = { enabledThreads: [] };
        fs.writeFileSync(SETTINGS_FILE, JSON.stringify(defaultSettings, null, 2));
        return defaultSettings;
    } catch (err) {
        console.error('Error loading lotto settings:', err);
        return { enabledThreads: [] };
    }
}
function saveSettings(settings) {
    try {
        fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    } catch (err) {
        console.error('Error saving lotto settings:', err);
    }
}

function generateResults() {
    return {
        special: Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
        first: Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
        second: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ],
        third: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ],
        fourth: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ],
        fifth: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ],
        sixth: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ],
        seventh: [
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0'),
            Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        ]
    };
}

function saveHistory(results) {
    const drawData = {
        results: results,
        drawTime: Date.now(),
        nextDrawTime: nextDrawTime.getTime()
    };

    lastResults.unshift(drawData);
    if (lastResults.length > 10) lastResults.pop();

    try {
        fs.writeFileSync(HISTORY_FILE, JSON.stringify({
            history: lastResults,
            lastUpdate: Date.now(),
            nextScheduledDraw: nextDrawTime.getTime()
        }, null, 2));
    } catch (err) {
        console.error('Error saving lottery history:', err);
    }
}
function loadHistory() {
    try {
        const jsonDir = path.join(__dirname, './json');
        if (!fs.existsSync(jsonDir)) {
            fs.mkdirSync(jsonDir, { recursive: true });
        }
        
        if (fs.existsSync(HISTORY_FILE)) {
            const data = JSON.parse(fs.readFileSync(HISTORY_FILE));
            lastResults = data.history || [];

            if (data.nextScheduledDraw) {
                const savedNextDraw = new Date(data.nextScheduledDraw);
                if (savedNextDraw > new Date()) {
                    nextDrawTime = savedNextDraw;
                } else {
                    nextDrawTime = new Date();
                    nextDrawTime.setMinutes(Math.ceil(nextDrawTime.getMinutes() / 10) * 10, 0, 0);
                }
            }
        } else {
            lastResults = [];
            nextDrawTime = new Date();
            nextDrawTime.setMinutes(Math.ceil(nextDrawTime.getMinutes() / 10) * 10, 0, 0);
            
            saveHistory(generateResults());
            console.log("Created new lottery history file");
        }
    } catch (err) {
        console.error('Error loading lottery history:', err);
       
        lastResults = [];
        nextDrawTime = new Date();
        nextDrawTime.setMinutes(Math.ceil(nextDrawTime.getMinutes() / 10) * 10, 0, 0);
    }
}
function loadTickets() {
    try {
        if (fs.existsSync(TICKETS_FILE)) {
            return JSON.parse(fs.readFileSync(TICKETS_FILE));
        }
        return { tickets: {} };
    } catch (err) {
        console.error('Error loading lotto tickets:', err);
        return { tickets: {} };
    }
}

function saveTickets() {
    try {
        fs.writeFileSync(TICKETS_FILE, JSON.stringify(ticketData, null, 2));
    } catch (err) {
        console.error('Error saving lotto tickets:', err);
    }
}

function buyTicket(userId, threadId, number, amount, betType) {
    const drawId = nextDrawTime.getTime().toString();

    if (!ticketData.tickets[drawId]) {
        ticketData.tickets[drawId] = [];
    }

    ticketData.tickets[drawId].push({
        userId,
        threadId,
        number,
        amount,
        betType,
        purchaseTime: Date.now()
    });

    saveTickets();
}

function getUserTickets(userId, drawId) {
    if (!ticketData || !ticketData.tickets || !drawId || !ticketData.tickets[drawId]) {
        return [];
    }

    return ticketData.tickets[drawId].filter(ticket => ticket.userId === userId);
}

function getPotentialWinnings(betType, amount, number) {
    let message = "";

    switch (betType) {
        case 'de2':
            message += `üíµ Gi·∫£i ƒêB (${number}): ${(amount * SPECIAL_PRIZE_RATIO).toLocaleString('vi-VN')}$ (x${SPECIAL_PRIZE_RATIO})\n`;
            break;
        case 'de3':
            message += `üíµ Gi·∫£i ƒêB (${number}): ${(amount * DE3_PRIZE_RATIO).toLocaleString('vi-VN')}$ (x${DE3_PRIZE_RATIO})\n`;
            break;
        case 'de5':
            message += `üíµ Gi·∫£i ƒêB (${number}): ${(amount * 10000).toLocaleString('vi-VN')}$ (x10000)\n`;
            break;
        case 'lo':
            message += `üíµ L√¥ (${number}): ${(amount * LO_PRIZE_RATIO).toLocaleString('vi-VN')}$ (x${LO_PRIZE_RATIO})\n`;
        
            const hitCount = number === '00' ? 8 : 9; 
            message += `üìä X√°c su·∫•t tr√∫ng: ~${hitCount}/100 (c√≥ ${hitCount} c·∫∑p s·ªë trong b·∫£ng k·∫øt qu·∫£)\n`;
            break;
    }

    return message;
}
function getAllTickets(drawId) {
    return ticketData.tickets[drawId] || [];
}

function clearOldTickets() {
    const now = Date.now();
    const oneDayAgo = now - (24 * 60 * 60 * 1000);

    Object.keys(ticketData.tickets).forEach(drawId => {
        if (parseInt(drawId) < oneDayAgo) {
            delete ticketData.tickets[drawId];
        }
    });

    saveTickets();
}

function checkWinners(results, drawId, api) {
    if (!ticketData.tickets[drawId]) return [];

    const winners = [];
    const specialLast2 = results.special.slice(-2); // Get last 2 digits of special prize
    const loNumbers = [
        results.first.slice(-2),
        ...results.second.map(num => num.slice(-2)),
        ...results.third.map(num => num.slice(-2)),
        ...results.fourth.map(num => num.slice(-2)),
        ...results.fifth.map(num => num.slice(-2)),
        ...results.sixth.map(num => num.slice(-2)),
        ...results.seventh.map(num => num.slice(-2))
    ];

    ticketData.tickets[drawId].forEach(ticket => {
        let winAmount = 0;
        switch (ticket.betType) {
            case 'de2':
                if (ticket.number === specialLast2) winAmount = ticket.amount * SPECIAL_PRIZE_RATIO;
                break;
            case 'de3':
                if (ticket.number === results.special.slice(-3)) winAmount = ticket.amount * DE3_PRIZE_RATIO;
                break;
            case 'de5':
                if (ticket.number === results.special) winAmount = ticket.amount * 10000;
                break;
            case 'lo':
                if (loNumbers.includes(ticket.number)) winAmount = ticket.amount * LO_PRIZE_RATIO;
                break;
        }
        if (winAmount > 0) {
            winners.push({
                ...ticket,
                winAmount,
                betAmount: ticket.amount
            });

            // Update user's balance
            updateBalance(ticket.userId, winAmount);
        }
    });

    return winners;
}

module.exports = {
    name: "lotto",
    info: "Ch∆°i x·ªï s·ªë nhanh Quick Lotto",
    dev: "HNT",
    category: "Games",
    usedby: 0,
    onPrefix: true,
    cooldowns: 5,
    usages: `=== H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG QUICK LOTTO ===
1. Xem k·∫øt qu·∫£ v√† th√¥ng tin:
   .lotto ‚Üí Xem k·∫øt qu·∫£ m·ªõi nh·∫•t

2. Mua v√© s·ªë:
   .lotto buy [lo·∫°i] [s·ªë] [ti·ªÅn]
   
   c√≥ 4 lo·∫°i c∆∞·ª£c:
    ‚Ä¢ ƒê·ªÅ 2 s·ªë: .lotto buy de2 [s·ªë 2 ch·ªØ s·ªë] [ti·ªÅn]
    ‚Ä¢ ƒê·ªÅ 3 c√†ng: .lotto buy de3 [s·ªë 3 ch·ªØ s·ªë] [ti·ªÅn]
    ‚Ä¢ ƒê·ªÅ 5 s·ªë: .lotto buy de5 [s·ªë 5 ch·ªØ s·ªë] [ti·ªÅn]
    ‚Ä¢ L√¥: .lotto buy lo [s·ªë 2 ch·ªØ s·ªë] [ti·ªÅn]

   ƒê√ÅNH ƒê·ªÄ
   VD: .lotto buy de2 68 1000 ‚Üí Mua s·ªë 68 v·ªõi 1000$
   ‚Ä¢ ƒë·ªëi v·ªõi ƒë·ªÅ 2 s·ªë nh·∫≠n x95 ti·ªÅn c∆∞·ª£c
   ‚Ä¢ ƒë·ªëi v·ªõi ƒë·ªÅ 3 s·ªë nh·∫≠n x999 ti·ªÅn c∆∞·ª£c
   ‚Ä¢ ƒë·ªëi v·ªõi ƒë·ªÅ 5 s·ªë nh·∫≠n x10,000 ti·ªÅn c∆∞·ª£c

   ƒê√ÅNH L√î
    VD: .lotto buy lo 68 1000 ‚Üí Mua s·ªë 68 v·ªõi 1000$
   ‚Ä¢ Ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu 1000$
   ‚Ä¢ T·ªâ l·ªá tr√∫ng l√¥: 3.67x
   ‚Ä¢ X√°c su·∫•t tr√∫ng: ~8/100 (c√≥ 8 c·∫∑p s·ªë trong b·∫£ng k·∫øt qu·∫£)

3. Qu·∫£n l√Ω v√© s·ªë: 
   .lotto tickets ‚Üí Xem v√© ƒë√£ mua
   .lotto history ‚Üí Xem 3 k·ª≥ g·∫ßn nh·∫•t

4. C√†i ƒë·∫∑t th√¥ng b√°o:
   .lotto notify ‚Üí B·∫≠t/t·∫Øt th√¥ng b√°o
   
üí° M·ªói k·ª≥ quay c√°ch nhau 10 ph√∫t`,

    onLaunch: async function ({ api, event, target = [] }) {
        const { threadID, messageID, senderID } = event;

        try {
            if (!ticketData || !ticketData.tickets) {
                ticketData = loadTickets();
            }

            const settings = loadSettings();
            const isEnabled = settings.enabledThreads.includes(threadID);

            // ƒê·∫£m b·∫£o nextDrawTime ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng
            const now = Date.now();
            if (!nextDrawTime || nextDrawTime.getTime() <= now) {
                nextDrawTime = new Date();
                // ƒê·∫∑t th·ªùi gian quay s·ªë t·ªõi ph√∫t chia h·∫øt cho 10 ti·∫øp theo
                nextDrawTime.setMinutes(Math.ceil(nextDrawTime.getMinutes() / 10) * 10, 0, 0);
            }

            // T√≠nh th·ªùi gian c√≤n l·∫°i v·ªõi ƒë·∫£m b·∫£o lu√¥n d∆∞∆°ng
            const timeUntilNext = nextDrawTime.getTime() - now;
            const minutesLeft = Math.max(0, Math.floor(timeUntilNext / 60000));
            const secondsLeft = Math.max(0, Math.floor((timeUntilNext % 60000) / 1000));

            const currentDrawId = nextDrawTime ? nextDrawTime.getTime().toString() : null;
            const userTickets = currentDrawId ? getUserTickets(senderID, currentDrawId) : [];

            const command = target[0]?.toLowerCase() || "default";

            switch (command) {
                case "notify":
                    if (isEnabled) {
                        settings.enabledThreads = settings.enabledThreads.filter(id => id !== threadID);
                        saveSettings(settings);
                        return api.sendMessage(
                            "üîï ƒê√£ T·∫ÆT th√¥ng b√°o k·∫øt qu·∫£ x·ªï s·ªë cho nh√≥m n√†y!",
                            threadID,
                            messageID
                        );
                    } else {
                        settings.enabledThreads.push(threadID);
                        saveSettings(settings);
                        return api.sendMessage(
                            "üîî ƒê√£ B·∫¨T th√¥ng b√°o k·∫øt qu·∫£ x·ªï s·ªë cho nh√≥m n√†y!",
                            threadID,
                            messageID
                        );
                    }
                    break;

                case "history":
                    if (lastResults.length === 0) {
                        return api.sendMessage("‚ùå Ch∆∞a c√≥ k·∫øt qu·∫£ x·ªï s·ªë n√†o!", threadID, messageID);
                    }

                    const historyCount = Math.min(3, lastResults.length);
                    let historyMessage = "üìú L·ªäCH S·ª¨ X·ªî S·ªê G·∫¶N ƒê√ÇY üìú\n";
                    historyMessage += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";

                    for (let i = 0; i < historyCount; i++) {
                        const draw = lastResults[i];
                        const drawDate = new Date(draw.drawTime);
                        historyMessage += `üî∏ K·ª≥ ${i + 1} - ${drawDate.toLocaleString('vi-VN')}\n`;
                        historyMessage += `üèÜ Gi·∫£i ƒêB: ${draw.results.special}\n`;
                        historyMessage += `ü•á Gi·∫£i Nh·∫•t: ${draw.results.first}\n`;
                        historyMessage += `ü•à Gi·∫£i Nh√¨: ${draw.results.second.join(', ')}\n`;
                        historyMessage += `ü•â Gi·∫£i Ba: ${draw.results.third.join(', ')}\n\n`;
                    }

                    return api.sendMessage(historyMessage, threadID, messageID);
                    break;

                case "buy":
                    const betType = target[1]?.toLowerCase();
                    const number = target[2];
                    const amount = parseInt(target[3]);
                    const minAmount = betType === "lo" ? MIN_BET_LO : 1000;
                    const numberPattern = betType === "de5" ? /^\d{5}$/ : betType === "de3" ? /^\d{3}$/ : /^\d{2}$/;

                    if (!number || !numberPattern.test(number)) {
                        return api.sendMessage(`‚ùå S·ªë kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng cho lo·∫°i c∆∞·ª£c ${betType}.`, threadID, messageID);
                    }

                    if (!amount || isNaN(amount) || amount < minAmount) {
                        return api.sendMessage(`‚ùå S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i t·ª´ ${minAmount.toLocaleString('vi-VN')}$ tr·ªü l√™n!`, threadID, messageID);
                    }

                    const balance = await getBalance(senderID);
                    if (balance < amount) {
                        return api.sendMessage(`‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß! B·∫°n ch·ªâ c√≥ ${balance.toLocaleString('vi-VN')}$`, threadID, messageID);
                    }

                    const buyTimeUntilNext = nextDrawTime ? nextDrawTime - Date.now() : 0;
                    const buyMinutesLeft = Math.ceil(buyTimeUntilNext / 60000);
                    const buySecondsLeft = Math.ceil(buyTimeUntilNext / 1000) % 60;

                    await updateBalance(senderID, -amount);

                    buyTicket(senderID, threadID, number, amount, betType);

                    const nextDrawId = nextDrawTime.getTime().toString();
                    const userTicketsForBuy = getUserTickets(senderID, nextDrawId);
                    let ticketList = "";

                    if (userTicketsForBuy.length > 0) {
                        ticketList = "\n\nüé´ V√© s·ªë ƒë√£ mua:\n";
                        userTicketsForBuy.forEach((ticket, index) => {
                            ticketList += `${index + 1}. S·ªë ${ticket.number}: ${ticket.amount.toLocaleString('vi-VN')}$\n`;
                        });
                    }

                    return api.sendMessage(
                        `üé´ MUA V√â ${betType.toUpperCase()} TH√ÄNH C√îNG üé´\n` +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üî¢ S·ªë: ${number}\n` +
                        `üí∞ C∆∞·ª£c: ${amount.toLocaleString('vi-VN')}$\n` +
                        `‚è∞ K·ª≥ quay: ${nextDrawTime.toLocaleString('vi-VN')}\n\n` +
                        `üèÜ N·∫æU TR√öNG B·∫†N S·∫º NH·∫¨N ƒê∆Ø·ª¢C:\n` +
                        getPotentialWinnings(betType, amount, number) +
                        ticketList,
                        threadID, messageID
                    );
                    break;

                case "ticket":
                case "tickets":
                    // Check user's current tickets
                    const currentTickets = getUserTickets(senderID, currentDrawId);

                    if (currentTickets.length === 0) {
                        return api.sendMessage("‚ùå B·∫°n ch∆∞a mua v√© s·ªë n√†o cho k·ª≥ quay s·∫Øp t·ªõi!", threadID, messageID);
                    }

                    let ticketMessage = "üé´ V√â S·ªê ƒê√É MUA üé´\n";
                    ticketMessage += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";

                    let totalBet = 0;
                    currentTickets.forEach((ticket, index) => {
                        ticketMessage += `${index + 1}. S·ªë ${ticket.number}: ${ticket.amount.toLocaleString('vi-VN')}$\n`;
                        totalBet += ticket.amount;
                    });

                    ticketMessage += `\nüí∞ T·ªïng c∆∞·ª£c: ${totalBet.toLocaleString('vi-VN')}$\n`;
                    ticketMessage += `üíµ Th∆∞·ªüng t·ªëi ƒëa: ${(totalBet * SPECIAL_PRIZE_RATIO).toLocaleString('vi-VN')}$\n`;

                    const timeLeft = nextDrawTime - Date.now();
                    const minsLeft = Math.floor(timeLeft / 60000);
                    const secsLeft = Math.floor((timeLeft % 60000) / 1000);

                    ticketMessage += `‚è∞ K·ª≥ quay sau: ${minsLeft}m ${secsLeft}s\n`;
                    ticketMessage += `üìÜ Th·ªùi gian: ${nextDrawTime.toLocaleString('vi-VN')}`;

                    return api.sendMessage(ticketMessage, threadID, messageID);
                    break;

                default:

                    let message = "üé∞ X·ªî S·ªê MI·ªÄN B·∫ÆC üé∞\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n";

                    if (lastResults.length > 0 && lastResults[0] && lastResults[0].results) {
                        const latest = lastResults[0].results;
                        const latestTime = new Date(lastResults[0].drawTime);

                        message += "üéØ K·∫æT QU·∫¢ G·∫¶N NH·∫§T:\n\n";
                        message += `‚è∞ Th·ªùi gian: ${latestTime.toLocaleString('vi-VN')}\n`;
                        message += `üèÜ Gi·∫£i ƒêB: ${latest.special}\n`;
                        message += `ü•á Gi·∫£i Nh·∫•t: ${latest.first}\n`;
                        message += `ü•à Gi·∫£i Nh√¨: ${latest.second.join(', ')}\n`;
                        message += `ü•â Gi·∫£i Ba: ${latest.third.join(', ')}\n`;
                        message += `4Ô∏è‚É£ Gi·∫£i T∆∞: ${latest.fourth.join(', ')}\n`;
                        message += `5Ô∏è‚É£ Gi·∫£i NƒÉm: ${latest.fifth.join(', ')}\n`;
                        message += `6Ô∏è‚É£ Gi·∫£i S√°u: ${latest.sixth.join(', ')}\n`;
                        message += `7Ô∏è‚É£ Gi·∫£i B·∫£y: ${latest.seventh.join(', ')}\n\n`;
                        message += `${isEnabled ? 'üîî' : 'üîï'} Th√¥ng b√°o: ${isEnabled ? 'B·∫≠t' : 'T·∫Øt'}`;
                        message += "\nüí° .lotto notify ƒë·ªÉ b·∫≠t/t·∫Øt th√¥ng b√°o";
                        message += "\nüí° .lotto history ƒë·ªÉ xem l·ªãch s·ª≠";
                        message += "\nüí° .lotto buy [s·ªë 2 ch·ªØ s·ªë] [ti·ªÅn c∆∞·ª£c] ƒë·ªÉ mua v√©";
                    } else {
                        message += "‚ùå Ch∆∞a c√≥ k·∫øt qu·∫£ x·ªï s·ªë n√†o!\n";
                        message += `${isEnabled ? 'üîî' : 'üîï'} Th√¥ng b√°o: ${isEnabled ? 'B·∫≠t' : 'T·∫Øt'}\n`;
                        message += "üí° .lotto notify ƒë·ªÉ b·∫≠t/t·∫Øt th√¥ng b√°o\n";
                        message += "üí° .lotto buy [s·ªë 2 ch·ªØ s·ªë] [ti·ªÅn c∆∞·ª£c] ƒë·ªÉ mua v√©\n";
                    }

                    message += `\n‚è∞ K·ª≥ quay k·∫ø ti·∫øp sau: ${minutesLeft}m ${secondsLeft}s\n`;
                    message += "\nüí° M·ªói k·ª≥ quay sau 10 ph√∫t";
                    if (userTickets.length > 0) {
                        message += "\n\nüé´ V√â S·ªê ƒê√É MUA:\n";
                        const maxDisplay = Math.min(3, userTickets.length);
                        for (let i = 0; i < maxDisplay; i++) {
                            message += `‚Ä¢ S·ªë ${userTickets[i].number}: ${userTickets[i].amount.toLocaleString('vi-VN')}$\n`;
                        }

                        if (userTickets.length > maxDisplay) {
                            message += `‚Ä¢ ... v√† ${userTickets.length - maxDisplay} v√© kh√°c\n`;
                        }

                        message += "üí° .lotto tickets ƒë·ªÉ xem t·∫•t c·∫£ c√°c v√©";
                    }

                    message += "\n\nüíé C√ÅC LO·∫†I C∆Ø·ª¢C:\n" +
                        "‚Ä¢ ƒê·ªÅ 2 s·ªë: .lotto buy de2 XX YYYY$\n" +
                        "‚Ä¢ ƒê·ªÅ 3 c√†ng: .lotto buy de3 XXX YYYY$\n" +
                        "‚Ä¢ ƒê·ªÅ 5 s·ªë: .lotto buy de5 XXXXX YYYY$\n" +
                        "‚Ä¢ L√¥: .lotto buy lo XX YYYY$\n";

                    await api.sendMessage(message, threadID, messageID);
                    break;
            }

        } catch (error) {
            console.error('QuickLotto Error:', error);
            await api.sendMessage(
                "‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra khi l·∫•y k·∫øt qu·∫£ x·ªï s·ªë!",
                threadID,
                messageID
            );
        }
    },

    onLoad: function({ api }) {
        loadHistory();
        
        const loadedTickets = loadTickets();
        if (loadedTickets) {
            ticketData = loadedTickets;
        } else {
            ticketData = { tickets: {} };
        }
    
        const now = Date.now();
        if (!nextDrawTime || nextDrawTime.getTime() <= now) {
            nextDrawTime = new Date();
            nextDrawTime.setMinutes(Math.ceil(nextDrawTime.getMinutes() / 10) * 10, 0, 0);
        }

        schedule.scheduleJob(SCHEDULE_INTERVAL, async function () {
            try {
                const results = generateResults();
                saveHistory(results);

                const currentDrawId = nextDrawTime.getTime().toString();

                nextDrawTime = new Date();
                nextDrawTime.setMinutes(nextDrawTime.getMinutes() + 10, 0, 0);

                const winners = checkWinners(results, currentDrawId, api);

                const settings = loadSettings();
                const threads = await api.getThreadList(100, null, ['INBOX']);
                const drawTime = new Date();

                let message = "üé∞ K·∫æT QU·∫¢ QUICK LOTTO üé∞\n" +
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                    `‚è∞ Th·ªùi gian: ${drawTime.toLocaleString('vi-VN')}\n` +
                    `üèÜ Gi·∫£i ƒêB: ${results.special}\n` +
                    `ü•á Gi·∫£i Nh·∫•t: ${results.first}\n` +
                    `ü•à Gi·∫£i Nh√¨: ${results.second.join(', ')}\n` +
                    `ü•â Gi·∫£i Ba: ${results.third.join(', ')}\n` +
                    `4Ô∏è‚É£ Gi·∫£i T∆∞: ${results.fourth.join(', ')}\n` +
                    `5Ô∏è‚É£ Gi·∫£i NƒÉm: ${results.fifth.join(', ')}\n` +
                    `6Ô∏è‚É£ Gi·∫£i S√°u: ${results.sixth.join(', ')}\n` +
                    `7Ô∏è‚É£ Gi·∫£i B·∫£y: ${results.seventh.join(', ')}\n\n` +
                    "‚è∞ K·ª≥ quay k·∫ø ti·∫øp sau 10 ph√∫t";

                for (const thread of threads) {
                    if (thread.isGroup && settings.enabledThreads.includes(thread.threadID)) {
                        await api.sendMessage(message, thread.threadID);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                for (const winner of winners) {
                    const winMessage =
                        "üéâ CH√öC M·ª™NG TR√öNG X·ªî S·ªê! üéâ\n" +
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
                        `üéØ S·ªë tr√∫ng: ${winner.number}\n` +
                        `üí∞ Ti·ªÅn c∆∞·ª£c: ${winner.betAmount.toLocaleString('vi-VN')}$\n` +
                        `üíµ Ti·ªÅn th·∫Øng: ${winner.winAmount.toLocaleString('vi-VN')}$\n` +
                        `üèÜ T·ªâ l·ªá th·∫Øng: ${SPECIAL_PRIZE_RATIO}x\n\n` +
                        "üí° Ti·ªÅn th∆∞·ªüng ƒë√£ ƒë∆∞·ª£c c·ªông v√†o t√†i kho·∫£n!";

                    await api.sendMessage(winMessage, winner.threadId);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                clearOldTickets();

            } catch (error) {
                console.error('QuickLotto Schedule Error:', error);
            }
        });
    }
};
