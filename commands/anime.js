const axios = require('axios');
const translate = require('translate-google');
const { getInfoFromName } = require('mal-scraper');
const request = require('request');
const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');

module.exports = {
    name: "anime",
    category: "Anime",
    info: "T√¨m ki·∫øm th√¥ng tin Anime, nh√¢n v·∫≠t, ·∫£nh, g·ª£i √Ω, m√πa hi·ªán t·∫°i, v√† manga.",
    dev: "ZiaRein",
    onPrefix: true,
    usages: [
        "anime info <t√™n anime>",
        "anime char <t√™n nh√¢n v·∫≠t>",
        "anime pic [th·ªÉ lo·∫°i|list|wall <t·ª´ kh√≥a>]",
        "anime rec [th·ªÉ lo·∫°i|t√™n anime]",
        "anime season [s·ªë trang]",
        "anime manga <t√™n manga>"
    ],
    cooldowns: 5,

    onLaunch: async function ({ api, event, target, actions }) {
        const { threadID, messageID } = event;
        const subcommand = target[0]?.toLowerCase();
        const query = target.slice(1).join(" ").trim();

        if (!subcommand) {
            return api.sendMessage(
                "üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng l·ªánh anime:\n\n" +
                this.usages.map(u => `- ${u}`).join("\n"),
                threadID, messageID
            );
        }

        switch (subcommand) {
            case "info":
                return await this.handleAnimeInfo(api, event, query, actions);
            case "char":
                return await this.handleAnimeChar(api, event, query);
            case "pic":
                return await this.handleAnimePic(api, event, target.slice(1));
            case "rec":
                return await this.handleAnimeRec(api, event, query);
            case "season":
                return await this.handleAnimeSeason(api, event, query);
            case "manga":
                return await this.handleMangaInfo(api, event, query);
            default:
                return api.sendMessage("‚ùå Subcommand kh√¥ng h·ª£p l·ªá!", threadID, messageID);
        }
    },
    handleWallpaper: async function(api, event, keywords) {
        const { threadID, messageID } = event;
        
        if (!keywords || keywords.length === 0) {
            return api.sendMessage(
                "üìå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm!\nV√≠ d·ª•: anime pic wall waifu",
                threadID,
                messageID
            );
        }
    
        const query = keywords.join(" ");
        const cacheDir = path.join(__dirname, "cache");
        if (!fs.existsSync(cacheDir)) {
            fs.mkdirSync(cacheDir, { recursive: true });
        }
    
        try {
            const response = await axios.get(
                `https://www.zerochan.net/search?q=${encodeURIComponent(query)}`,
                { responseType: "text" }
            );
    
            const imageUrls = response.data.match(/https:\/\/static\.zerochan\.net\/[^"]+\.full\.[^"]+/g);
            if (!imageUrls || imageUrls.length === 0) {
                return api.sendMessage(
                    "‚ùå Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh ph√π h·ª£p!",
                    threadID,
                    messageID
                );
            }
    
            const randomImage = imageUrls[Math.floor(Math.random() * imageUrls.length)];
            const imgResponse = await axios.get(randomImage, {
                responseType: "arraybuffer"
            });
    
            const imgPath = path.join(
                cacheDir,
                `wall_${Date.now()}.${randomImage.split(".").pop()}`
            );
    
            fs.writeFileSync(imgPath, imgResponse.data);
    
            await api.sendMessage(
                {
                    body: `üå∏ Anime Wallpaper: ${query}`,
                    attachment: fs.createReadStream(imgPath)
                },
                threadID,
                () => fs.unlinkSync(imgPath),
                messageID
            );
    
        } catch (error) {
            console.error("Wallpaper Error:", error);
            return api.sendMessage(
                "‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra khi t√¨m h√¨nh ·∫£nh, vui l√≤ng th·ª≠ l·∫°i sau!",
                threadID,
                messageID
            );
        }
    },
    handleAnimeInfo: async function (api, event, query, actions) {
        if (!query || query.length < 2) {
            return await actions.reply("‚ùé Vui l√≤ng nh·∫≠p t√™n anime c·∫ßn t√¨m (√≠t nh·∫•t 2 k√Ω t·ª±)");
        }

        const cachePath = path.join(__dirname, 'cache');
        if (!fs.existsSync(cachePath)) {
            fs.mkdirSync(cachePath, { recursive: true });
        }

        try {
            const anime = await getInfoFromName(query);
            if (!anime) throw new Error("Kh√¥ng t√¨m th·∫•y th√¥ng tin anime n√†y");

            let imagePath = null;
            if (anime.picture) {
                imagePath = path.join(cachePath, `mal_${Date.now()}.${getImageExt(anime.picture)}`);
                await downloadImage(anime.picture, imagePath);
            }

            const translatedSynopsis = await translate(anime.synopsis || "Kh√¥ng c√≥ m√¥ t·∫£", { from: 'en', to: 'vi' });
            const msg = formatAnimeMessage(anime, translatedSynopsis);

            const attachments = imagePath ? [fs.createReadStream(imagePath)] : [];
            await actions.send(
                { body: msg, attachment: attachments },
                event.threadID,
                async () => {
                    if (imagePath) {
                        try {
                            await fsPromises.unlink(imagePath);
                        } catch (err) {
                            console.error("Failed to delete temp file:", err);
                        }
                    }
                },
                event.messageID
            );

        } catch (err) {
            console.error("Error fetching anime info:", err);
            return await actions.reply(`‚ö†Ô∏è L·ªói: ${err.message || "Kh√¥ng th·ªÉ t√¨m th·∫•y anime"}`);
        }
    },

    handleAnimeChar: async function (api, event, query) {
        if (!query) {
            return api.sendMessage("üìå Vui l√≤ng nh·∫≠p t√™n nh√¢n v·∫≠t c·∫ßn t√¨m!", event.threadID, event.messageID);
        }

        try {
            const response = await axios.get(`https://api.jikan.moe/v4/characters?q=${encodeURIComponent(query)}&limit=1`);
            if (!response.data?.data?.[0]) {
                return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n v·∫≠t!", event.threadID, event.messageID);
            }

            const char = response.data.data[0];
            const about = await translate(char.about || "Kh√¥ng c√≥ th√¥ng tin", { from: 'en', to: 'vi' });

            const imgResponse = await axios.get(char.images.jpg.image_url, { responseType: 'arraybuffer' });
            const imgPath = path.join(__dirname, 'cache', `char_${Date.now()}.jpg`);
            fs.writeFileSync(imgPath, imgResponse.data);

            const msg = `üë§ TH√îNG TIN NH√ÇN V·∫¨T\n\n` +
                       `üìù T√™n: ${char.name}\n` +
                       `‚úíÔ∏è T√™n kh√°c: ${char.name_kanji || 'Kh√¥ng c√≥'}\n` +
                       `üëç ƒê·ªô y√™u th√≠ch: ${char.favorites}\n\n` +
                       `üìñ Gi·ªõi thi·ªáu:\n${about}\n\n` +
                       `üîó Chi ti·∫øt: ${char.url}`;

            await api.sendMessage(
                {
                    body: msg,
                    attachment: fs.createReadStream(imgPath)
                },
                event.threadID,
                () => fs.unlinkSync(imgPath),
                event.messageID
            );

        } catch (error) {
            console.error("Animechar Error:", error);
            return api.sendMessage("‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
        }
    },

    handleAnimePic: async function (api, event, target) {
        const { threadID, messageID } = event;

        // Handle wallpaper command
        if (target[0] === "wall") {
            return await this.handleWallpaper(api, event, target.slice(1));
        }

        const categories = {
            waifu: "Waifu",
            neko: "M√®o n·ªØ",
            shinobu: "Shinobu",
            megumin: "Megumin",
            // ...other categories...
        };

        if (!target[0] || target[0] === "random") {
            const randomCategory =
                Object.keys(categories)[
                    Math.floor(Math.random() * Object.keys(categories).length)
                ];
            target[0] = randomCategory;
        }

        if (target[0] === "list") {
            let msg = "üìë DANH S√ÅCH TH·ªÇ LO·∫†I:\n\n";
            Object.entries(categories).forEach(([key, value], index) => {
                msg += `${index + 1}. ${value} (${key})\n`;
            });
            msg += "\nüëâ D√πng 'animepic <th·ªÉ lo·∫°i>' ƒë·ªÉ xem ·∫£nh";
            return api.sendMessage(msg, threadID, messageID);
        }

        const category = target[0].toLowerCase();
        if (!categories[category]) {
            return api.sendMessage(
                "‚ùå Th·ªÉ lo·∫°i kh√¥ng h·ª£p l·ªá!\nüëâ D√πng 'animepic list' ƒë·ªÉ xem danh s√°ch",
                threadID,
                messageID
            );
        }

        try {
            const response = await axios.get(
                `https://api.waifu.pics/sfw/${category}`
            );
            if (!response.data?.url) throw new Error("Kh√¥ng t√¨m th·∫•y ·∫£nh");

            const imgResponse = await axios.get(response.data.url, {
                responseType: "arraybuffer",
            });
            const imgPath = path.join(
                __dirname,
                "cache",
                `anime_${Date.now()}.${response.data.url.split(".").pop()}`
            );

            fs.writeFileSync(imgPath, imgResponse.data);

            await api.sendMessage(
                {
                    body: `üå∏ Anime ${categories[category]}`,
                    attachment: fs.createReadStream(imgPath),
                },
                threadID,
                () => fs.unlinkSync(imgPath),
                messageID
            );
        } catch (error) {
            console.error("Animepic Error:", error);
            return api.sendMessage(
                "‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i sau!",
                threadID,
                messageID
            );
        }
    },

    handleAnimeRec: async function (api, event, query) {
        const { threadID, messageID } = event;

        try {
            let endpoint, data, type;

            if (!query) {
                endpoint = "https://api.jikan.moe/v4/recommendations/anime";
                type = "random";
            } else if (query.length < 10) {
                const genreId = getGenreId(query.toLowerCase());
                if (genreId) {
                    endpoint = `https://api.jikan.moe/v4/anime?genres=${genreId}&order_by=score&sort=desc&limit=5`;
                    type = "genre";
                    data = { genre: query };
                } else {
                    return api.sendMessage("‚ùå Th·ªÉ lo·∫°i kh√¥ng h·ª£p l·ªá!", threadID, messageID);
                }
            } else {
                endpoint = `https://api.jikan.moe/v4/anime?q=${encodeURIComponent(query)}&order_by=score&sort=desc&limit=1`;
                type = "similar";
                data = { anime: query };
            }

            const response = await axios.get(endpoint);

            if (type === "random") {
                if (!response.data?.data?.length) {
                    throw new Error("Kh√¥ng t√¨m th·∫•y anime n√†o!");
                }

                const randomRec = response.data.data[Math.floor(Math.random() * response.data.data.length)];
                const randomAnime = randomRec.entry[Math.floor(Math.random() * randomRec.entry.length)];

                const translatedContent = await translate(
                    randomRec.content.substring(0, 500) + (randomRec.content.length > 500 ? "..." : ""),
                    { from: 'en', to: 'vi' }
                );

                const msg = `üéØ ANIME G·ª¢I √ù NG·∫™U NHI√äN\n\n` +
                           `üì∫ Anime: ${randomAnime.title}\n` +
                           `‚≠ê ƒê√°nh gi√°: ${randomAnime.score || "N/A"}/10\n` +
                           `üìù L√Ω do g·ª£i √Ω:\n${translatedContent}\n\n` +
                           `üîó Xem chi ti·∫øt: ${randomAnime.url}`;

                return api.sendMessage(msg, threadID, messageID);
            } else if (type === "genre") {
                if (!response.data?.data?.length) {
                    throw new Error(`Kh√¥ng t√¨m th·∫•y anime n√†o thu·ªôc th·ªÉ lo·∫°i ${data.genre}!`);
                }

                let msg = `üéØ TOP 5 ANIME TH·ªÇ LO·∫†I ${data.genre.toUpperCase()}\n\n`;

                for (let i = 0; i < response.data.data.length; i++) {
                    const anime = response.data.data[i];
                    msg += `${i + 1}. ${anime.title}\n`;
                    msg += `‚≠ê ƒê√°nh gi√°: ${anime.score || "N/A"}/10\n`;
                    msg += `üé¨ S·ªë t·∫≠p: ${anime.episodes || "?"}\n`;
                    msg += `üìÖ NƒÉm: ${anime.year || "N/A"}\n\n`;
                }

                msg += `üëâ D√πng l·ªánh "anime <t√™n anime>" ƒë·ªÉ xem chi ti·∫øt v·ªÅ t·ª´ng anime.`;

                return api.sendMessage(msg, threadID, messageID);
            } else if (type === "similar") {
                if (!response.data?.data?.length) {
                    throw new Error(`Kh√¥ng t√¨m th·∫•y anime "${data.anime}"!`);
                }

                const selectedAnime = response.data.data[0];
                const genres = selectedAnime.genres.map(genre => genre.mal_id).join(",");

                const similarResponse = await axios.get(
                    `https://api.jikan.moe/v4/anime?genres=${genres}&order_by=score&sort=desc&limit=5`
                );

                if (!similarResponse.data?.data?.length) {
                    throw new Error("Kh√¥ng t√¨m th·∫•y anime t∆∞∆°ng t·ª±!");
                }

                const recommendations = similarResponse.data.data
                    .filter(anime => anime.mal_id !== selectedAnime.mal_id)
                    .slice(0, 5);

                let msg = `üéØ ANIME T∆Ø∆†NG T·ª∞ "${selectedAnime.title}"\n\n`;

                for (let i = 0; i < recommendations.length; i++) {
                    const anime = recommendations[i];
                    msg += `${i + 1}. ${anime.title}\n`;
                    msg += `‚≠ê ƒê√°nh gi√°: ${anime.score || "N/A"}/10\n`;
                    msg += `üé¨ S·ªë t·∫≠p: ${anime.episodes || "?"}\n`;
                    msg += `üìÖ NƒÉm: ${anime.year || "N/A"}\n\n`;
                }

                msg += `üëâ D√πng l·ªánh "anime <t√™n anime>" ƒë·ªÉ xem chi ti·∫øt v·ªÅ t·ª´ng anime.`;

                return api.sendMessage(msg, threadID, messageID);
            }
        } catch (error) {
            console.error("Animerec Error:", error);
            return api.sendMessage(
                `‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra: ${error.message || "Kh√¥ng th·ªÉ t√¨m g·ª£i √Ω anime"}`,
                threadID, messageID
            );
        }
    },

    handleAnimeSeason: async function (api, event, query) {
        const { threadID, messageID } = event;
        const page = parseInt(query) || 1;
        const perPage = 10;

        try {
            const season = getCurrentSeason();
            const year = new Date().getFullYear();

            const response = await axios.get(
                `https://api.jikan.moe/v4/seasons/${year}/${season}`
            );

            if (!response.data?.data?.length) {
                throw new Error("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu anime!");
            }

            const animes = response.data.data;
            const totalPages = Math.ceil(animes.length / perPage);

            if (page < 1 || page > totalPages) {
                return api.sendMessage(
                    `‚ö†Ô∏è Trang ph·∫£i t·ª´ 1 ƒë·∫øn ${totalPages}!`,
                    threadID, messageID
                );
            }

            const start = (page - 1) * perPage;
            const end = start + perPage;
            const pageAnimes = animes.slice(start, end);

            let msg = `üå∏ ANIME ${season.toUpperCase()} ${year}\n`;
            msg += `Trang ${page}/${totalPages}\n\n`;

            for (let i = 0; i < pageAnimes.length; i++) {
                const anime = pageAnimes[i];
                const title = anime.title;
                const score = anime.score || "N/A";
                const episodes = anime.episodes || "??";
                const type = anime.type || "N/A";

                msg += `${start + i + 1}. ${title}\n`;
                msg += `‚≠ê Score: ${score}\n`;
                msg += `üé¨ T·∫≠p: ${episodes}\n`;
                msg += `üì∫ Lo·∫°i: ${type}\n\n`;
            }

            msg += `D√πng "anime season ${page + 1}" ƒë·ªÉ xem trang ti·∫øp theo`;

            return api.sendMessage(msg, threadID, messageID);

        } catch (error) {
            console.error("Animeseason Error:", error);
            return api.sendMessage(
                "‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i sau!",
                threadID, messageID
            );
        }
    },

    handleMangaInfo: async function (api, event, query) {
        if (!query) {
            return api.sendMessage("üìå Vui l√≤ng nh·∫≠p t√™n manga c·∫ßn t√¨m!", event.threadID, event.messageID);
        }

        try {
            const response = await axios.get(`https://api.jikan.moe/v4/manga?q=${encodeURIComponent(query)}&limit=1`);
            if (!response.data?.data?.[0]) {
                return api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin manga!", event.threadID, event.messageID);
            }

            const manga = response.data.data[0];
            const synopsis = await translate(manga.synopsis || "Kh√¥ng c√≥ m√¥ t·∫£", { from: 'en', to: 'vi' });

            const msg = `üìñ TH√îNG TIN MANGA\n\n` +
                       `üìö T√™n: ${manga.title}\n` +
                       `üéå T√™n ti·∫øng Nh·∫≠t: ${manga.title_japanese || "Kh√¥ng c√≥"}\n` +
                       `üìñ T√¨nh tr·∫°ng: ${manga.status}\n` +
                       `üìÖ Ng√†y ph√°t h√†nh: ${manga.published.string}\n` +
                       `üìã S·ªë ch∆∞∆°ng: ${manga.chapters || "?"}\n` +
                       `üìì S·ªë t·∫≠p: ${manga.volumes || "?"}\n` +
                       `üåü ƒêi·ªÉm s·ªë: ${manga.score || "N/A"}\n\n` +
                       `üìù N·ªôi dung:\n${synopsis}\n\n` +
                       `üîó Link chi ti·∫øt: ${manga.url}`;

            return api.sendMessage(msg, event.threadID, event.messageID);
        } catch (error) {
            console.error("MangaInfo Error:", error);
            return api.sendMessage("‚ùå ƒê√£ c√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i sau!", event.threadID, event.messageID);
        }
    }
};

function getImageExt(url) {
    return url.split('.').pop() || 'jpg';
}

function formatAnimeMessage(anime, synopsis) {
    return `üìñ TH√îNG TIN ANIME\n\n` +
           `üé• T√™n: ${anime.title}\n` +
           `üéå T√™n ti·∫øng Nh·∫≠t: ${anime.japaneseTitle}\n` +
           `üì∫ Lo·∫°i: ${anime.type}\n` +
           `‚ö°Ô∏è Tr·∫°ng th√°i: ${anime.status}\n` +
           `üóìÔ∏è Kh·ªüi chi·∫øu: ${anime.premiered}\n` +
           `üì° Ph√°t s√≥ng: ${anime.broadcast}\n` +
           `üìÖ Ra m·∫Øt: ${anime.aired}\n` +
           `üé¨ Nh√† s·∫£n xu·∫•t: ${anime.producers}\n` +
           `üéì Studio: ${anime.studios}\n` +
           `üìù Ngu·ªìn: ${anime.source}\n` +
           `üéûÔ∏è S·ªë t·∫≠p: ${anime.episodes}\n` +
           `‚åõÔ∏è Th·ªùi l∆∞·ª£ng: ${anime.duration}\n` +
           `üé≠ Th·ªÉ lo·∫°i: ${(anime.genres || ["Kh√¥ng c√≥"]).join(", ")}\n` +
           `üåü ƒê·ªô ph·ªï bi·∫øn: ${anime.popularity}\n` +
           `üîù X·∫øp h·∫°ng: ${anime.ranked}\n` +
           `üéñÔ∏è ƒêi·ªÉm s·ªë: ${anime.score}\n` +
           `üîû ƒê√°nh gi√°: ${anime.rating}\n\n` +
           `üìù N·ªôi dung:\n${synopsis}\n\n` +
           `üåê Link chi ti·∫øt: ${anime.url}`;
}

function downloadImage(url, dest) {
    return new Promise((resolve, reject) => {
        request(url)
            .on('error', reject)
            .pipe(fs.createWriteStream(dest))
            .on('close', resolve)
            .on('error', reject);
    });
}

function getGenreId(genre) {
    const genres = {
        action: 1,
        adventure: 2,
        cars: 3,
        comedy: 4,
        dementia: 5,
        demons: 6,
        mystery: 7,
        drama: 8,
        ecchi: 9,
        fantasy: 10,
        game: 11,
        hentai: 12,
        historical: 13,
        horror: 14,
        kids: 15,
        magic: 16,
        martialarts: 17,
        mecha: 18,
        music: 19,
        parody: 20,
        samurai: 21,
        romance: 22,
        school: 23,
        scifi: 24,
        shoujo: 25,
        shoujoai: 26,
        shounen: 27,
        shounenai: 28,
        space: 29,
        sports: 30,
        superpower: 31,
        vampire: 32,
        yaoi: 33,
        yuri: 34,
        harem: 35,
        sliceoflife: 36,
        supernatural: 37,
        military: 38,
        police: 39,
        psychological: 40,
        thriller: 41,
        seinen: 42,
        josei: 43,
    };

    return genres[genre] || null;
}

function getCurrentSeason() {
    const month = new Date().getMonth() + 1;
    if (month >= 1 && month <= 3) return "winter";
    if (month >= 4 && month <= 6) return "spring";
    if (month >= 7 && month <= 9) return "summer";
    return "fall";
}
