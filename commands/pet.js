const fs = require('fs');
const path = require('path');
const { getBalance, updateBalance } = require('../utils/currencies');
const { createPetImage } = require('../canvas/petCanvas');

const PET_FILE = path.join(__dirname, './json/pet.json');
const QUEST_TYPES = {
    DAILY: {
        "T·∫≠p th·ªÉ d·ª•c": {
            description: "Ch∆°i v·ªõi pet 3 l·∫ßn",
            requirement: 3,
            type: "play",
            reward: {
                exp: 50,
                money: 200
            }
        },
        "B·ªØa ƒÉn ƒë·∫ßy ƒë·ªß": {
            description: "Cho pet ƒÉn 3 l·∫ßn",
            requirement: 3,
            type: "feed",
            reward: {
                exp: 50,
                money: 200
            }
        },
        "Hu·∫•n luy·ªán chƒÉm ch·ªâ": {
            description: "Hu·∫•n luy·ªán pet 2 l·∫ßn",
            requirement: 2,
            type: "train",
            reward: {
                exp: 100,
                money: 500
            }
        }
    },
    ACHIEVEMENT: {
        "Chuy√™n gia hu·∫•n luy·ªán": {
            description: "ƒê·∫°t level 10",
            condition: (pet) => pet.level >= 10,
            reward: {
                exp: 500,
                money: 2000,
                title: "üéì Chuy√™n Gia"
            }
        },
        "Si√™u sao": {
            description: "ƒê·∫°t 1000 ƒëi·ªÉm s·ª©c m·∫°nh",
            condition: (pet) => (pet.power || 0) >= 1000,
            reward: {
                exp: 1000,
                money: 5000,
                title: "üí™ Si√™u Sao"
            }
        }
    }
};
const PET_TYPES = {
    DOG: {
        name: "Ch√≥",
        price: 5000,
        maxHunger: 100,
        maxHappy: 100,
        maxEnergy: 100,
        foods: ["x∆∞∆°ng", "th·ªãt", "pate"],
        activities: ["ƒëi d·∫°o", "n√©m b√≥ng", "hu·∫•n luy·ªán"]
    },
    CAT: {
        name: "M√®o",
        price: 4500,
        maxHunger: 100,
        maxHappy: 100,
        maxEnergy: 100,
        foods: ["c√°", "th·ªãt", "pate"],
        activities: ["vu·ªët ve", "ƒë·ªì ch∆°i chu·ªôt", "leo tr√®o"]
    },
    HAMSTER: {
        name: "Chu·ªôt Hamster",
        price: 2500,
        maxHunger: 100,
        maxHappy: 100,
        maxEnergy: 100,
        foods: ["h·∫°t", "rau", "tr√°i c√¢y"],
        activities: ["ch·∫°y wheel", "chui ·ªëng", "ƒë·ªì ch∆°i g·∫∑m"]
    }
};

const PET_SKILLS = {
    DOG: {
        FETCH: {
            name: "Fetch",
            description: "T√¨m ki·∫øm v·∫≠t ph·∫©m qu√Ω hi·∫øm",
            cooldown: 300000, // 5 ph√∫t
            minLevel: 1,
            effect: (pet) => {
                const rewards = [
                    { item: "x∆∞∆°ng", chance: 50, value: 100 },
                    { item: "pate", chance: 30, value: 200 },
                    { item: "b√≥ng tennis", chance: 20, value: 300 }
                ];
                const roll = Math.random() * 100;
                let sum = 0;
                for (const reward of rewards) {
                    sum += reward.chance;
                    if (roll <= sum) {
                        return `ü¶¥ T√¨m th·∫•y ${reward.item}! (${reward.value}$)`;
                    }
                }
            }
        },
        GUARD: {
            name: "Guard",
            description: "B·∫£o v·ªá ch·ªß nh√¢n, tƒÉng thu nh·∫≠p",
            cooldown: 600000, // 10 ph√∫t
            minLevel: 3,
            effect: (pet) => {
                const bonus = Math.floor(pet.level * 1.5) * 100;
                return `üõ°Ô∏è Canh g√°c th√†nh c√¥ng! Nh·∫≠n th√™m ${bonus}$ ti·ªÅn th∆∞·ªüng`;
            }
        }
    },
    CAT: {
        HUNT: {
            name: "Hunt",
            description: "SƒÉn b·∫Øt chu·ªôt, ki·∫øm ti·ªÅn",
            cooldown: 300000,
            minLevel: 1,
            effect: (pet) => {
                const caught = Math.random() < 0.7;
                const reward = Math.floor(pet.level * 100);
                return caught ? 
                    `üê≠ B·∫Øt ƒë∆∞·ª£c chu·ªôt! Nh·∫≠n ${reward}$` : 
                    "üòø Kh√¥ng b·∫Øt ƒë∆∞·ª£c g√¨...";
            }
        },
        CHARM: {
            name: "Charm",
            description: "Quy·∫øn r≈© ng∆∞·ªùi kh√°c ƒë·ªÉ nh·∫≠n qu√†",
            cooldown: 600000,
            minLevel: 3,
            effect: (pet) => {
                const gifts = ["pate cao c·∫•p", "ƒë·ªì ch∆°i m·ªõi", "khƒÉn ·∫•m"];
                const gift = gifts[Math.floor(Math.random() * gifts.length)];
                return `üò∫ D√πng v·∫ª ƒë√°ng y√™u ƒë·ªÉ nh·∫≠n ƒë∆∞·ª£c ${gift}!`;
            }
        }
    },
    HAMSTER: {
        GATHER: {
            name: "Gather",
            description: "Thu th·∫≠p h·∫°t v√† th·ª©c ƒÉn",
            cooldown: 300000,
            minLevel: 1,
            effect: (pet) => {
                const items = ["h·∫°t h∆∞·ªõng d∆∞∆°ng", "h·∫°t b√≠", "ng≈© c·ªëc"];
                const count = Math.floor(Math.random() * 3) + 1;
                const item = items[Math.floor(Math.random() * items.length)];
                return `üå∞ Thu th·∫≠p ƒë∆∞·ª£c ${count}x ${item}!`;
            }
        },
        PERFORM: {
            name: "Perform",
            description: "Bi·ªÉu di·ªÖn ƒë√°ng y√™u ƒë·ªÉ ki·∫øm ti·ªÅn",
            cooldown: 600000,
            minLevel: 3,
            effect: (pet) => {
                const tips = Math.floor((Math.random() * 5 + 5) * pet.level);
                return `üé™ Bi·ªÉu di·ªÖn th√†nh c√¥ng! Nh·∫≠n ƒë∆∞·ª£c ${tips}$ ti·ªÅn th∆∞·ªüng`;
            }
        }
    }
};
const TRAINING_ACTIVITIES = {
    DOG: {
        "v∆∞·ª£t ch∆∞·ªõng ng·∫°i": {
            exp: 20,
            powerGain: 15,
            cost: 300,
            description: "Hu·∫•n luy·ªán kh·∫£ nƒÉng v∆∞·ª£t ch∆∞·ªõng ng·∫°i v·∫≠t"
        },
        "tu·∫ßn tra": {
            exp: 25,
            powerGain: 20,
            cost: 400,
            description: "Luy·ªán t·∫≠p k·ªπ nƒÉng tu·∫ßn tra v√† canh g√°c"
        },
        "nghe l·ªánh": {
            exp: 30,
            powerGain: 25,
            cost: 500,
            description: "R√®n luy·ªán kh·∫£ nƒÉng tu√¢n theo m·ªánh l·ªánh"
        }
    },
    CAT: {
        "leo tr√®o": {
            exp: 20,
            powerGain: 15,
            cost: 300,
            description: "T·∫≠p luy·ªán k·ªπ nƒÉng leo tr√®o v√† thƒÉng b·∫±ng"
        },
        "sƒÉn m·ªìi": {
            exp: 25,
            powerGain: 20,
            cost: 400,
            description: "R√®n luy·ªán b·∫£n nƒÉng v√† k·ªπ thu·∫≠t sƒÉn m·ªìi"
        },
        "·∫©n n·∫•p": {
            exp: 30,
            powerGain: 25,
            cost: 500,
            description: "Luy·ªán t·∫≠p k·ªπ nƒÉng ·∫©n n·∫•p v√† ng·ª•y trang"
        }
    },
    HAMSTER: {
        "ch·∫°y wheel": {
            exp: 20,
            powerGain: 15,
            cost: 300,
            description: "TƒÉng s·ª©c b·ªÅn v√† t·ªëc ƒë·ªô"
        },
        "ƒë√†o hang": {
            exp: 25,
            powerGain: 20,
            cost: 400,
            description: "R√®n luy·ªán k·ªπ nƒÉng ƒë√†o hang v√† t√¨m ƒë∆∞·ªùng"
        },
        "gi·∫•u th·ª©c ƒÉn": {
            exp: 30,
            powerGain: 25,
            cost: 500,
            description: "Luy·ªán t·∫≠p kh·∫£ nƒÉng t√≠ch tr·ªØ v√† ghi nh·ªõ"
        }
    }
};

const PET_FOODS = {
    "x∆∞∆°ng": {
        price: 500,
        hunger: 25,
        happy: 5,
        energy: 20,
        description: "X∆∞∆°ng th∆°m ngon d√†nh cho ch√≥",
        effect: "TƒÉng 5% s·ª©c m·∫°nh trong 1 gi·ªù",
        type: "DOG",
        rarity: "COMMON",
        emoji: "ü¶¥"
    },
    "th·ªãt": {
        price: 800,
        hunger: 35,
        happy: 8,
        energy: 30,
        description: "Th·ªãt t∆∞∆°i ngon b·ªï d∆∞·ª°ng",
        effect: "TƒÉng 20 ƒëi·ªÉm s·ª©c m·∫°nh",
        type: ["DOG", "CAT"],
        rarity: "UNCOMMON",
        emoji: "ü•©"
    },
    "pate": {
        price: 1000,
        hunger: 40,
        happy: 15,
        energy: 40,
        description: "Pate cao c·∫•p nh·∫≠p kh·∫©u",
        effect: "TƒÉng 50% t·ªëc ƒë·ªô l√™n level trong 30 ph√∫t",
        type: ["DOG", "CAT"],
        rarity: "RARE",
        emoji: "ü•´"
    },
    "c√°": {
        price: 600,
        hunger: 30,
        happy: 10,
        energy: 25,
        description: "C√° t∆∞∆°i gi√†u dinh d∆∞·ª°ng",
        effect: "TƒÉng 10% may m·∫Øn khi sƒÉn m·ªìi",
        type: "CAT",
        rarity: "UNCOMMON",
        emoji: "üêü"
    },
    "h·∫°t": {
        price: 300,
        hunger: 20,
        happy: 5,
        energy: 15,
        description: "H·∫°t dinh d∆∞·ª°ng t·ªïng h·ª£p",
        effect: "H·ªìi 10 nƒÉng l∆∞·ª£ng m·ªói 5 ph√∫t",
        type: "HAMSTER",
        rarity: "COMMON",
        emoji: "üå∞"
    },
    "rau": {
        price: 200,
        hunger: 15,
        happy: 3,
        energy: 10,
        description: "Rau xanh t∆∞∆°i m√°t",
        effect: "TƒÉng 5% t·ªëc ƒë·ªô h·ªìi ph·ª•c",
        type: "HAMSTER",
        rarity: "COMMON",
        emoji: "ü•¨"
    },
    "tr√°i c√¢y": {
        price: 400,
        hunger: 25,
        happy: 12,
        energy: 20,
        description: "Tr√°i c√¢y t∆∞∆°i ng·ªçt",
        effect: "TƒÉng 10 ƒëi·ªÉm h·∫°nh ph√∫c",
        type: "HAMSTER",
        rarity: "UNCOMMON",
        emoji: "üçé"
    }
};

function loadPetData() {
    try {
        if (!fs.existsSync(PET_FILE)) {
            const dir = path.dirname(PET_FILE);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(PET_FILE, JSON.stringify({}));
            return {};
        }
        return JSON.parse(fs.readFileSync(PET_FILE));
    } catch (error) {
        console.error('Error loading pet data:', error);
        return {};
    }
}

function savePetData(data) {
    try {
        fs.writeFileSync(PET_FILE, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('Error saving pet data:', error);
    }
}

function getTimeLeft(lastTime, cooldown) {
    const timeLeft = cooldown - (Date.now() - lastTime);
    return timeLeft > 0 ? Math.ceil(timeLeft / 1000) : 0;
}

function createProgressBar(value, maxValue, size = 10) {
    const percentage = Math.round((value / maxValue) * size);
    const filled = '‚ñ†'.repeat(percentage);
    const empty = '‚ñ°'.repeat(size - percentage);
    return filled + empty;
}
function calculateCurrentStats(pet) {
    const now = Date.now();
    const hoursPassed = (now - pet.lastFed) / (1000 * 60 * 60);

    const hungerLoss = 5 * hoursPassed; 
    const energyLoss = 3 * hoursPassed; 
    const happyLoss = 4 * hoursPassed; 

    pet.hunger = Math.max(0, Math.min(pet.hunger - hungerLoss, PET_TYPES[pet.type].maxHunger));
    pet.energy = Math.max(0, Math.min(pet.energy - energyLoss, PET_TYPES[pet.type].maxEnergy));
    pet.happy = Math.max(0, Math.min(pet.happy - happyLoss, PET_TYPES[pet.type].maxHappy));

    return pet;
}
module.exports = {
    name: "pet",
    dev: "HNT",
    category: "Games",
    usedby: 0,
    info: "Nu√¥i th√∫ c∆∞ng ·∫£o",
    usages: ".pet [buy/feed/play/info/shop]",
    onPrefix: true,
    cooldowns: 5,

    onLaunch: async function({ api, event, target }) {
        const { threadID, messageID, senderID } = event;
        const petData = loadPetData();

        if (!target[0]) {
            return api.sendMessage(
                "üêæ H∆Ø·ªöNG D·∫™N NU√îI TH√ö C∆ØNG üêæ\n\n" +
                "1. .pet buy [dog/cat/hamster] - Mua th√∫ c∆∞ng\n" +
                "2. .pet feed [th·ª©c ƒÉn] - Cho th√∫ c∆∞ng ƒÉn\n" +
                "3. .pet play [ho·∫°t ƒë·ªông] - Ch∆°i v·ªõi th√∫ c∆∞ng\n" +
                "4. .pet info - Xem th√¥ng tin th√∫ c∆∞ng\n" +
                "5. .pet shop - Xem c·ª≠a h√†ng th√∫ c∆∞ng\n" +
                "6. .pet food - Xem c·ª≠a h√†ng th·ª©c ƒÉn\n" +
                "7. .pet skill [skill] - S·ª≠ d·ª•ng k·ªπ nƒÉng c·ªßa th√∫ c∆∞ng\n" +
                "8. .pet train - Hu·∫•n luy·ªán th√∫ c∆∞ng\n" +
                "9. .pet quest - Nh·∫≠n nhi·ªám v·ª• cho th√∫ c∆∞ng" +
                "10 .pet rename [t√™n m·ªõi] - ƒê·∫∑t t√™n m·ªõi cho th√∫ c∆∞",
                threadID, messageID
            );
        }

        const action = target[0].toLowerCase();

        switch (action) {
            case "buy": {
                if (!target[1]) {
                    return api.sendMessage(
                        "üè™ H∆Ø·ªöNG D·∫™N MUA TH√ö C∆ØNG üè™\n" +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
                        "üëâ C√°ch d√πng: .pet buy [lo·∫°i th√∫]\n" +
                        "üêï Ch√≥ (dog): 5,000$\n" +
                        "üêà M√®o (cat): 4,500$\n" +
                        "üêπ Hamster (hamster): 2,500$\n\n" +
                        "üí° L∆∞u √Ω:\n" +
                        "‚Ä¢ M·ªói ng∆∞·ªùi ch·ªâ nu√¥i ƒë∆∞·ª£c 1 pet\n" +
                        "‚Ä¢ C√≥ th·ªÉ ƒë·∫∑t t√™n cho pet khi mua\n" +
                        "‚Ä¢ C√∫ ph√°p: .pet buy [lo·∫°i] [t√™n]",
                        threadID, messageID
                    );
                }
            
                if (petData[senderID]) {
                    const currentPet = petData[senderID];
                    return api.sendMessage(
                        `‚ùå B·∫°n ƒë√£ c√≥ ${currentPet.name} r·ªìi!\n` +
                        "üí≠ H√£y chƒÉm s√≥c th·∫≠t t·ªët pet hi·ªán t·∫°i nh√©!",
                        threadID, messageID
                    );
                }
            
                const petType = target[1].toUpperCase();
                if (!PET_TYPES[petType]) {
                    return api.sendMessage(
                        "‚ùå Lo·∫°i th√∫ c∆∞ng kh√¥ng h·ª£p l·ªá!\n" +
                        "üëâ Ch·ªçn m·ªôt trong c√°c lo·∫°i: dog, cat, hamster",
                        threadID, messageID
                    );
                }
            
                const pet = PET_TYPES[petType];
                const balance = await getBalance(senderID);
            
                if (balance < pet.price) {
                    return api.sendMessage(
                        `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn!\n` +
                        `üí∞ Gi√°: ${pet.price.toLocaleString()}$\n` +
                        `üíµ S·ªë d∆∞: ${balance.toLocaleString()}$\n` +
                        `üéØ C√≤n thi·∫øu: ${(pet.price - balance).toLocaleString()}$`,
                        threadID, messageID
                    );
                }
            
                const petName = target[2] ? target[2].charAt(0).toUpperCase() + target[2].slice(1) : pet.name;
                
                const newPet = {
                    type: petType,
                    name: petName,
                    hunger: pet.maxHunger,
                    happy: pet.maxHappy,
                    energy: pet.maxEnergy,
                    level: 1,
                    exp: 0,
                    power: 10,
                    lastFed: Date.now(),
                    lastPlay: Date.now(),
                    skills: {},
                    inventory: [],
                    stats: {
                        gamesPlayed: 0,
                        foodEaten: 0,
                        trainingSessions: 0,
                        questsCompleted: 0
                    },
                    achievements: {},
                    birthday: Date.now()
                };
            
                // Th√™m k·ªπ nƒÉng c∆° b·∫£n d·ª±a tr√™n lo·∫°i pet
                Object.keys(PET_SKILLS[petType]).forEach(skillId => {
                    newPet.skills[skillId] = {
                        level: 1,
                        exp: 0,
                        lastUsed: 0
                    };
                });
            
                await updateBalance(senderID, -pet.price);
                petData[senderID] = newPet;
                savePetData(petData);
            
                return api.sendMessage(
                    "üéâ CH√öC M·ª™NG B·∫†N ƒê√É MUA PET TH√ÄNH C√îNG! üéâ\n" +
                    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
                    `üêæ T√™n: ${petName}\n` +
                    `üìã Lo·∫°i: ${pet.name}\n` +
                    `üí™ S·ª©c m·∫°nh c∆° b·∫£n: 10\n` +
                    `üéÆ K·ªπ nƒÉng c√≥ s·∫µn: ${Object.keys(PET_SKILLS[petType]).length}\n\n` +
                    "üí° L·ªùi khuy√™n:\n" +
                    "‚Ä¢ Cho pet ƒÉn th∆∞·ªùng xuy√™n\n" +
                    "‚Ä¢ Ch∆°i v·ªõi pet m·ªói ng√†y\n" +
                    "‚Ä¢ Hu·∫•n luy·ªán ƒë·ªÉ tƒÉng s·ª©c m·∫°nh\n" +
                    "‚Ä¢ L√†m nhi·ªám v·ª• ƒë·ªÉ nh·∫≠n th∆∞·ªüng\n\n" +
                    "üëâ G√µ .pet info ƒë·ªÉ xem th√¥ng tin chi ti·∫øt",
                    threadID, messageID
                );
            }
            case "feed": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
            
                if (!target[1]) {
                    const suitableFoods = Object.entries(PET_FOODS)
                        .filter(([_, info]) => 
                            Array.isArray(info.type) ? 
                            info.type.includes(pet.type) : 
                            info.type === pet.type
                        )
                        .map(([name, info]) => `${info.emoji} ${name}`)
                        .join(", ");
            
                    return api.sendMessage(
                        `üçñ CH·ªåN TH·ª®C ƒÇN CHO ${pet.name}\n` +
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n" +
                        `Th·ª©c ƒÉn ph√π h·ª£p:\n${suitableFoods}\n\n` +
                        "C√°ch d√πng: .pet feed [t√™n th·ª©c ƒÉn]",
                        threadID, messageID
                    );
                }
            
                const foodName = target[1].toLowerCase();
                const foodInfo = PET_FOODS[foodName];
            
                if (!foodInfo) {
                    return api.sendMessage(
                        "‚ùå Kh√¥ng t√¨m th·∫•y th·ª©c ƒÉn n√†y!\n" +
                        "üëâ G√µ .pet feed ƒë·ªÉ xem danh s√°ch th·ª©c ƒÉn",
                        threadID, messageID
                    );
                }
            
                const canEat = Array.isArray(foodInfo.type) ? 
                    foodInfo.type.includes(pet.type) : 
                    foodInfo.type === pet.type;
            
                if (!canEat) {
                    return api.sendMessage(
                        `‚ùå ${pet.name} kh√¥ng th·ªÉ ƒÉn ${foodName}!\n` +
                        "üëâ G√µ .pet feed ƒë·ªÉ xem th·ª©c ƒÉn ph√π h·ª£p",
                        threadID, messageID
                    );
                }
        
                const balance = await getBalance(senderID);
                if (balance < foodInfo.price) {
                    return api.sendMessage(
                        `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn!\n` +
                        `üí∞ Gi√°: ${foodInfo.price.toLocaleString()}$\n` +
                        `üíµ S·ªë d∆∞: ${balance.toLocaleString()}$`,
                        threadID, messageID
                    );
                }
            
                const fedTime = getTimeLeft(pet.lastFed, 30000);
                if (fedTime > 0) {
                    return api.sendMessage(
                        `‚è≥ Vui l√≤ng ƒë·ª£i ${fedTime} gi√¢y n·ªØa!`,
                        threadID, messageID
                    );
                }
            
                await updateBalance(senderID, -foodInfo.price);
                pet.hunger = Math.min(pet.hunger + foodInfo.hunger, PET_TYPES[pet.type].maxHunger);
                pet.happy = Math.min(pet.happy + foodInfo.happy, PET_TYPES[pet.type].maxHappy);
                pet.energy = Math.min(pet.energy + foodInfo.energy, PET_TYPES[pet.type].maxEnergy);
                pet.lastFed = Date.now();
                pet.exp += 10;
            
                if (!pet.quests) pet.quests = { daily: {} };
                pet.quests.daily.feedCount = (pet.quests.daily.feedCount || 0) + 1;
            
                if (pet.exp >= 100 * pet.level) {
                    pet.level++;
                    pet.exp = 0;
                }
            
                savePetData(petData);
                return api.sendMessage(
                    `${foodInfo.emoji} ƒê√£ cho ${pet.name} ƒÉn ${foodName}!\n\n` +
                    `üîÑ NƒÉng l∆∞·ª£ng: ${createProgressBar(pet.energy, PET_TYPES[pet.type].maxEnergy)} (${pet.energy}%)\n` +
                    `üçñ ƒê·ªô ƒë√≥i: ${createProgressBar(pet.hunger, PET_TYPES[pet.type].maxHunger)} (${pet.hunger}%)\n` +
                    `üòä H·∫°nh ph√∫c: ${createProgressBar(pet.happy, PET_TYPES[pet.type].maxHappy)} (${pet.happy}%)\n` +
                    `üìä Level: ${pet.level} (${pet.exp}/100)\n\n` +
                    `üí´ Hi·ªáu ·ª©ng: ${foodInfo.effect}`,
                    threadID, messageID
                );
            }

            case "play": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
                if (pet.hunger <= 10) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng ƒëang ƒë√≥i! H√£y cho ƒÉn tr∆∞·ªõc.",
                        threadID, messageID
                    );
                }
            
                if (pet.energy <= 10) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng ƒëang m·ªát! C·∫ßn ngh·ªâ ng∆°i.",
                        threadID, messageID
                    );
                }

                if (!target[1]) {
                    const activities = PET_TYPES[pet.type].activities;
                    return api.sendMessage(
                        `Vui l√≤ng ch·ªçn ho·∫°t ƒë·ªông:\n${activities.join(", ")}\n` +
                        `V√≠ d·ª•: .pet play ${activities[0]}`,
                        threadID, messageID
                    );
                }

                const activity = target[1].toLowerCase();
                if (!PET_TYPES[pet.type].activities.includes(activity)) {
                    return api.sendMessage(
                        `Ho·∫°t ƒë·ªông kh√¥ng h·ª£p l·ªá!\nHo·∫°t ƒë·ªông cho ${pet.name}:\n` +
                        PET_TYPES[pet.type].activities.join(", "),
                        threadID, messageID
                    );
                }

                const playTime = getTimeLeft(pet.lastPlay, 60000);
                if (playTime > 0) {
                    return api.sendMessage(
                        `Vui l√≤ng ƒë·ª£i ${playTime} gi√¢y n·ªØa m·ªõi c√≥ th·ªÉ ch∆°i!`,
                        threadID, messageID
                    );
                }

                if (pet.energy < 20) {
                    return api.sendMessage(
                        "Th√∫ c∆∞ng qu√° m·ªát ƒë·ªÉ ch∆°i! H√£y cho ƒÉn ƒë·ªÉ h·ªìi ph·ª•c nƒÉng l∆∞·ª£ng.",
                        threadID, messageID
                    );
                }

                pet.happy = Math.min(pet.happy + 20, PET_TYPES[pet.type].maxHappy);
                pet.energy = Math.max(0, pet.energy - 20);
                pet.lastPlay = Date.now();
                pet.exp += 15;

                if (pet.exp >= 100 * pet.level) {
                    pet.level++;
                    pet.exp = 0;
                }

                savePetData(petData);
                return api.sendMessage(
                    `üéÆ ƒê√£ ch∆°i ${activity} v·ªõi ${pet.name}!\n` +
                    `‚ö° NƒÉng l∆∞·ª£ng: ${createProgressBar(pet.energy, PET_TYPES[pet.type].maxEnergy)} (${pet.energy}%)\n` +
                    `üòä H·∫°nh ph√∫c: ${createProgressBar(pet.happy, PET_TYPES[pet.type].maxHappy)} (${pet.happy}%)\n` +
                    `üìä Level: ${pet.level} (${pet.exp}/100)`,
                    threadID, messageID
                );
            }

            case "info": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
            
                const updatedPet = calculateCurrentStats(pet);
                petData[senderID] = updatedPet;
                savePetData(petData);
            
                try {
                    const imagePath = await createPetImage({
                        userId: senderID,
                        userName: event.senderID,
                        pet: {
                            ...updatedPet,
                            maxEnergy: PET_TYPES[pet.type].maxEnergy,
                            maxHunger: PET_TYPES[pet.type].maxHunger,
                            maxHappy: PET_TYPES[pet.type].maxHappy
                        },
                        type: pet.type
                    });

                    return api.sendMessage(
                        {
                            body: "üêæ TH√îNG TIN TH√ö C∆ØNG üêæ\n" +
                                `T√™n: ${pet.name}\n` +
                                `Level: ${pet.level} (${pet.exp}/100)\n` +
                                `Th·ª©c ƒÉn y√™u th√≠ch: ${PET_TYPES[pet.type].foods.join(", ")}\n` +
                                `Ho·∫°t ƒë·ªông y√™u th√≠ch: ${PET_TYPES[pet.type].activities.join(", ")}`,
                            attachment: fs.createReadStream(imagePath)
                        },
                        threadID,
                        () => fs.unlinkSync(imagePath),
                        messageID
                    );
                } catch (error) {
                    console.error('Error creating pet image:', error);
                  
                    return api.sendMessage(
                        "üêæ TH√îNG TIN TH√ö C∆ØNG üêæ\n" +
                        `T√™n: ${pet.name}\n` +
                        `Lo·∫°i: ${PET_TYPES[pet.type].name}\n` +
                        `Level: ${pet.level}\n` +
                        `EXP: ${pet.exp}/100\n\n` +
                        `üîÑ NƒÉng l∆∞·ª£ng: ${createProgressBar(pet.energy, PET_TYPES[pet.type].maxEnergy)} (${pet.energy}%)\n` +
                        `üçñ ƒê·ªô ƒë√≥i: ${createProgressBar(pet.hunger, PET_TYPES[pet.type].maxHunger)} (${pet.hunger}%)\n` +
                        `üòä H·∫°nh ph√∫c: ${createProgressBar(pet.happy, PET_TYPES[pet.type].maxHappy)} (${pet.happy}%)\n\n` +
                        `üíù Th·ª©c ƒÉn y√™u th√≠ch: ${PET_TYPES[pet.type].foods.join(", ")}\n` +
                        `üéÆ Ho·∫°t ƒë·ªông y√™u th√≠ch: ${PET_TYPES[pet.type].activities.join(", ")}`,
                        threadID, messageID
                    );
                }
            }
            case "shop": {
                const balance = await getBalance(senderID);
                const currentPet = petData[senderID];
            
                let shopMessage = "üè™ C·ª¨A H√ÄNG TH√ö C∆ØNG üè™\n";
                shopMessage += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
            
                for (const [type, pet] of Object.entries(PET_TYPES)) {
                    const canBuy = balance >= pet.price;
                    const isPetOwned = currentPet?.type === type;
                    
                    shopMessage += `${isPetOwned ? "‚ú®" : canBuy ? "‚úÖ" : "‚ùå"} ${pet.name.toUpperCase()}\n`;
                    shopMessage += `‚Ä∫ Gi√°: ${pet.price.toLocaleString()}$\n`;
                    shopMessage += `‚Ä∫ Th√¥ng s·ªë c∆° b·∫£n:\n`;
                    shopMessage += `  ‚ö° NƒÉng l∆∞·ª£ng t·ªëi ƒëa: ${pet.maxEnergy}\n`;
                    shopMessage += `  üçñ ƒê·ªô ƒë√≥i t·ªëi ƒëa: ${pet.maxHunger}\n`;
                    shopMessage += `  üòä ƒê·ªô vui t·ªëi ƒëa: ${pet.maxHappy}\n`;
                    
                    shopMessage += `‚Ä∫ K·ªπ nƒÉng ƒë·∫∑c tr∆∞ng:\n`;
                    Object.entries(PET_SKILLS[type]).forEach(([skillId, skill]) => {
                        shopMessage += `  üéØ ${skill.name}: ${skill.description}\n`;
                    });
            
                    shopMessage += `‚Ä∫ Th·ª©c ƒÉn ∆∞a th√≠ch: ${pet.foods.map(food => {
                        const foodInfo = PET_FOODS[food];
                        return foodInfo ? `${foodInfo.emoji} ${food}` : food;
                    }).join(", ")}\n`;
            
                    shopMessage += `‚Ä∫ Ho·∫°t ƒë·ªông: ${pet.activities.join(", ")}\n\n`;
                }
            
                shopMessage += "üí° TH√îNG TIN TH√äM:\n";
                shopMessage += "‚Ä¢ M·ªói ng∆∞·ªùi ch·ªâ nu√¥i ƒë∆∞·ª£c 1 pet\n";
                shopMessage += "‚Ä¢ Pet c·∫ßn ƒë∆∞·ª£c cho ƒÉn v√† ch∆°i ƒë√πa th∆∞·ªùng xuy√™n\n";
                shopMessage += "‚Ä¢ C√†ng chƒÉm s√≥c t·ªët, pet c√†ng ph√°t tri·ªÉn m·∫°nh\n\n";
            
                shopMessage += `üí∞ S·ªë d∆∞ c·ªßa b·∫°n: ${balance.toLocaleString()}$\n`;
                if (currentPet) {
                    shopMessage += "‚ùå B·∫°n ƒë√£ c√≥ pet, kh√¥ng th·ªÉ mua th√™m!\n";
                }
                shopMessage += "\nMua th√∫ c∆∞ng: .pet buy [dog/cat/hamster]";
            
                return api.sendMessage(shopMessage, threadID, messageID);
            }
            case "rename": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("‚ùå B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
            
                if (!target[1]) {
                    return api.sendMessage(
                        "üëâ C√°ch ƒë·∫∑t t√™n cho pet:\n" +
                        "‚Ä¢ .pet rename [t√™n m·ªõi]\n\n" +
                        "üí° L∆∞u √Ω:\n" +
                        "‚Ä¢ T√™n ph·∫£i t·ª´ 1-15 k√Ω t·ª±\n" +
                        "‚Ä¢ Kh√¥ng ch·ª©a k√Ω t·ª± ƒë·∫∑c bi·ªát\n" +
                        "‚Ä¢ Chi ph√≠ ƒë·ªïi t√™n: 1000$",
                        threadID, messageID
                    );
                }
            
                const newName = target.slice(1).join(" ");
            
                if (newName.length > 15 || newName.length < 1) {
                    return api.sendMessage(
                        "‚ùå T√™n ph·∫£i c√≥ ƒë·ªô d√†i t·ª´ 1-15 k√Ω t·ª±!",
                        threadID, messageID
                    );
                }
            
                if (!/^[a-zA-Z0-9\s√Ä-·ªπ]+$/g.test(newName)) {
                    return api.sendMessage(
                        "‚ùå T√™n kh√¥ng ƒë∆∞·ª£c ch·ª©a k√Ω t·ª± ƒë·∫∑c bi·ªát!",
                        threadID, messageID
                    );
                }
            
                const balance = await getBalance(senderID);
                if (balance < 1000) {
                    return api.sendMessage(
                        "‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn!\n" +
                        "üí∞ Chi ph√≠ ƒë·ªïi t√™n: 1000$\n" +
                        `üíµ S·ªë d∆∞: ${balance}$`,
                        threadID, messageID
                    );
                }
            
                const oldName = pet.name;
                
                await updateBalance(senderID, -1000);
                pet.name = newName.charAt(0).toUpperCase() + newName.slice(1);
                savePetData(petData);
            
                return api.sendMessage(
                    "‚úÖ ƒê·ªïi t√™n th√†nh c√¥ng!\n\n" +
                    `T√™n c≈©: ${oldName}\n` +
                    `T√™n m·ªõi: ${pet.name}\n\n` +
                    "üí∏ -1000$ ph√≠ ƒë·ªïi t√™n",
                    threadID, messageID
                );
            }
            case "food": {
                const pet = petData[senderID];
                
                let foodMessage = "üè™ C·ª¨A H√ÄNG TH·ª®C ƒÇN üè™\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                
                const foodByRarity = {};
                Object.entries(PET_FOODS).forEach(([name, info]) => {
                    if (!foodByRarity[info.rarity]) foodByRarity[info.rarity] = [];
                    foodByRarity[info.rarity].push({name, ...info});
                });
            
                const rarityOrder = ["RARE", "UNCOMMON", "COMMON"];
                const rarityEmoji = {
                    "RARE": "üåü",
                    "UNCOMMON": "‚≠ê",
                    "COMMON": "‚ö™"
                };
            
                rarityOrder.forEach(rarity => {
                    if (foodByRarity[rarity]) {
                        foodMessage += `${rarityEmoji[rarity]} ${rarity}:\n`;
                        foodByRarity[rarity].forEach(food => {
                            const canEat = !pet || (Array.isArray(food.type) ? 
                                food.type.includes(pet.type) : 
                                food.type === pet.type);
            
                            foodMessage += `${food.emoji} ${food.name}\n`;
                            foodMessage += `‚Ä∫ Gi√°: ${food.price}$\n`;
                            foodMessage += `‚Ä∫ NƒÉng l∆∞·ª£ng +${food.hunger}%, H·∫°nh ph√∫c +${food.happy}%\n`;
                            foodMessage += `‚Ä∫ ${food.description}\n`;
                            foodMessage += `‚Ä∫ Hi·ªáu ·ª©ng: ${food.effect}\n`;
                            if (!canEat && pet) {
                                foodMessage += `‚ùå Kh√¥ng ph√π h·ª£p v·ªõi ${pet.name}\n`;
                            }
                            foodMessage += "\n";
                        });
                    }
                });
            
                if (pet) {
                    foodMessage += "\nüí° Th·ª©c ƒÉn ph√π h·ª£p v·ªõi pet c·ªßa b·∫°n:\n";
                    const suitableFoods = Object.entries(PET_FOODS)
                        .filter(([_, info]) => 
                            Array.isArray(info.type) ? 
                            info.type.includes(pet.type) : 
                            info.type === pet.type
                        )
                        .map(([name, info]) => `${info.emoji} ${name}`)
                        .join(", ");
                    foodMessage += suitableFoods;
                }
            
                foodMessage += "\n\nMua th·ª©c ƒÉn: .pet feed [t√™n th·ª©c ƒÉn]";
                return api.sendMessage(foodMessage, threadID, messageID);
            }
            case "skill": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
            
                if (!target[1]) {
                    let skillMessage = `üìñ DANH S√ÅCH K·ª∏ NƒÇNG C·ª¶A ${pet.name}\n`;
                    skillMessage += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                    
                    const petSkills = PET_SKILLS[pet.type];
                    for (const [skillId, skill] of Object.entries(petSkills)) {
                        const available = pet.level >= skill.minLevel;
                        const cooldownLeft = getTimeLeft(pet.lastSkill?.[skillId] || 0, skill.cooldown);
                        
                        skillMessage += `${available ? "‚úÖ" : "‚ùå"} ${skill.name}\n`;
                        skillMessage += `‚Ä∫ M√¥ t·∫£: ${skill.description}\n`;
                        skillMessage += `‚Ä∫ Y√™u c·∫ßu: Level ${skill.minLevel}\n`;
                        skillMessage += `‚Ä∫ H·ªìi chi√™u: ${skill.cooldown/60000} ph√∫t\n`;
                        if (cooldownLeft > 0) {
                            skillMessage += `‚Ä∫ C√≤n: ${Math.ceil(cooldownLeft/1000)} gi√¢y\n`;
                        }
                        skillMessage += "\n";
                    }
                    
                    skillMessage += "S·ª≠ d·ª•ng: .pet skill [t√™n k·ªπ nƒÉng]";
                    return api.sendMessage(skillMessage, threadID, messageID);
                }
            
                const skillName = target[1].toUpperCase();
                const skill = PET_SKILLS[pet.type][skillName];
                
                if (!skill) {
                    return api.sendMessage(
                        "‚ùå K·ªπ nƒÉng kh√¥ng h·ª£p l·ªá!\n" +
                        "G√µ .pet skill ƒë·ªÉ xem danh s√°ch k·ªπ nƒÉng", 
                        threadID, messageID
                    );
                }
            
                if (pet.level < skill.minLevel) {
                    return api.sendMessage(
                        `‚ùå C·∫ßn ƒë·∫°t level ${skill.minLevel} ƒë·ªÉ s·ª≠ d·ª•ng k·ªπ nƒÉng n√†y!`,
                        threadID, messageID
                    );
                }
            
                const cooldownLeft = getTimeLeft(pet.lastSkill?.[skillName] || 0, skill.cooldown);
                if (cooldownLeft > 0) {
                    return api.sendMessage(
                        `‚è≥ Vui l√≤ng ƒë·ª£i ${Math.ceil(cooldownLeft/1000)} gi√¢y n·ªØa!`,
                        threadID, messageID
                    );
                }
            
                if (!pet.lastSkill) pet.lastSkill = {};
                
                const result = skill.effect(pet);
                pet.lastSkill[skillName] = Date.now();
                pet.exp += 5; 
                
                if (pet.exp >= 100 * pet.level) {
                    pet.level++;
                    pet.exp = 0;
                }
            
                savePetData(petData);
                return api.sendMessage(
                    `üéØ ${pet.name} s·ª≠ d·ª•ng ${skill.name}!\n` +
                    `${result}\n` +
                    `‚≠ê +5 EXP (${pet.exp}/100)`,
                    threadID, messageID
                );
            }
            case "train": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
                if (pet.hunger <= 10) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng ƒëang ƒë√≥i! H√£y cho ƒÉn tr∆∞·ªõc.",
                        threadID, messageID
                    );
                }
            
                if (pet.energy <= 10) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng ƒëang m·ªát! C·∫ßn ngh·ªâ ng∆°i.",
                        threadID, messageID
                    );
                }
            
                if (pet.happy <= 10) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng ƒëang bu·ªìn! H√£y ch∆°i v·ªõi n√≥.",
                        threadID, messageID
                    );
                }
                if (!target[1]) {
                    let trainMessage = `üéØ HU·∫§N LUY·ªÜN CHO ${pet.name}\n`;
                    trainMessage += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                    
                    const activities = TRAINING_ACTIVITIES[pet.type];
                    for (const [name, info] of Object.entries(activities)) {
                        trainMessage += `üî∏ ${name}\n`;
                        trainMessage += `‚Ä∫ Chi ph√≠: ${info.cost}$\n`;
                        trainMessage += `‚Ä∫ EXP: +${info.exp}\n`;
                        trainMessage += `‚Ä∫ S·ª©c m·∫°nh: +${info.powerGain}\n`;
                        trainMessage += `‚Ä∫ ${info.description}\n\n`;
                    }
                    
                    trainMessage += "S·ª≠ d·ª•ng: .pet train [t√™n ho·∫°t ƒë·ªông]";
                    return api.sendMessage(trainMessage, threadID, messageID);
                }
            
                const activity = target.slice(1).join(" ").toLowerCase();
                const trainingInfo = TRAINING_ACTIVITIES[pet.type][activity];
            
                if (!trainingInfo) {
                    return api.sendMessage(
                        "‚ùå Ho·∫°t ƒë·ªông hu·∫•n luy·ªán kh√¥ng h·ª£p l·ªá!\n" +
                        "G√µ .pet train ƒë·ªÉ xem danh s√°ch ho·∫°t ƒë·ªông", 
                        threadID, messageID
                    );
                }
            
                const trainCooldown = getTimeLeft(pet.lastTrain || 0, 300000); 
                if (trainCooldown > 0) {
                    return api.sendMessage(
                        `‚è≥ Th√∫ c∆∞ng ƒëang m·ªát, vui l√≤ng ƒë·ª£i ${Math.ceil(trainCooldown/1000)} gi√¢y n·ªØa!`,
                        threadID, messageID
                    );
                }
            
                if (pet.energy < 30) {
                    return api.sendMessage(
                        "‚ùå Th√∫ c∆∞ng qu√° m·ªát ƒë·ªÉ t·∫≠p luy·ªán! H√£y cho ƒÉn ƒë·ªÉ h·ªìi ph·ª•c nƒÉng l∆∞·ª£ng.",
                        threadID, messageID
                    );
                }
            
                const balance = await getBalance(senderID);
                if (balance < trainingInfo.cost) {
                    return api.sendMessage(
                        `‚ùå B·∫°n kh√¥ng ƒë·ªß ti·ªÅn! C·∫ßn ${trainingInfo.cost}$ ƒë·ªÉ hu·∫•n luy·ªán.`,
                        threadID, messageID
                    );
                }
            
                await updateBalance(senderID, -trainingInfo.cost);
                pet.power = (pet.power || 0) + trainingInfo.powerGain;
                pet.exp += trainingInfo.exp;
                pet.energy = Math.max(0, pet.energy - 30);
                pet.lastTrain = Date.now();
            
                if (pet.exp >= 100 * pet.level) {
                    pet.level++;
                    pet.exp = 0;
                }
            
                savePetData(petData);
                return api.sendMessage(
                    `üéØ ${pet.name} ƒë√£ ho√†n th√†nh bu·ªïi hu·∫•n luy·ªán ${activity}!\n\n` +
                    `üí™ S·ª©c m·∫°nh +${trainingInfo.powerGain} (T·ªïng: ${pet.power})\n` +
                    `‚≠ê EXP +${trainingInfo.exp} (${pet.exp}/100)\n` +
                    `‚ö° NƒÉng l∆∞·ª£ng: ${createProgressBar(pet.energy, PET_TYPES[pet.type].maxEnergy)} (${pet.energy}%)\n` +
                    `üìä Level: ${pet.level}`,
                    threadID, messageID
                );
            }

            case "quest": {
                const pet = petData[senderID];
                if (!pet) {
                    return api.sendMessage("B·∫°n ch∆∞a c√≥ th√∫ c∆∞ng!", threadID, messageID);
                }
            
                if (!pet.quests) {
                    pet.quests = {
                        daily: {},
                        achievements: {},
                        lastDaily: 0
                    };
                }
            
                const now = Date.now();
                const lastDaily = pet.quests.lastDaily || 0;
                if (now - lastDaily > 86400000) { 
                    pet.quests.daily = {};
                    pet.quests.lastDaily = now;
                }
            
                if (!target[1]) {
                    let questMessage = "üìã DANH S√ÅCH NHI·ªÜM V·ª§\n";
                    questMessage += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n";
                    
                    questMessage += "üåÖ NHI·ªÜM V·ª§ H√ÄNG NG√ÄY:\n";
                    for (const [questId, quest] of Object.entries(QUEST_TYPES.DAILY)) {
                        const progress = pet.quests.daily[questId] || 0;
                        const completed = progress >= quest.requirement;
                        questMessage += `${completed ? "‚úÖ" : "‚ùå"} ${quest.description}\n`;
                        questMessage += `‚Ä∫ Ti·∫øn ƒë·ªô: z${progress}/${quest.requirement}\n`;
                        questMessage += `‚Ä∫ Ph·∫ßn th∆∞·ªüng: ${quest.reward.exp} EXP, ${quest.reward.money}$\n\n`;
                    }
                    
                    questMessage += "üèÜ TH√ÄNH T·ª∞U:\n";
                    for (const [achieveId, achieve] of Object.entries(QUEST_TYPES.ACHIEVEMENT)) {
                        const completed = achieve.condition(pet);
                        const claimed = pet.quests.achievements[achieveId];
                        questMessage += `${completed ? (claimed ? "‚úÖ" : "‚≠ê") : "‚ùå"} ${achieve.description}\n`;
                        if (!claimed) {
                            questMessage += `‚Ä∫ Ph·∫ßn th∆∞·ªüng: ${achieve.reward.exp} EXP, ${achieve.reward.money}$\n`;
                            if (achieve.reward.title) questMessage += `‚Ä∫ Danh hi·ªáu: ${achieve.reward.title}\n`;
                        }
                        questMessage += "\n";
                    }
                    
                    questMessage += "üí° S·ª≠ d·ª•ng:\n";
                    questMessage += "‚Ä¢ .pet quest claim [daily/achieve] - Nh·∫≠n ph·∫ßn th∆∞·ªüng\n";
                    questMessage += "‚Ä¢ .pet quest info - Xem chi ti·∫øt nhi·ªám v·ª•";
                    
                    return api.sendMessage(questMessage, threadID, messageID);
                }
            
                const subCommand = target[1].toLowerCase();
                
                if (subCommand === "claim") {
                    const questType = target[2]?.toLowerCase();
                    if (!questType || !["daily", "achieve"].includes(questType)) {
                        return api.sendMessage("‚ùå Vui l√≤ng ch·ªçn lo·∫°i ph·∫ßn th∆∞·ªüng (daily/achieve)!", threadID, messageID);
                    }
            
                    if (questType === "daily") {
                        let claimed = false;
                        let totalExp = 0;
                        let totalMoney = 0;
            
                        for (const [questId, quest] of Object.entries(QUEST_TYPES.DAILY)) {
                            const progress = pet.quests.daily[questId] || 0;
                            if (progress >= quest.requirement && !pet.quests.daily[`${questId}_claimed`]) {
                                claimed = true;
                                totalExp += quest.reward.exp;
                                totalMoney += quest.reward.money;
                                pet.quests.daily[`${questId}_claimed`] = true;
                            }
                        }
            
                        if (!claimed) {
                            return api.sendMessage("‚ùå Kh√¥ng c√≥ ph·∫ßn th∆∞·ªüng n√†o ƒë·ªÉ nh·∫≠n!", threadID, messageID);
                        }
            
                        pet.exp += totalExp;
                        await updateBalance(senderID, totalMoney);
            
                        if (pet.exp >= 100 * pet.level) {
                            pet.level++;
                            pet.exp = 0;
                        }
            
                        savePetData(petData);
                        return api.sendMessage(
                            `üéÅ Nh·∫≠n th∆∞·ªüng th√†nh c√¥ng!\n` +
                            `‚≠ê +${totalExp} EXP\n` +
                            `üí∞ +${totalMoney}$\n` +
                            `üìä Level: ${pet.level} (${pet.exp}/100)`,
                            threadID, messageID
                        );
                    }
            
                    if (questType === "achieve") {
                        let claimed = false;
                        let totalExp = 0;
                        let totalMoney = 0;
                        let titles = [];
            
                        for (const [achieveId, achieve] of Object.entries(QUEST_TYPES.ACHIEVEMENT)) {
                            if (achieve.condition(pet) && !pet.quests.achievements[achieveId]) {
                                claimed = true;
                                totalExp += achieve.reward.exp;
                                totalMoney += achieve.reward.money;
                                if (achieve.reward.title) titles.push(achieve.reward.title);
                                pet.quests.achievements[achieveId] = true;
                            }
                        }
            
                        if (!claimed) {
                            return api.sendMessage("‚ùå Kh√¥ng c√≥ th√†nh t·ª±u n√†o ƒë·ªÉ nh·∫≠n!", threadID, messageID);
                        }
            
                        pet.exp += totalExp;
                        await updateBalance(senderID, totalMoney);
            
                        if (pet.exp >= 100 * pet.level) {
                            pet.level++;
                            pet.exp = 0;
                        }
            
                        savePetData(petData);
                        let rewardMsg = `üèÜ Nh·∫≠n th∆∞·ªüng th√†nh t·ª±u!\n` +
                                       `‚≠ê +${totalExp} EXP\n` +
                                       `üí∞ +${totalMoney}$\n` +
                                       `üìä Level: ${pet.level} (${pet.exp}/100)`;
                        
                        if (titles.length > 0) {
                            rewardMsg += `\nüéóÔ∏è Danh hi·ªáu m·ªõi: ${titles.join(", ")}`;
                        }
            
                        return api.sendMessage(rewardMsg, threadID, messageID);
                    }
                }
            
                return api.sendMessage("‚ùå L·ªánh kh√¥ng h·ª£p l·ªá! G√µ .pet quest ƒë·ªÉ xem h∆∞·ªõng d·∫´n.", threadID, messageID);
            }
        }
    }
};
