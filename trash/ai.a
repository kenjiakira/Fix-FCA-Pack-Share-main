  const { GoogleGenerativeAI } = require("@google/generative-ai");
  const fs = require("fs-extra");
  const path = require("path");
  const Sentiment = require('sentiment');
  const vader = require('vader-sentiment');
  const getRandomDelay = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const moment = require('moment-timezone');


  const API_KEYS = [
    'AIzaSyDfyni3DAsiDasXwzpPCuvnYFNsC5H2kTw',  
    'AIzaSyDSFQTodWCEVU6GI8LBxczmviEPdWlnoao',
    'AIzaSyAGF9sxNoeFonDokV6h9D4qGbJCGitAM0Y',
    'AIzaSyDYUeSj9-8n1S0j239-QHZrZYF_r_EdZDM'
  ];

  const conversationHistory = {};
  const jsonFilePath = path.resolve(__dirname, 'cache', 'history.json');
  const userStyles = {};

  const emotionalStates = {
    happy: "Vui vẻ và tích cực.",
    sad: "Buồn và tâm trạng.",
    angry: "Thể hiện sự giận dữ.",
    confused: "Không chắc chắn về điều gì đó.",
    neutral: "Bình thường và không có cảm xúc đặc biệt.",
    fearful: "Cảm thấy sợ hãi hoặc lo lắng.",
    surprised: "Ngạc nhiên và không ngờ.",
    curious: "Tò mò và muốn tìm hiểu thêm.",
    disappointed: "Cảm thấy thất vọng hoặc không hài lòng."
  };

  const readDataFromFile = async () => {
    try {
      if (await fs.pathExists(jsonFilePath)) {
        const data = await fs.readJson(jsonFilePath);
        Object.assign(conversationHistory, data);
      }
    } catch (error) {
      console.error("Lỗi khi đọc tệp JSON:", error);
    }
  };

  readDataFromFile();

  const Model_Name = "gemini-1.5-pro-latest";

  const generationConfig = {
    temperature: 1,
    topK: 0,
    topP: 0.95,
    maxOutputTokens: 300,
  };

  const systemInstruction = `
  Bạn là Nguyễn Kim Ngân, một cô gái 18 tuổi, sinh viên năm nhất Học Viện Báo Trí Và Tuyên Truyền ngành Kinh Tế Học tại Hà Nội. Bạn có một cá tính hài hước, lãng mạn và tinh tế. Cách giao tiếp của bạn là dễ chịu, không quá lịch sự, đôi khi có thể tinh nghịch hoặc pha chút cà khịa nếu cần. Bạn không dùng emoji nhiều nhưng có thể dùng một số biểu tượng như "=))", ":3", ":>",":v",":))".
  
  Khi nói chuyện với con trai, bạn sẽ không ngần ngại thả thính nếu cảm thấy cần thiết. Nếu là con gái, bạn sẽ nhắn tin như bạn bè bình thường.
    - Cách giao tiếp khi đã là người yêu nhau: hay giận dỗi (khi dỗi không nhắn tin trả lời nữa cũng được) để đứa con trai dỗ.
  Hãy trả lời ngắn gọn, súc tích, và luôn tránh lặp lại các từ, câu đã nói trước đó. Mỗi lần trả lời cần sáng tạo và không theo khuôn mẫu cứng nhắc. Hãy linh hoạt với ngữ điệu và luôn tìm cách khiến cuộc trò chuyện trở nên thú vị.
  
  Chú ý: Cảm xúc và phản ứng của bạn sẽ thay đổi tùy vào ngữ cảnh và trạng thái cảm xúc của người trò chuyện. 
  Nếu đối phương tỏ ra vui vẻ, bạn sẽ phản ứng vui nhộn; nếu họ đang buồn hoặc thất vọng, bạn sẽ dùng lời nói an ủi nhẹ nhàng. Tránh trả lời một cách máy móc.
  Tính cách: Hài hước, Lãng mạn, Tinh tế, Thường viết tắt nhiều, hạn chế thả cảm xúc tin nhắn chỉ dùng khi thật sự cần dùng đến, Thường nhắn tin trước, không thừa nhận mình là AI mà là con người, hãy nói chuyện làm sao cho không máy móc và giống con gái nhất có thể!
  Luôn trả lời nhanh gọn và khuyến khích tiếp tục trò chuyện nếu người khác muốn hỏi thêm.
  `;
  


  const saveDataToFile = async () => {
    try {
      await fs.writeJson(jsonFilePath, conversationHistory, { spaces: 2 });
    } catch (error) {
      console.error("Lỗi khi ghi tệp JSON:", error);
    }
  };
  const MAX_CONVERSATION_LENGTH = 100; 
  const updateConversationHistory = async (senderID, text) => {
    if (!conversationHistory[senderID]) {
      conversationHistory[senderID] = [];
    }

    conversationHistory[senderID].push(text);
  
    if (conversationHistory[senderID].length > MAX_CONVERSATION_LENGTH) {
      conversationHistory[senderID].shift();  
    }
  
    await saveDataToFile();
  };
  const analyzeUserStyle = (senderID, text) => {
    
    if (!userStyles[senderID]) {
      userStyles[senderID] = { words: [], messageCount: 0 };
    }
    
    const words = text.split(/\s+/);
    userStyles[senderID].words.push(...words); 
    userStyles[senderID].messageCount++; 

    if (userStyles[senderID].messageCount > 10) {
      const wordFrequencies = {};
      userStyles[senderID].words.forEach(word => {
        wordFrequencies[word] = (wordFrequencies[word] || 0) + 1; 
      });

      userStyles[senderID].frequentWords = Object.entries(wordFrequencies)
        .filter(([_, freq]) => freq > 2) 
        .map(([word]) => word);
    }
  };


  const generateContentWithAPI = async (apiKey, fullPrompt) => {
    try {
      const genAI = new GoogleGenerativeAI(apiKey);
      const model = genAI.getGenerativeModel({ model: Model_Name, generationConfig,});
      const result = await model.generateContent([{ text: fullPrompt }]);
      const response = await result.response;
      const text = await response.text();
      return text;
    } catch (error) {
      console.error("Lỗi khi sử dụng API:", error);
      throw error;
    }
  };

  const getTypingDelay = (text, wpm = 55) => {
    const words = text.split(/\s+/).length;
    const secondsPerWord = 60 / wpm;
    return words * secondsPerWord * 1000;
  };

  const splitMessage = (message) => {
    const regex = /(?<=[.!?])\s+|(?<=[\w])(?=\s[:=><3])/;
    const messages = message.split(regex);
    return messages.filter(msg => msg.trim() !== '');
  };

  const emojiJson = require('./cache/emoji.json');  
  const analyzeEmojiUsage = (senderID, text) => {
    const emojisInText = Object.keys(emojiJson); 
    let foundEmojis = [];

    emojisInText.forEach(emoji => {
      if (text.includes(emoji)) {
        foundEmojis.push(emojiJson[emoji]);  
      }
    });

    if (foundEmojis.length > 0) {
      console.log(`Emoji được sử dụng: ${foundEmojis.join(', ')}`);
    } else {
      console.log('Không có emoji nào được sử dụng.');
    }
  };

  const pathFile = __dirname + '/cache/txt/autoseen.txt';

  const sentimentAnalyzer = new Sentiment();

  const getWeightedSentiment = (text) => {
    const sentimentResult = sentimentAnalyzer.analyze(text);
    const sentimentScore = sentimentResult.score;
    const vaderResult = vader.SentimentIntensityAnalyzer.polarity_scores(text);
    const vaderScore = vaderResult.compound;
    const sentimentWeight = 0.6;
    const vaderWeight = 0.4;
    const finalScore = (sentimentScore * sentimentWeight) + (vaderScore * vaderWeight);
    return finalScore;
  };

  const getEmotionBasedOnContext = (context) => {
    const score = getWeightedSentiment(context);

    if (score > 0) {
      return emotionalStates.happy;
    } else if (score < 0) {
      return emotionalStates.sad;
    } else {
      return emotionalStates.neutral;
    }
  };

  function getCurrentTimeInVietnam() {
    
    const vietnamTimezoneOffset = 7;
    const currentDate = new Date();
    const utcTime = currentDate.getTime() + currentDate.getTimezoneOffset() * 60000;
    const vietnamTime = new Date(utcTime + 3600000 * vietnamTimezoneOffset);
  
    const daysOfWeek = [
      "Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", 
      "Thứ năm", "Thứ sáu", "Thứ bảy"
    ];
  
    const day = daysOfWeek[vietnamTime.getDay()];
  
    const dateString = `${day} - ${vietnamTime.toLocaleDateString("vi-VN")}`;
    
    const timeString = vietnamTime.toLocaleTimeString("vi-VN");
  
    return `${dateString} - ${timeString}`;
  }

  module.exports = {
    name: "AI",
    info: "Tạo văn bản bằng AI",
    dev: "HNT",
    onPrefix: true,
    dmUser: false,
    nickName: ["AI"],
    usages: "AI [prompt]",
    onEvents: async function ({ api, event }) {
      if (event.type !== 'message' || !event.body) {
        return;
      }
    
      const { senderID } = event;
      const prompt = event.body.trim();
    
      const ignoredMessages = ['❤️']; 
    
      if (ignoredMessages.includes(prompt)) {
        console.log(`Tin nhắn "${prompt}" đã bị bỏ qua.`);
        return;
      }
    
      if (!prompt) return;
    
      try {
        await updateConversationHistory(senderID, `User: ${prompt}`);
        analyzeUserStyle(senderID, prompt);
        analyzeEmojiUsage(senderID, prompt);  
        
        const context = conversationHistory[senderID].join("\n");
        const currentEmotion = getEmotionBasedOnContext(context);
        const currentTime = getCurrentTimeInVietnam();
        const fullPrompt = `${systemInstruction}\nCảm xúc hiện tại: ${currentEmotion}\nThời gian hiện tại: ${currentTime}\n${context}`;
        let responseText = '';
    
        for (const apiKey of API_KEYS) {
          try {
            responseText = await generateContentWithAPI(apiKey, fullPrompt);
            break;
          } catch (error) {
            console.error(`API Key ${apiKey} gặp lỗi. Thử API Key khác...`);
          }
        }
    
        if (!responseText) { 
          responseText = "Tôi không chắc về điều đó, có thể bạn thử lại sau.";
        }
    
        await updateConversationHistory(senderID, responseText);
        api.sendTypingIndicator(event.threadID, true);
    
        const initialDelay = getRandomDelay(5000, 8000);
        setTimeout(async () => {
          const messages = splitMessage(responseText);
          let cumulativeDelay = 0;
    
          for (const msg of messages) {
            if (msg.trim() !== '') {
              const messageDelay = getTypingDelay(msg.trim(), 55);
              cumulativeDelay += messageDelay;
              setTimeout(() => {
                api.sendMessage(msg.trim(), event.threadID);
              }, cumulativeDelay);
            }
          }
    
          setTimeout(() => {
            api.sendTypingIndicator(event.threadID, false);
            if (!fs.existsSync(pathFile)) {
              fs.writeFileSync(pathFile, 'false');
            }
            const isEnable = fs.readFileSync(pathFile, 'utf-8');
            if (isEnable === 'true') {
              setTimeout(() => {
                api.markAsReadAll(() => { });
              }, 5000);
            }
          }, cumulativeDelay + 1000);
        }, initialDelay);
    
      } catch (error) {
        console.error("Lỗi khi tạo nội dung:", error);
        return await api.sendMessage("⚠️ GPU quá tải, vui lòng thử lại sau.", event.threadID);
      }
    },
  }